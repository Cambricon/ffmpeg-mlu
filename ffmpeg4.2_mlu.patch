From a337dafe79ca484cda3bebad39d625f5c79cf7d9 Mon Sep 17 00:00:00 2001
From: solution-sdk <solution-sdk@cambricon.com>
Date: Mon, 15 Mar 2021 16:55:16 +0800
Subject: [PATCH] gen new patch

---
 configure                       |   17 +
 doc/examples/Makefile           |    1 +
 doc/examples/mlumpp_transcode.c |  396 +++++++++
 libavcodec/Makefile             |    8 +
 libavcodec/allcodecs.c          |    8 +
 libavcodec/mlumpp_dec.c         | 1701 +++++++++++++++++++++++++++++++++++++++
 libavcodec/mlumpp_enc_h264.c    |  155 ++++
 libavcodec/mlumpp_enc_hevc.c    |  152 ++++
 libavcodec/mlumpp_enc_jpeg.c    |  844 +++++++++++++++++++
 libavcodec/mlumpp_mluop.c       |  122 +++
 libavcodec/mlumpp_mluop.h       |   33 +
 libavcodec/mlumpp_vid_enc.c     | 1321 ++++++++++++++++++++++++++++++
 libavcodec/mlumpp_vid_enc.h     |  118 +++
 libavfilter/Makefile            |    1 +
 libavfilter/allfilters.c        |    1 +
 libavfilter/vf_sr_mlu.c         |  271 +++++++
 16 files changed, 5149 insertions(+)
 create mode 100755 doc/examples/mlumpp_transcode.c
 mode change 100644 => 100755 libavcodec/Makefile
 mode change 100644 => 100755 libavcodec/allcodecs.c
 create mode 100755 libavcodec/mlumpp_dec.c
 create mode 100755 libavcodec/mlumpp_enc_h264.c
 create mode 100755 libavcodec/mlumpp_enc_hevc.c
 create mode 100755 libavcodec/mlumpp_enc_jpeg.c
 create mode 100755 libavcodec/mlumpp_mluop.c
 create mode 100755 libavcodec/mlumpp_mluop.h
 create mode 100755 libavcodec/mlumpp_vid_enc.c
 create mode 100755 libavcodec/mlumpp_vid_enc.h
 create mode 100644 libavfilter/vf_sr_mlu.c

diff --git a/configure b/configure
index 34c2adb..8f5bddf 100755
--- a/configure
+++ b/configure
@@ -340,6 +340,7 @@ External library support:
   --disable-vaapi          disable Video Acceleration API (mainly Unix/Intel) code [autodetect]
   --disable-vdpau          disable Nvidia Video Decode and Presentation API for Unix code [autodetect]
   --disable-videotoolbox   disable VideoToolbox code [autodetect]
+  --enable-mlumpp          enable Cambricon MLU Media Process Platform code (mlumpp) [no]
 
 Toolchain options:
   --arch=ARCH              select architecture [$arch]
@@ -1685,6 +1686,7 @@ EXAMPLE_LIST="
     transcoding_example
     vaapi_encode_example
     vaapi_transcode_example
+    mlumpp_transcode_example
 "
 
 EXTERNAL_AUTODETECT_LIBRARY_LIST="
@@ -1738,6 +1740,7 @@ EXTERNAL_LIBRARY_VERSION3_LIST="
     libvo_amrwbenc
     mbedtls
     rkmpp
+    mlumpp
 "
 
 EXTERNAL_LIBRARY_GPLV3_LIST="
@@ -3014,11 +3017,14 @@ h264_mediacodec_decoder_deps="mediacodec"
 h264_mediacodec_decoder_select="h264_mp4toannexb_bsf h264_parser"
 h264_mmal_decoder_deps="mmal"
 h264_nvenc_encoder_deps="nvenc"
+h264_mlumpp_encoder_deps="mlumpp"
 h264_omx_encoder_deps="omx"
 h264_qsv_decoder_select="h264_mp4toannexb_bsf h264_parser qsvdec"
 h264_qsv_encoder_select="qsvenc"
 h264_rkmpp_decoder_deps="rkmpp"
 h264_rkmpp_decoder_select="h264_mp4toannexb_bsf"
+h264_mlumpp_decoder_deps="mlumpp"
+h264_mlumpp_decoder_select="h264_mp4toannexb_bsf"
 h264_vaapi_encoder_select="cbs_h264 vaapi_encode"
 h264_v4l2m2m_decoder_deps="v4l2_m2m h264_v4l2_m2m"
 h264_v4l2m2m_decoder_select="h264_mp4toannexb_bsf"
@@ -3029,16 +3035,21 @@ hevc_cuvid_decoder_select="hevc_mp4toannexb_bsf"
 hevc_mediacodec_decoder_deps="mediacodec"
 hevc_mediacodec_decoder_select="hevc_mp4toannexb_bsf hevc_parser"
 hevc_nvenc_encoder_deps="nvenc"
+hevc_mlumpp_encoder_deps="mlumpp"
 hevc_qsv_decoder_select="hevc_mp4toannexb_bsf hevc_parser qsvdec"
 hevc_qsv_encoder_select="hevcparse qsvenc"
 hevc_rkmpp_decoder_deps="rkmpp"
 hevc_rkmpp_decoder_select="hevc_mp4toannexb_bsf"
+hevc_mlumpp_decoder_deps="mlumpp"
+hevc_mlumpp_decoder_select="hevc_mp4toannexb_bsf"
 hevc_vaapi_encoder_deps="VAEncPictureParameterBufferHEVC"
 hevc_vaapi_encoder_select="cbs_h265 vaapi_encode"
 hevc_v4l2m2m_decoder_deps="v4l2_m2m hevc_v4l2_m2m"
 hevc_v4l2m2m_decoder_select="hevc_mp4toannexb_bsf"
 hevc_v4l2m2m_encoder_deps="v4l2_m2m hevc_v4l2_m2m"
 mjpeg_cuvid_decoder_deps="cuvid"
+mjpeg_mlumpp_decoder_deps="mlumpp"
+mjpeg_mlumpp_encoder_deps="mlumpp"
 mjpeg_qsv_encoder_deps="libmfx"
 mjpeg_qsv_encoder_select="qsvenc"
 mjpeg_vaapi_encoder_deps="VAEncPictureParameterBufferJPEG"
@@ -3069,6 +3080,7 @@ vc1_mmal_decoder_deps="mmal"
 vc1_qsv_decoder_select="qsvdec vc1_parser"
 vc1_v4l2m2m_decoder_deps="v4l2_m2m vc1_v4l2_m2m"
 vp8_cuvid_decoder_deps="cuvid"
+vp8_mlumpp_decoder_deps="mlumpp"
 vp8_mediacodec_decoder_deps="mediacodec"
 vp8_qsv_decoder_select="qsvdec vp8_parser"
 vp8_rkmpp_decoder_deps="rkmpp"
@@ -3077,6 +3089,7 @@ vp8_vaapi_encoder_select="vaapi_encode"
 vp8_v4l2m2m_decoder_deps="v4l2_m2m vp8_v4l2_m2m"
 vp8_v4l2m2m_encoder_deps="v4l2_m2m vp8_v4l2_m2m"
 vp9_cuvid_decoder_deps="cuvid"
+vp9_mlumpp_decoder_deps="mlumpp"
 vp9_mediacodec_decoder_deps="mediacodec"
 vp9_rkmpp_decoder_deps="rkmpp"
 vp9_vaapi_encoder_deps="VAEncPictureParameterBufferVP9"
@@ -6367,6 +6380,10 @@ enabled rkmpp             && { require_pkg_config rkmpp rockchip_mpp  rockchip/r
                              }
 enabled vapoursynth       && require_pkg_config vapoursynth "vapoursynth-script >= 42" VSScript.h vsscript_init
 
+if enabled mlumpp; then
+    require_headers  cn_video_dec.h && require_headers  cn_video_enc.h || die "ERROR: mlumpp requires proper neuware environment";
+    check_lib cncodec cn_video_dec.h cnvideoDecQueryAvailInputBuf -lcncodec -lcnrt -lcndrv || die "ERROR: mlumpp requires 1.3 or above neuware environment" ;
+fi
 
 if enabled gcrypt; then
     GCRYPT_CONFIG="${cross_prefix}libgcrypt-config"
diff --git a/doc/examples/Makefile b/doc/examples/Makefile
index 2935424..d3369f8 100644
--- a/doc/examples/Makefile
+++ b/doc/examples/Makefile
@@ -21,6 +21,7 @@ EXAMPLES-$(CONFIG_TRANSCODE_AAC_EXAMPLE)     += transcode_aac
 EXAMPLES-$(CONFIG_TRANSCODING_EXAMPLE)       += transcoding
 EXAMPLES-$(CONFIG_VAAPI_ENCODE_EXAMPLE)      += vaapi_encode
 EXAMPLES-$(CONFIG_VAAPI_TRANSCODE_EXAMPLE)   += vaapi_transcode
+EXAMPLES-$(CONFIG_MLUMPP_TRANSCODE_EXAMPLE)   += mlumpp_transcode
 
 EXAMPLES       := $(EXAMPLES-yes:%=doc/examples/%$(PROGSSUF)$(EXESUF))
 EXAMPLES_G     := $(EXAMPLES-yes:%=doc/examples/%$(PROGSSUF)_g$(EXESUF))
diff --git a/doc/examples/mlumpp_transcode.c b/doc/examples/mlumpp_transcode.c
new file mode 100755
index 0000000..8aca30a
--- /dev/null
+++ b/doc/examples/mlumpp_transcode.c
@@ -0,0 +1,396 @@
+/*
+ * MLU MPP Video Acceleration API (video transcoding) transcode sample
+ * Copyright (C) [2019] by Cambricon, Inc. All rights reserved
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+/**
+ * @file
+ * Cambricon MLUMPP-accelerated transcoding example.
+ *
+ * @example mlumpp_transcode.c
+ * This example shows how to do mlumpp-accelerated transcoding with multi-threads supports.
+ * Usage: mlu_transcode codec input_stream codec output_path file extension
+ * e.g: - mlu_transcode h264_mludec input.mp4 hevc_mluenc ./ mp4
+ *      - mlu_transcode hevc_mludec input.mp4 h264_mluenc ./ mp4
+ */
+
+#include <stdio.h>
+#include <errno.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <libavcodec/avcodec.h>
+#include <libavformat/avformat.h>
+#include <libavutil/avstring.h>
+#include <libavutil/time.h>
+typedef struct{
+    AVFormatContext *ifmt_ctx;
+    AVFormatContext *ofmt_ctx;
+    AVCodecContext *decoder_ctx;
+    AVCodecContext *encoder_ctx;
+    int video_stream;
+    AVStream *ost;
+    int initialized;
+    uint64_t transcoding_frames_count;
+    uint64_t decoder_time_st;
+    uint64_t seconds_elapsed;
+}mlu_transcode_context_t;
+
+#define DOWNSCALE
+// #define PERF_PRINT
+static int open_input_file(const char *filename,AVCodec *decoder,mlu_transcode_context_t *ctx)
+{
+    int ret;
+    AVStream *video = NULL;
+    AVDictionary *decoder_opts = NULL;
+#ifdef DOWNSCALE
+    char resize_str[10];
+#endif
+    if ((ret = avformat_open_input(&ctx->ifmt_ctx, filename, NULL, NULL)) < 0) {
+        fprintf(stderr, "Cannot open input file '%s', Error code: %s\n",
+                filename, av_err2str(ret));
+        return ret;
+    }
+
+    if ((ret = avformat_find_stream_info(ctx->ifmt_ctx, NULL)) < 0) {
+        fprintf(stderr, "Cannot find input stream information. Error code: %s\n",
+                av_err2str(ret));
+        return ret;
+    }
+
+    ret = av_find_best_stream(ctx->ifmt_ctx, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0);
+    if (ret < 0) {
+        fprintf(stderr, "Cannot find a video stream in the input file. "
+                "Error code: %s\n", av_err2str(ret));
+        return ret;
+    }
+    ctx->video_stream = ret;
+
+    if (!(ctx->decoder_ctx = avcodec_alloc_context3(decoder)))
+        return AVERROR(ENOMEM);
+
+    video = ctx->ifmt_ctx->streams[ctx->video_stream];
+    if ((ret = avcodec_parameters_to_context(ctx->decoder_ctx, video->codecpar)) < 0) {
+        fprintf(stderr, "avcodec_parameters_to_context error. Error code: %s\n",
+                av_err2str(ret));
+        return ret;
+    }
+    if (av_stristr(decoder->name,"mludec")) {
+#ifdef DOWNSCALE
+        snprintf(resize_str,10,"%dx%d", ctx->decoder_ctx->width>>2,ctx->decoder_ctx->height>>2);
+        av_dict_set(&decoder_opts, "resize", resize_str, 0);
+#endif
+        ctx->decoder_ctx->flags |= AV_CODEC_FLAG_LOW_DELAY;
+        //av_dict_set_int(&decoder_opts, "trace", 1, 0);
+        av_dict_set_int(&decoder_opts, "device_id", 0, 0);
+    }
+    if ((ret = avcodec_open2(ctx->decoder_ctx, decoder, &decoder_opts)) < 0)
+        fprintf(stderr, "Failed to open codec for decoding. Error code: %s\n",
+                av_err2str(ret));
+
+    if (decoder_opts) {
+        av_dict_free(&decoder_opts);
+        decoder_opts = NULL;
+    }
+    return ret;
+}
+
+static int encode_write(AVFrame *frame,mlu_transcode_context_t *ctx)
+{
+    int ret = 0;
+    AVPacket enc_pkt;
+    av_init_packet(&enc_pkt);
+    enc_pkt.data = NULL;
+    enc_pkt.size = 0;
+    if ((ret = avcodec_send_frame(ctx->encoder_ctx, frame)) < 0) {
+        fprintf(stderr, "Error during encoding. Error code: %s\n", av_err2str(ret));
+        goto end;
+    }
+
+    while (1) {
+        ret = avcodec_receive_packet(ctx->encoder_ctx, &enc_pkt);
+        if (ret)
+            break;
+#ifndef PERF_PRINT
+        enc_pkt.stream_index = 0;
+        av_packet_rescale_ts(&enc_pkt, ctx->ifmt_ctx->streams[ctx->video_stream]->time_base,
+                             ctx->ofmt_ctx->streams[0]->time_base);
+        ret = av_interleaved_write_frame(ctx->ofmt_ctx, &enc_pkt);
+        if (ret < 0) {
+            fprintf(stderr, "Error during writing data to output file. "
+                    "Error code: %s\n", av_err2str(ret));
+            return -1;
+        }
+#else
+        ctx->transcoding_frames_count ++;
+#endif
+    }
+end:
+    if (ret == AVERROR_EOF)
+        return 0;
+    ret = ((ret == AVERROR(EAGAIN)) ? 0:-1);
+    return ret;
+}
+#define DEFAULT_BPS 0x100000
+#define DEFAULT_GOP 50
+#define DEFAULT_QMIN 26
+#define DEFAULT_QMAX 51
+#define DEFAULT_B_NUM 1
+static int dec_enc(AVPacket *pkt, AVCodec *dec_codec,AVCodec *enc_codec,mlu_transcode_context_t *ctx)
+{
+    AVFrame *frame;
+    int ret = 0;
+    AVDictionary *encoder_opts = NULL;
+
+    ret = avcodec_send_packet(ctx->decoder_ctx, pkt);
+    if (ret < 0) {
+        if (ret != AVERROR_EOF)
+            fprintf(stderr, "Error during decoding. Error code: %s\n", av_err2str(ret));
+        return ret;
+    }
+    while (ret >= 0) {
+        if (!(frame = av_frame_alloc()))
+            return AVERROR(ENOMEM);
+
+        ret = avcodec_receive_frame(ctx->decoder_ctx, frame);
+        if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) {
+            av_frame_free(&frame);
+            return 0;
+        } else if (ret < 0) {
+            fprintf(stderr, "Error while decoding. Error code: %s\n", av_err2str(ret));
+            goto fail;
+        }
+
+        if (!ctx->initialized) {
+            /* set AVCodecContext Parameters for encoder, here we keep them stay
+             * the same as decoder.
+             * xxx: now the sample can't handle resolution change case.
+             */
+            ctx->encoder_ctx->time_base = (AVRational){1, 25};
+            /* take first format from list of supported formats */
+            if (enc_codec->pix_fmts)
+                ctx->encoder_ctx->pix_fmt = enc_codec->pix_fmts[0];
+            else
+                ctx->encoder_ctx->pix_fmt = ctx->decoder_ctx->pix_fmt;
+            ctx->encoder_ctx->width     = ctx->decoder_ctx->width;
+            ctx->encoder_ctx->height    = ctx->decoder_ctx->height;
+            ctx->encoder_ctx->bit_rate = DEFAULT_BPS;
+            ctx->encoder_ctx->gop_size = DEFAULT_GOP;
+            ctx->encoder_ctx->sample_aspect_ratio = ctx->decoder_ctx->sample_aspect_ratio;
+            ctx->encoder_ctx->framerate =  (AVRational){25, 1};
+            ctx->encoder_ctx->max_b_frames = DEFAULT_B_NUM;
+            ctx->encoder_ctx->qmin = DEFAULT_QMIN;
+            ctx->encoder_ctx->qmax = DEFAULT_QMAX;
+            if (av_stristr(enc_codec->name,"mluenc")) {
+                //av_dict_set_int(&encoder_opts, "trace", 1, 0);
+                av_dict_set_int(&encoder_opts, "device_id", 0, 0);
+            }
+            if ((ret = avcodec_open2(ctx->encoder_ctx, enc_codec, &encoder_opts)) < 0) {
+                fprintf(stderr, "Failed to open encode codec. Error code: %s\n",
+                        av_err2str(ret));
+                goto fail;
+            }
+            if (encoder_opts) {
+                av_dict_free(&encoder_opts);
+                encoder_opts = NULL;
+            }
+            if (!(ctx->ost = avformat_new_stream(ctx->ofmt_ctx, enc_codec))) {
+                fprintf(stderr, "Failed to allocate stream for output format.\n");
+                ret = AVERROR(ENOMEM);
+                goto fail;
+            }
+
+            ctx->ost->time_base = ctx->encoder_ctx->time_base;
+            ret = avcodec_parameters_from_context(ctx->ost->codecpar, ctx->encoder_ctx);
+            if (ret < 0) {
+                fprintf(stderr, "Failed to copy the stream parameters. "
+                        "Error code: %s\n", av_err2str(ret));
+                goto fail;
+            }
+
+            /* write the stream header */
+            if ((ret = avformat_write_header(ctx->ofmt_ctx, NULL)) < 0) {
+                fprintf(stderr, "Error while writing stream header. "
+                        "Error code: %s\n", av_err2str(ret));
+                goto fail;
+            }
+            ctx->decoder_time_st = av_gettime_relative();
+            ctx->initialized = 1;
+        }
+
+        if ((ret = encode_write(frame,ctx)) < 0)
+            fprintf(stderr, "Error during encoding and writing.\n");
+fail:
+        av_frame_free(&frame);
+        if (ret < 0)
+            return ret;
+    }
+    return 0;
+}
+
+int transcode_cmd(int argc, char **argv);
+#define FILE_NAME_MAX 1024
+int transcode_cmd(int argc, char **argv)
+{
+    int ret = 0;
+    AVPacket dec_pkt;
+    AVCodec *enc_codec;
+    AVCodec *dec_codec;
+    char output_file[FILE_NAME_MAX];
+    pthread_t tid;
+    mlu_transcode_context_t ctx;
+    uint64_t time_st,time_end;
+    memset((void*)&ctx,0,sizeof(mlu_transcode_context_t));
+    ctx.video_stream = -1;
+    ctx.initialized = 0;
+    av_log_set_flags(AV_LOG_SKIP_REPEATED);
+    av_log_set_level(AV_LOG_INFO);
+    tid = pthread_self();
+    memset(output_file,0,FILE_NAME_MAX);
+    snprintf(output_file,FILE_NAME_MAX,"%s/%lu.%s",argv[4],(long unsigned)tid,argv[5]);
+    if (!(dec_codec = avcodec_find_decoder_by_name(argv[1]))) {
+        fprintf(stderr, "Could not find decoder '%s'\n", argv[1]);
+        ret = -1;
+        goto end;
+    }
+
+    if ((ret = open_input_file(argv[2],dec_codec,&ctx) < 0))
+        goto end;
+
+    if (!(enc_codec = avcodec_find_encoder_by_name(argv[3]))) {
+        fprintf(stderr, "Could not find encoder '%s'\n", argv[3]);
+        ret = -1;
+        goto end;
+    }
+
+    if ((ret = (avformat_alloc_output_context2(&(ctx.ofmt_ctx), NULL, NULL, output_file))) < 0) {
+        fprintf(stderr, "Failed to deduce output format from file extension. Error code: "
+                "%s\n", av_err2str(ret));
+        goto end;
+    }
+
+    if (!(ctx.encoder_ctx = avcodec_alloc_context3(enc_codec))) {
+        ret = AVERROR(ENOMEM);
+        goto end;
+    }
+
+    ret = avio_open(&(ctx.ofmt_ctx->pb), output_file, AVIO_FLAG_WRITE);
+    if (ret < 0) {
+        fprintf(stderr, "Cannot open output file. "
+                "Error code: %s\n", av_err2str(ret));
+        goto end;
+    }
+
+    /* read all packets and only transcoding video */
+    while (ret >= 0) {
+        if ((ret = av_read_frame(ctx.ifmt_ctx, &dec_pkt)) < 0)
+            break;
+
+        if (ctx.video_stream == dec_pkt.stream_index){
+            ret = dec_enc(&dec_pkt, dec_codec,enc_codec,&ctx);
+        }
+        av_packet_unref(&dec_pkt);
+    }
+
+    /* flush decoder */
+    {
+        dec_pkt.data = NULL;
+        dec_pkt.size = 0;
+        ret = dec_enc(&dec_pkt, dec_codec,enc_codec,&ctx);
+        av_packet_unref(&dec_pkt);
+    }
+
+    /* flush encoder */
+    ret = encode_write(NULL,&ctx);
+#ifndef PERF_PRINT
+    /* write the trailer for output stream */
+    av_write_trailer(ctx.ofmt_ctx);
+#endif
+
+end:
+    time_st = ctx.decoder_time_st;
+    time_end = av_gettime_relative();
+    ctx.seconds_elapsed = (time_end - time_st) / 1000000;
+#ifdef PERF_PRINT
+    fprintf(stderr, "Total transcoding frames couts: %lu,"
+    "elapsed seconds: %lu,transcoding perf: %.2f \n",
+    ctx.transcoding_frames_count,ctx.seconds_elapsed,(float)ctx.transcoding_frames_count/(float)ctx.seconds_elapsed);
+#endif
+    avformat_close_input(&ctx.ifmt_ctx);
+    avformat_close_input(&ctx.ofmt_ctx);
+    avcodec_free_context(&ctx.decoder_ctx);
+    avcodec_free_context(&ctx.encoder_ctx);
+    return ret;
+}
+
+typedef struct {
+    int argc;
+    char** argv;
+}cmd_set_t;
+
+void* transocde_task(void* args);
+void* transocde_task(void* args)
+{
+    cmd_set_t * cmd = (cmd_set_t*)args;
+    transcode_cmd(cmd->argc,cmd->argv);
+    return NULL;
+}
+#define NUM_THREADS 60
+int main(int argc, char** argv)
+{
+    pthread_t tids[NUM_THREADS];
+    pthread_attr_t attr;
+    cmd_set_t cmd[NUM_THREADS];
+    int ret = 0;
+    int thread_num = NUM_THREADS;
+    if (argc != 7) {
+        fprintf(stderr, "Usage: %s <decode codec> <input file> <encode codec> <output path> <file extension> <task num>\n"
+        "The output format is guessed according to the file extension.\n"
+        "\n", argv[0]);
+        return -1;
+    }
+    thread_num = atoi(argv[6]);
+    if (thread_num < 0 || thread_num > NUM_THREADS) {
+        thread_num = NUM_THREADS;
+    }
+    pthread_attr_init( &attr);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
+    for (int i = 0;i < thread_num; i++) {
+        cmd[i].argc = argc;
+        cmd[i].argv = argv;
+        ret = pthread_create( &tids[i], &attr, transocde_task, (void*)&cmd[i]);
+        if(ret != 0) {
+            fprintf(stderr, "pthread_create error:error_code= %d\n",ret);
+        }
+    }
+    pthread_attr_destroy(&attr);
+    for(int i = 0; i < thread_num; i++){
+        void *status = NULL;
+        ret = pthread_join( tids[i], &status);
+        if (ret != 0){
+            fprintf(stderr, "pthread_join error(thread id :%lu): error_code=%d\n",(long unsigned)tids[i],ret);
+        } else {
+#ifndef PERF_PRINT
+            fprintf(stderr, "pthread_join(thread id :%lu): get status:=%ld\n",(long unsigned)tids[i],(long)status);
+#endif
+        }
+    }
+    return 0;
+}
diff --git a/libavcodec/Makefile b/libavcodec/Makefile
old mode 100644
new mode 100755
index 3cd73fb..f47f3ad
--- a/libavcodec/Makefile
+++ b/libavcodec/Makefile
@@ -347,6 +347,8 @@ OBJS-$(CONFIG_H264_DECODER)            += h264dec.o h264_cabac.o h264_cavlc.o \
                                           h264_mb.o h264_picture.o \
                                           h264_refs.o h264_sei.o \
                                           h264_slice.o h264data.o
+OBJS-$(CONFIG_H264_MLUMPP_DECODER)     += mlumpp_dec.o mlumpp_mluop.o
+OBJS-$(CONFIG_H264_MLUMPP_ENCODER)     += mlumpp_vid_enc.o mlumpp_enc_h264.o
 OBJS-$(CONFIG_H264_AMF_ENCODER)        += amfenc_h264.o
 OBJS-$(CONFIG_H264_CUVID_DECODER)      += cuviddec.o
 OBJS-$(CONFIG_H264_MEDIACODEC_DECODER) += mediacodecdec.o
@@ -368,6 +370,8 @@ OBJS-$(CONFIG_HCOM_DECODER)            += hcom.o
 OBJS-$(CONFIG_HEVC_DECODER)            += hevcdec.o hevc_mvs.o \
                                           hevc_cabac.o hevc_refs.o hevcpred.o    \
                                           hevcdsp.o hevc_filter.o hevc_data.o
+OBJS-$(CONFIG_HEVC_MLUMPP_DECODER)     += mlumpp_dec.o
+OBJS-$(CONFIG_HEVC_MLUMPP_ENCODER)     += mlumpp_vid_enc.o mlumpp_enc_hevc.o
 OBJS-$(CONFIG_HEVC_AMF_ENCODER)        += amfenc_hevc.o
 OBJS-$(CONFIG_HEVC_CUVID_DECODER)      += cuviddec.o
 OBJS-$(CONFIG_HEVC_MEDIACODEC_DECODER) += mediacodecdec.o
@@ -427,6 +431,8 @@ OBJS-$(CONFIG_MIMIC_DECODER)           += mimic.o
 OBJS-$(CONFIG_MJPEG_DECODER)           += mjpegdec.o
 OBJS-$(CONFIG_MJPEG_ENCODER)           += mjpegenc.o mjpegenc_common.o \
                                           mjpegenc_huffman.o
+OBJS-$(CONFIG_MJPEG_MLUMPP_DECODER)    += mlumpp_dec.o
+OBJS-$(CONFIG_MJPEG_MLUMPP_ENCODER)    += mlumpp_enc_jpeg.o
 OBJS-$(CONFIG_MJPEGB_DECODER)          += mjpegbdec.o
 OBJS-$(CONFIG_MJPEG_CUVID_DECODER)     += cuviddec.o
 OBJS-$(CONFIG_MJPEG_QSV_ENCODER)       += qsvenc_jpeg.o
@@ -666,6 +672,7 @@ OBJS-$(CONFIG_VP3_DECODER)             += vp3.o
 OBJS-$(CONFIG_VP5_DECODER)             += vp5.o vp56.o vp56data.o vp56rac.o
 OBJS-$(CONFIG_VP6_DECODER)             += vp6.o vp56.o vp56data.o \
                                           vp6dsp.o vp56rac.o
+OBJS-$(CONFIG_VP8_MLUMPP_DECODER)      += mlumpp_dec.o
 OBJS-$(CONFIG_VP7_DECODER)             += vp8.o vp56rac.o
 OBJS-$(CONFIG_VP8_DECODER)             += vp8.o vp56rac.o
 OBJS-$(CONFIG_VP8_CUVID_DECODER)       += cuviddec.o
@@ -678,6 +685,7 @@ OBJS-$(CONFIG_VP8_V4L2M2M_ENCODER)     += v4l2_m2m_enc.o
 OBJS-$(CONFIG_VP9_DECODER)             += vp9.o vp9data.o vp9dsp.o vp9lpf.o vp9recon.o \
                                           vp9block.o vp9prob.o vp9mvs.o vp56rac.o \
                                           vp9dsp_8bpp.o vp9dsp_10bpp.o vp9dsp_12bpp.o
+OBJS-$(CONFIG_VP9_MLUMPP_DECODER)      += mlumpp_dec.o
 OBJS-$(CONFIG_VP9_CUVID_DECODER)       += cuviddec.o
 OBJS-$(CONFIG_VP9_MEDIACODEC_DECODER)  += mediacodecdec.o
 OBJS-$(CONFIG_VP9_RKMPP_DECODER)       += rkmppdec.o
diff --git a/libavcodec/allcodecs.c b/libavcodec/allcodecs.c
old mode 100644
new mode 100755
index d2f9a39..311ca7a
--- a/libavcodec/allcodecs.c
+++ b/libavcodec/allcodecs.c
@@ -143,11 +143,14 @@ extern AVCodec ff_h264_mediacodec_decoder;
 extern AVCodec ff_h264_mmal_decoder;
 extern AVCodec ff_h264_qsv_decoder;
 extern AVCodec ff_h264_rkmpp_decoder;
+extern AVCodec ff_h264_mlumpp_decoder;
+extern AVCodec ff_h264_mlumpp_encoder;
 extern AVCodec ff_hap_encoder;
 extern AVCodec ff_hap_decoder;
 extern AVCodec ff_hevc_decoder;
 extern AVCodec ff_hevc_qsv_decoder;
 extern AVCodec ff_hevc_rkmpp_decoder;
+extern AVCodec ff_hevc_mlumpp_decoder;
 extern AVCodec ff_hevc_v4l2m2m_decoder;
 extern AVCodec ff_hnm4_video_decoder;
 extern AVCodec ff_hq_hqa_decoder;
@@ -754,6 +757,7 @@ extern AVCodec ff_nvenc_hevc_encoder;
 #endif
 extern AVCodec ff_hevc_amf_encoder;
 extern AVCodec ff_hevc_cuvid_decoder;
+extern AVCodec ff_hevc_mlumpp_encoder;
 extern AVCodec ff_hevc_mediacodec_decoder;
 extern AVCodec ff_hevc_nvenc_encoder;
 extern AVCodec ff_hevc_qsv_encoder;
@@ -762,6 +766,8 @@ extern AVCodec ff_hevc_vaapi_encoder;
 extern AVCodec ff_hevc_videotoolbox_encoder;
 extern AVCodec ff_libkvazaar_encoder;
 extern AVCodec ff_mjpeg_cuvid_decoder;
+extern AVCodec ff_mjpeg_mlumpp_decoder;
+extern AVCodec ff_mjpeg_mlumpp_encoder;
 extern AVCodec ff_mjpeg_qsv_encoder;
 extern AVCodec ff_mjpeg_vaapi_encoder;
 extern AVCodec ff_mpeg1_cuvid_decoder;
@@ -773,11 +779,13 @@ extern AVCodec ff_mpeg4_mediacodec_decoder;
 extern AVCodec ff_mpeg4_v4l2m2m_encoder;
 extern AVCodec ff_vc1_cuvid_decoder;
 extern AVCodec ff_vp8_cuvid_decoder;
+extern AVCodec ff_vp8_mlumpp_decoder;
 extern AVCodec ff_vp8_mediacodec_decoder;
 extern AVCodec ff_vp8_qsv_decoder;
 extern AVCodec ff_vp8_v4l2m2m_encoder;
 extern AVCodec ff_vp8_vaapi_encoder;
 extern AVCodec ff_vp9_cuvid_decoder;
+extern AVCodec ff_vp9_mlumpp_decoder;
 extern AVCodec ff_vp9_mediacodec_decoder;
 extern AVCodec ff_vp9_vaapi_encoder;
 
diff --git a/libavcodec/mlumpp_dec.c b/libavcodec/mlumpp_dec.c
new file mode 100755
index 0000000..ee3ed04
--- /dev/null
+++ b/libavcodec/mlumpp_dec.c
@@ -0,0 +1,1701 @@
+/******************************************************************************
+ * Cambricon MLU Media Process Platform(MLU MPP) SDK
+ * Copyright (C) [2019] by Cambricon, Inc. All rights reserved
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *******************************************************************************/
+#include <stdint.h>
+#include <unistd.h>
+#include <time.h>
+#include <sys/time.h>
+#include <semaphore.h>
+#include "config.h"
+#include <stdatomic.h>
+#include "libavutil/buffer.h"
+#include "libavutil/mathematics.h"
+#include "libavutil/fifo.h"
+#include "libavutil/log.h"
+#include "libavutil/opt.h"
+#include "libavutil/time.h"
+#include "libavutil/pixdesc.h"
+#include "libavutil/thread.h"
+#include "libavutil/version.h"
+#include "avcodec.h"
+#include "decode.h"
+#include "internal.h"
+// Cambricon decoder header file
+#include "cn_video_dec.h"
+#include "cn_jpeg_dec.h"
+#include "cn_codec_common.h"
+// Cambricon runtime header file
+#include "cnrt.h"
+#include "mlumpp_mluop.h"
+// common defines
+#define CNRT_ERROR_CHECK(avctx, ret)                                                       \
+    if (ret != CNRT_RET_SUCCESS) {                                                         \
+        av_log(avctx,AV_LOG_ERROR,"error occur, func: %s, line: %d\n", __func__, __LINE__);\
+        return ret;                                                                         \
+    }
+#define CNCODEC_ERROR_CHECK(avctx, ret)                                                     \
+    if (ret != CNCODEC_SUCCESS) {                                                           \
+        av_log(avctx,AV_LOG_ERROR,"error occur, func: %s, line: %d\n", __func__, __LINE__); \
+        return ret;                                                                          \
+    }
+
+#ifdef CNCODEC_MAJOR_VERSION
+#define CNCODEC_VERSION_INT AV_VERSION_INT(CNCODEC_MAJOR_VERSION, \
+                                           CNCODEC_MINOR_VERSION, \
+                                           CNCODEC_PATCH_VERSION)
+#define CNCODEC_VERSION_1_6 AV_VERSION_INT(1, 6, 0)
+#endif
+#define FF_MLU_MAJPR_VERSION 1
+#define FF_MLU_MINOR_VERSION 2
+#define FF_MLU_PATCH_VERSION 0
+
+static av_cold void mlumpp_empty_frame_queue(AVCodecContext *avctx);
+typedef struct MLUMPPContext
+{
+    AVClass *avclass;
+    int device_id;
+    int instance_id;
+    int num_input_buffers;
+    int num_output_buffers;
+    char *crop_str;
+    char *resize_str;
+    int trace_flag;
+    int cnrt_init_flag;
+    int async_queue_depth;
+    char *output_pixfmt;
+    struct
+    {
+        int left;
+        int top;
+        int right;
+        int bottom;
+    } crop;
+    struct
+    {
+        int width;
+        int height;
+        void *in_y_ptr;
+        void *in_uv_ptr;
+        void *out_y_ptr;
+        void *out_uv_ptr;
+    } resize;
+    int progressive;
+    void *handle;
+    cnvideoDecCreateInfo vdec_params;
+    cnvideoDecSequenceInfo codec_info;
+    AVBSFContext *bsf;
+    AVCodecContext *avctx;
+    sem_t eos_sema;
+    AVFifoBuffer *frame_queue;
+    AVMutex queue_mutex;
+    cncodecType codec_type;
+    volatile int eos_sended;
+    volatile int eos_received;
+    volatile int decoder_flushing;
+    int64_t last_send_pkt_time;
+    int stride_align;
+    int first_packet;
+    volatile int codec_abort_flag;
+    volatile int decoder_start;
+    volatile int decoder_init_flag;
+    HANDLE_MLU_OP mluop_handle;
+    //the below only for debug
+    // AVMutex count_mutex;
+    unsigned long long total_frame_count;
+    unsigned long long total_packet_count;
+    unsigned long long total_outframe_count;
+} MLUMPPContext_t;
+typedef struct MLUVideoFrameInfo {
+    cnvideoDecOutput outframe;
+} MLUVideoFrameInfo_t;
+typedef struct MLUJpegFrameInfo {
+    cnjpegDecOutput outframe;
+} MLUJpegFrameInfo_t;
+/************************************************************************************************************/
+// mlumpp helper function,internal function
+static inline void mlumpp_get_version(void) {
+    av_log(NULL, AV_LOG_INFO, "rel time: 2021/03/15 \n");
+    av_log(NULL, AV_LOG_INFO, "CNCODEC: %d.%d.%d \n",
+            CNCODEC_MAJOR_VERSION, CNCODEC_MINOR_VERSION, CNCODEC_PATCH_VERSION);
+    av_log(NULL, AV_LOG_INFO, "FFMPEG_MLU: %d.%d.%d \n",
+            FF_MLU_MAJPR_VERSION, FF_MLU_MINOR_VERSION, FF_MLU_PATCH_VERSION);
+}
+static inline int mlumpp_adapt_resolution(AVCodecContext* avctx) {
+    if (avctx->codec->id == AV_CODEC_ID_MJPEG) {
+        if (avctx->width < 64 ||  avctx->width > 8192 || avctx->height < 64 || avctx->height > 4320) {
+            av_log(avctx, AV_LOG_ERROR, "Unsupport resoution: %dx%d\n", avctx->width, avctx->height);
+            av_log(avctx, AV_LOG_ERROR, "MLU jpeg decoder only support resolution: 64x64~8192x4320\n");
+            return -1;
+        }
+    } else {
+        if (avctx->width < 64 ||  avctx->width > 4096 || avctx->height < 64 || avctx->height > 4096) {
+            av_log(avctx, AV_LOG_ERROR, "Unsupport resoution: %dx%d\n", avctx->width, avctx->height);
+            av_log(avctx, AV_LOG_ERROR, "MLU video decoder only support resolution: 64x64~4096x4096\n");
+            return -1;
+        }
+    }
+    return 0;
+}
+static void mlumpp_dump_vdec_create_params(AVCodecContext* avctx, cnvideoDecCreateInfo* params)
+{
+    av_log(avctx, AV_LOG_INFO, "************************video decoder create params before*********************\n");
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecCreateInfo params->codec: %d\n", params->codec);
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecCreateInfo params->instance: %u\n", params->instance);
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecCreateInfo params->deviceId: %u\n", params->deviceId);
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecCreateInfo params->pixelFmt: %d\n", params->pixelFmt);
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecCreateInfo params->colorSpace: %d\n", params->colorSpace);
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecCreateInfo params->width: %u\n", params->width);
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecCreateInfo params->height: %u\n", params->height);
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecCreateInfo params->progressive: %u\n", params->progressive);
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecCreateInfo params->bitDepthMinus8: %u\n", params->bitDepthMinus8);
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecCreateInfo params->inputBufNum: %u\n", params->inputBufNum);
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecCreateInfo params->outputBufNum: %u\n", params->outputBufNum);
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecCreateInfo params->suggestedLibAllocBitStrmBufSize: %u\n", params->suggestedLibAllocBitStrmBufSize);
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecCreateInfo params->allocType: %u\n", params->allocType);
+    av_log(avctx, AV_LOG_INFO, "thread id: %lu\n", (long unsigned)pthread_self());
+    av_log(avctx, AV_LOG_INFO, "************************video decoder create params end************************\n");
+}
+static void mlumpp_dump_jdec_create_params(AVCodecContext* avctx, cnjpegDecCreateInfo* params)
+{
+    av_log(avctx, AV_LOG_INFO, "************************decoder create params before*********************\n");
+    av_log(avctx, AV_LOG_INFO, "cnjpegDecCreateInfo params->instance: %u\n", params->instance);
+    av_log(avctx, AV_LOG_INFO, "cnjpegDecCreateInfo params->deviceId: %u\n", params->deviceId);
+    av_log(avctx, AV_LOG_INFO, "cnjpegDecCreateInfo params->pixelFmt: %d\n", params->pixelFmt);
+    av_log(avctx, AV_LOG_INFO, "cnjpegDecCreateInfo params->colorSpace: %d\n", params->colorSpace);
+    av_log(avctx, AV_LOG_INFO, "cnjpegDecCreateInfo params->width: %u\n", params->width);
+    av_log(avctx, AV_LOG_INFO, "cnjpegDecCreateInfo params->height: %u\n", params->height);
+    av_log(avctx, AV_LOG_INFO, "cnjpegDecCreateInfo params->bitDepthMinus8: %u\n", params->bitDepthMinus8);
+    av_log(avctx, AV_LOG_INFO, "cnjpegDecCreateInfo params->inputBufNum: %u\n", params->inputBufNum);
+    av_log(avctx, AV_LOG_INFO, "cnjpegDecCreateInfo params->outputBufNum: %u\n", params->outputBufNum);
+    av_log(avctx, AV_LOG_INFO, "cnjpegDecCreateInfo params->suggestedLibAllocBitStrmBufSize: %u\n", params->suggestedLibAllocBitStrmBufSize);
+    av_log(avctx, AV_LOG_INFO, "cnjpegDecCreateInfo params->allocType: %u\n", params->allocType);
+    av_log(avctx, AV_LOG_INFO, "thread id: %lu\n", (long unsigned)pthread_self());
+    av_log(avctx, AV_LOG_INFO, "************************decoder create params end************************\n");
+}
+static void mlumpp_dump_vdec_frame(AVCodecContext* avctx, cnvideoDecOutput* frameinfo)
+{
+    int i = 0;
+    av_log(avctx, AV_LOG_INFO, "***********************decoder cnvideoDecOutput before*********************\n");
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecOutput frameinfo->frame.pixelFmt: %d\n", frameinfo->frame.pixelFmt);
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecOutput frameinfo->frame.colorSpace: %d\n", frameinfo->frame.colorSpace);
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecOutput frameinfo->frame.width: %d\n", frameinfo->frame.width);
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecOutput frameinfo->frame.height: %d\n", frameinfo->frame.height);
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecOutput frameinfo->frame.planeNum: %d\n", frameinfo->frame.planeNum);
+    for (i = 0; i< frameinfo->frame.planeNum; i++) {
+        av_log(avctx, AV_LOG_INFO, "cnvideoDecOutput frameinfo->frame.plane.addr: %lu\n", frameinfo->frame.plane[i].addr);
+        av_log(avctx, AV_LOG_INFO, "cnvideoDecOutput frameinfo->frame.plane.size: %u\n", frameinfo->frame.plane[i].size);
+        av_log(avctx, AV_LOG_INFO, "cnvideoDecOutput frameinfo->frame.stride: %u\n", frameinfo->frame.stride[i]);
+    }
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecOutput frameinfo->pts: (%3" PRId64 ")\n", frameinfo->pts);
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecOutput frameinfo->flags: %u\n", frameinfo->flags);
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecOutput frameinfo->reserved: %lu\n", frameinfo->reserved);
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecOutput frameinfo->privData: %lu\n", frameinfo->privData);
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecOutput frameinfo->mbErrorCount: %u\n", frameinfo->mbErrorCount);
+    av_log(avctx, AV_LOG_INFO, "thread id: %lu\n", (long unsigned)pthread_self());
+    av_log(avctx, AV_LOG_INFO, "***********************decoder cnvideoDecOutput end************************\n");
+}
+static void mlumpp_dump_jdec_frame(AVCodecContext* avctx, cnjpegDecOutput* frameinfo)
+{
+    int i = 0;
+    av_log(avctx, AV_LOG_INFO, "***********************decoder cnjpegDecOutput before*********************\n");
+    av_log(avctx, AV_LOG_INFO, "cnjpegDecOutput frameinfo->frame.pixelFmt: %d\n", frameinfo->frame.pixelFmt);
+    av_log(avctx, AV_LOG_INFO, "cnjpegDecOutput frameinfo->frame.width: %d\n", frameinfo->frame.width);
+    av_log(avctx, AV_LOG_INFO, "cnjpegDecOutput frameinfo->frame.height: %d\n", frameinfo->frame.height);
+    av_log(avctx, AV_LOG_INFO, "cnjpegDecOutput frameinfo->frame.planeNum: %d\n", frameinfo->frame.planeNum);
+    for (i = 0; i< frameinfo->frame.planeNum; i++) {
+        av_log(avctx, AV_LOG_INFO, "cnjpegDecOutput frameinfo->frame.plane.addr: %lu\n", frameinfo->frame.plane[i].addr);
+        av_log(avctx, AV_LOG_INFO, "cnjpegDecOutput frameinfo->frame.plane.size: %u\n", frameinfo->frame.plane[i].size);
+        av_log(avctx, AV_LOG_INFO, "cnjpegDecOutput frameinfo->frame.stride: %u\n", frameinfo->frame.stride[i]);
+    }
+    av_log(avctx, AV_LOG_INFO, "cnjpegDecOutput frameinfo->pts: (%3" PRId64 ")\n", frameinfo->pts);
+    av_log(avctx, AV_LOG_INFO, "cnjpegDecOutput frameinfo->flags: %u\n", frameinfo->flags);
+    av_log(avctx, AV_LOG_INFO, "cnjpegDecOutput frameinfo->reserved: %lu\n", frameinfo->reserved);
+    av_log(avctx, AV_LOG_INFO, "cnjpegDecOutput frameinfo->privData: %lu\n", frameinfo->privData);
+    av_log(avctx, AV_LOG_INFO, "thread id: %lu\n", (long unsigned)pthread_self());
+    av_log(avctx, AV_LOG_INFO, "***********************decoder cnjpegDecOutput end************************\n");
+}
+static void mlumpp_dump_dec_seq_info(AVCodecContext* avctx, cnvideoDecSequenceInfo* pFormat)
+{
+    av_log(avctx, AV_LOG_INFO, "***********************decoder cnvideoDecSequenceInfo before*********************\n");
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecSequenceInfo pFormat->codec: %d\n", pFormat->codec);
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecSequenceInfo pFormat->width: %u\n", pFormat->width);
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecSequenceInfo pFormat->height: %u\n", pFormat->height);
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecSequenceInfo pFormat->minInputBufNum: %u\n", pFormat->minInputBufNum);
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecSequenceInfo pFormat->minOutputBufNum: %u\n", pFormat->minOutputBufNum);
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecSequenceInfo pFormat->cropArea.left: %u\n", pFormat->cropArea.left);
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecSequenceInfo pFormat->cropArea.top: %u\n", pFormat->cropArea.top);
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecSequenceInfo pFormat->cropArea.right: %u\n", pFormat->cropArea.right);
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecSequenceInfo pFormat->cropArea.bottom: %u\n", pFormat->cropArea.bottom);
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecSequenceInfo pFormat->aspectRatio.x: %u\n", pFormat->aspectRatio.x);
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecSequenceInfo pFormat->aspectRatio.y: %u\n", pFormat->aspectRatio.y);
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecSequenceInfo pFormat->fps.numerator: %u\n", pFormat->fps.numerator);
+    av_log(avctx, AV_LOG_INFO, "cnvideoDecSequenceInfo pFormat->fps.denominator: %u\n", pFormat->fps.denominator);
+    av_log(avctx, AV_LOG_INFO, "thread id: %lu\n", (long unsigned)pthread_self());
+    av_log(avctx, AV_LOG_INFO, "***********************decoder cnvideoDecSequenceInfo end************************\n");
+}
+static inline cncodecPixelFormat mlumpp_dec_map_mlu_pixfmt(enum AVPixelFormat pixfmt)
+{
+    switch (pixfmt) {
+    case AV_PIX_FMT_NV12:
+        return CNCODEC_PIX_FMT_NV12;
+    case AV_PIX_FMT_NV21:
+        return CNCODEC_PIX_FMT_NV21;
+    case AV_PIX_FMT_YUV420P:
+    case AV_PIX_FMT_YUVJ420P:
+        return CNCODEC_PIX_FMT_I420;
+    case AV_PIX_FMT_P010:
+        return CNCODEC_PIX_FMT_P010;
+    default:
+        return CNCODEC_PIX_FMT_NV12;
+    }
+}
+static inline cnvideoDecInstance mlumpp_dec_get_vpu_inst(unsigned int id)
+{
+    switch (id) {
+    case 0:
+        return CNVIDEODEC_INSTANCE_AUTO;
+    case 1:
+        return CNVIDEODEC_INSTANCE_0;
+    case 2:
+        return CNVIDEODEC_INSTANCE_1;
+    case 3:
+        return CNVIDEODEC_INSTANCE_2;
+    case 4:
+        return CNVIDEODEC_INSTANCE_3;
+    case 5:
+        return CNVIDEODEC_INSTANCE_4;
+    case 6:
+        return CNVIDEODEC_INSTANCE_5;
+    default:
+        return CNVIDEODEC_INSTANCE_AUTO;
+    }
+}
+static inline cnjpegDecInstance mlumpp_dec_get_jpu_inst(unsigned int id)
+{
+    switch (id) {
+    case 0:
+        return CNJPEGDEC_INSTANCE_AUTO;
+    case 1:
+        return CNJPEGDEC_INSTANCE_0;
+    case 2:
+        return CNJPEGDEC_INSTANCE_1;
+    case 3:
+        return CNJPEGDEC_INSTANCE_2;
+    case 4:
+        return CNJPEGDEC_INSTANCE_3;
+    case 5:
+        return CNJPEGDEC_INSTANCE_4;
+    case 6:
+        return CNJPEGDEC_INSTANCE_5;
+    default:
+        return CNJPEGDEC_INSTANCE_AUTO;
+    }
+}
+static inline cncodecPixelFormat mlumpp_dec_map_cn_pixfmt(char *pixfmt)
+{
+    if (!strcmp("nv12", pixfmt) || !strcmp("NV12", pixfmt)) {
+        return CNCODEC_PIX_FMT_NV12;
+    } else if (!strcmp("nv21", pixfmt) || !strcmp("NV21", pixfmt)) {
+        return CNCODEC_PIX_FMT_NV21;
+    } else if (!strcmp("i420", pixfmt) || !strcmp("I420", pixfmt)) {
+        return CNCODEC_PIX_FMT_I420;
+    } else if (!strcmp("p010", pixfmt) || !strcmp("P010", pixfmt) ||
+               !strcmp("p010le", pixfmt) || !strcmp("P010LE", pixfmt) ||
+               !strcmp("p010be", pixfmt) || !strcmp("P010BE", pixfmt)) {
+        return CNCODEC_PIX_FMT_P010;
+    } else {
+        av_log(NULL, AV_LOG_ERROR, "unsupport pix fmt: %s, cndecoder only suport nv12/nv21/i420/p010 \n", pixfmt);
+        return -1;
+    }
+}
+static inline  enum AVPixelFormat mlumpp_dec_map_ff_pixfmt(cncodecPixelFormat pixfmt)
+{
+    switch (pixfmt) {
+    case CNCODEC_PIX_FMT_NV12:
+        return AV_PIX_FMT_NV12;
+    case CNCODEC_PIX_FMT_NV21:
+        return AV_PIX_FMT_NV21;
+    case CNCODEC_PIX_FMT_I420:
+        return AV_PIX_FMT_YUV420P;
+    case CNCODEC_PIX_FMT_P010:
+        return AV_PIX_FMT_P010;
+    default:
+        return CNCODEC_PIX_FMT_NV12;
+    }
+}
+static int mlumpp_dec_set_cnrt_ctx(AVCodecContext *avctx, unsigned int device_id, cnrtChannelType_t channel_id)
+{
+    cnrtDev_t dev;
+    cnrtRet_t ret;
+    ret = cnrtGetDeviceHandle(&dev, device_id);
+    CNRT_ERROR_CHECK(avctx, ret);
+    ret = cnrtSetCurrentDevice(dev);
+    CNRT_ERROR_CHECK(avctx, ret);
+    if (channel_id >= CNRT_CHANNEL_TYPE_0) {
+        ret = cnrtSetCurrentChannel(channel_id);
+        CNRT_ERROR_CHECK(avctx, ret);
+    }
+    return 0;
+}
+
+static int mlumpp_is_input_available(AVCodecContext *avctx, int nonblock_flag)
+{
+    MLUMPPContext_t *ctx = (MLUMPPContext_t*)avctx->priv_data;
+    if (ctx->codec_type == CNCODEC_JPEG) {
+        return 1;
+    }
+    if (nonblock_flag) {
+        int ret = 0;
+        if (ctx->handle)
+            ret = cnvideoDecQueryAvailInputBuf(ctx->handle);
+        return ret;
+    } else {
+        int ret = 0;
+        int counts = 500;
+        while (!ctx->codec_abort_flag && --counts) { // timeout = 500ms
+            if (ctx->handle)
+                ret = cnvideoDecQueryAvailInputBuf(ctx->handle);
+            if (ret)
+                return 1;
+            av_usleep(1000);
+        }
+    }
+    return 0;
+}
+
+static int mlumpp_is_frame_queue_empty(AVCodecContext *avctx)
+{
+    MLUMPPContext_t *ctx = (MLUMPPContext_t*)avctx->priv_data;
+    int ret = 1;
+    ff_mutex_lock(&ctx->queue_mutex);
+    if(ctx->frame_queue) {
+        ret = av_fifo_size(ctx->frame_queue) == 0;
+    } else {
+        ret = -1;
+        av_log(avctx, AV_LOG_WARNING, "Frame queue address is invalid \n");
+    }
+    ff_mutex_unlock(&ctx->queue_mutex);
+    return ret;
+}
+
+static int mlumpp_is_frame_queue_invalid(AVCodecContext *avctx)
+{
+    MLUMPPContext_t *ctx = (MLUMPPContext_t*)avctx->priv_data;
+    int ret = 0;
+    ff_mutex_lock(&ctx->queue_mutex);
+    if (ctx->frame_queue) {
+        ret = 0;
+    } else {
+        ret = 1;
+    }
+    ff_mutex_unlock(&ctx->queue_mutex);
+    return ret;
+}
+
+static int mlumpp_create_vid_frame_queue(AVCodecContext *avctx) {
+    MLUMPPContext_t *ctx = (MLUMPPContext_t*)avctx->priv_data;
+    int ret = -1;
+    ff_mutex_lock(&ctx->queue_mutex);
+    if (ctx->frame_queue) {
+        av_log(avctx, AV_LOG_WARNING, "Received sequence info again, need flush vid frame queue firstly \n");
+        // mlumpp_empty_frame_queue(avctx);
+        while (av_fifo_size(ctx->frame_queue) >= sizeof(MLUVideoFrameInfo_t)) {
+            MLUVideoFrameInfo_t video_frame;
+            if (ctx->trace_flag > 1) {
+                av_log(avctx, AV_LOG_INFO, "Thread id: %lu, decoded frames [%lu] are reserved in cache\n", (long unsigned)pthread_self(),
+                    av_fifo_size(ctx->frame_queue) / sizeof(MLUVideoFrameInfo_t));
+            }
+            av_fifo_generic_read(ctx->frame_queue, &video_frame, sizeof(MLUVideoFrameInfo_t), NULL);
+            if (ctx->handle)
+                cnvideoDecReleaseReference(ctx->handle, &(video_frame.outframe.frame));
+        }
+        ctx->frame_queue = NULL;
+    }
+    if (!ctx->frame_queue) {
+        ctx->frame_queue = av_fifo_alloc(ctx->async_queue_depth * sizeof(MLUVideoFrameInfo_t));
+        if (!ctx->frame_queue) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to create vid frame queue \n");
+            return -1;
+        }
+        ret = 1;
+    }
+    ff_mutex_unlock(&ctx->queue_mutex);
+    return ret;
+}
+
+static av_cold void mlumpp_empty_frame_queue(AVCodecContext *avctx) {
+    MLUMPPContext_t *ctx = (MLUMPPContext_t*)avctx->priv_data;
+    ff_mutex_lock(&ctx->queue_mutex);
+    if (ctx->frame_queue) {
+        if (ctx->trace_flag > 0) {
+            av_log(avctx, AV_LOG_INFO, "dec frame queue valid \n");
+        }
+        if (ctx->codec_type == CNCODEC_JPEG) {
+            while (av_fifo_size(ctx->frame_queue) >= sizeof(MLUJpegFrameInfo_t)) {
+                MLUJpegFrameInfo_t jpeg_frame;
+                if (ctx->trace_flag > 0) {
+                    av_log(avctx, AV_LOG_INFO, "thread id: %lu, decoded frames [%lu] are reserved in cache\n", (long unsigned)pthread_self(),
+                        av_fifo_size(ctx->frame_queue) / sizeof(MLUJpegFrameInfo_t));
+                }
+                av_fifo_generic_read(ctx->frame_queue, &jpeg_frame, sizeof(MLUJpegFrameInfo_t), NULL);
+                if (ctx->handle)
+                    cnjpegDecReleaseReference(ctx->handle, &(jpeg_frame.outframe.frame));
+            }
+        } else {
+            if (ctx->trace_flag > 0) {
+                av_log(avctx, AV_LOG_INFO, "dec frame queue size: %d, sizeof(vid data): %d \n", av_fifo_size(ctx->frame_queue), sizeof(MLUVideoFrameInfo_t));
+            }
+            while (av_fifo_size(ctx->frame_queue) >= sizeof(MLUVideoFrameInfo_t)) {
+                MLUVideoFrameInfo_t video_frame;
+                if (ctx->trace_flag > 0) {
+                    av_log(avctx, AV_LOG_INFO, "thread id: %lu, decoded frames [%lu] are reserved in cache\n", (long unsigned)pthread_self(),
+                        av_fifo_size(ctx->frame_queue) / sizeof(MLUVideoFrameInfo_t));
+                }
+                av_fifo_generic_read(ctx->frame_queue, &video_frame, sizeof(MLUVideoFrameInfo_t), NULL);
+                if (ctx->handle)
+                    cnvideoDecReleaseReference(ctx->handle, &(video_frame.outframe.frame));
+            }
+        }
+    }
+    ff_mutex_unlock(&ctx->queue_mutex);
+}
+
+static av_cold void mlumpp_set_frame_queue_invalid(AVCodecContext *avctx) {
+    MLUMPPContext_t *ctx = (MLUMPPContext_t*)avctx->priv_data;
+    ff_mutex_lock(&ctx->queue_mutex);
+    ctx->frame_queue = NULL;
+    ff_mutex_unlock(&ctx->queue_mutex);
+}
+
+static int mlumpp_read_from_frame_queue (AVCodecContext *avctx) {
+    MLUMPPContext_t *ctx = (MLUMPPContext_t*)avctx->priv_data;
+    return 0;
+}
+
+static int mlumpp_write_in_frame_queue (AVCodecContext *avctx) {
+    MLUMPPContext_t *ctx = (MLUMPPContext_t*)avctx->priv_data;
+    return 0;
+}
+
+static int mlumpp_send_video_data(AVCodecContext *avctx,const AVPacket *avpkt, int eos)
+{
+    cnvideoDecInput input;
+    int ret = 0;
+    MLUMPPContext_t *ctx = (MLUMPPContext_t*)avctx->priv_data;
+    const int feed_timeout = 3000;
+    // const int feed_timeout = (1000 / 30) * ctx->num_input_buffers * 50; // 50 is max channel number
+    if (avpkt && avpkt->size) {
+        // on first packet, send extradata
+        if (ctx->first_packet) {
+            if (avctx->extradata_size) {
+                input.streamBuf = avctx->extradata;
+                input.streamLength = avctx->extradata_size;
+                input.pts = avpkt->pts;
+                input.flags = CNVIDEODEC_FLAG_TIMESTAMP;
+#ifdef CNCODEC_VERSION_INT
+                input.flags |= CNVIDEODEC_FLAG_END_OF_FRAME;
+#endif
+                if (ctx->trace_flag > 1) {
+                    av_log(avctx, AV_LOG_INFO, "first packet, write extradata to decoder: %p, length: %u, pts: (%3" PRId64 ")\n",
+                           input.streamBuf, input.streamLength, input.pts);
+                }
+                if (ctx->handle) {
+                    ret = cnvideoDecFeedData(ctx->handle, &input, feed_timeout);
+                }
+                CNCODEC_ERROR_CHECK(avctx, ret);
+            }
+            ctx->first_packet = 0;
+        }
+        // send packet
+        memset(&input, 0, sizeof(cnvideoDecInput));
+        input.streamBuf = avpkt->data;
+        input.streamLength = avpkt->size;
+        input.pts = avpkt->pts;
+        input.flags = CNVIDEODEC_FLAG_TIMESTAMP;
+#ifdef CNCODEC_VERSION_INT
+        input.flags |= CNVIDEODEC_FLAG_END_OF_FRAME;
+#endif
+        if (ctx->trace_flag > 1) {
+            av_log(avctx, AV_LOG_INFO, "[%lu]Feed stream info start\n", (long unsigned)pthread_self());
+            av_log(avctx, AV_LOG_INFO, "[%lu]data: %p, length: %u, pts: (%3" PRId64 ")\n", (long unsigned)pthread_self(),
+                   input.streamBuf, input.streamLength, input.pts);
+        }
+        if (ctx->handle) {
+            ret = cnvideoDecFeedData(ctx->handle, &input, feed_timeout);
+            CNCODEC_ERROR_CHECK(avctx,ret);
+        }
+        if (ctx->trace_flag > 1) {
+            av_log(avctx, AV_LOG_INFO, "[%lu]Feed stream info end\n", (long unsigned)pthread_self());
+        }
+        ctx->total_packet_count++;
+    }
+    if (eos) {
+        ctx->eos_sended = 1;
+        input.streamBuf = NULL;
+        input.streamLength = 0;
+        input.pts = 0;
+        input.flags |= CNVIDEODEC_FLAG_EOS;
+        if (ctx->trace_flag > 0) {
+            av_log(avctx, AV_LOG_INFO, "cndecoder vid feed eos ... \n");
+        }
+        if (ctx->handle) {
+            ret = cnvideoDecFeedData(ctx->handle, &input, feed_timeout);
+        }
+        if (ctx->trace_flag > 0) {
+            av_log(avctx, AV_LOG_INFO, "cndecoder vid feed eos done \n");
+        }
+        CNCODEC_ERROR_CHECK(avctx,ret);
+        if (ctx->trace_flag > 1) {
+            av_log(avctx, AV_LOG_INFO, "[%lu]Feed stream info EOS, flags: %u, pts: (%3" PRId64 ")\n",
+                   (long unsigned)pthread_self(), input.flags, input.pts);
+        }
+    }
+    return ret;
+}
+static int mlumpp_send_jpeg_data(AVCodecContext *avctx,const AVPacket *avpkt, int eos)
+{
+    cnjpegDecInput input;
+    int ret = -1;
+    MLUMPPContext_t *ctx = (MLUMPPContext_t*)avctx->priv_data;
+    const int feed_timeout = 3000;
+    // const int feed_timeout = (1000 / 30) * ctx->num_input_buffers * 50; // 50 is max channel number
+    if (avpkt && avpkt->size) {
+        memset(&input, 0, sizeof(cnjpegDecInput));
+        input.streamBuffer =  avpkt->data;
+        input.streamLength = avpkt->size;
+        input.pts = avpkt->pts;
+        input.flags = CNJPEGDEC_FLAG_TIMESTAMP;
+        if (ctx->trace_flag > 1) {
+            av_log(avctx, AV_LOG_INFO, "Feed stream info: data: %p, length: %u, pts: (%3" PRId64 ")\n",
+                   input.streamBuffer, input.streamLength, input.pts);
+        }
+        if (ctx->handle) {
+            ret = cnjpegDecFeedData(ctx->handle, &input, feed_timeout);
+        }
+        CNCODEC_ERROR_CHECK(avctx, ret);
+        ctx->total_packet_count++;
+    }
+    if (eos) {
+        ctx->eos_sended = 1;
+        input.streamBuffer = NULL;
+        input.streamLength = 0;
+        input.pts = 0;
+        input.flags |= CNJPEGDEC_FLAG_EOS;
+        if (ctx->trace_flag > 0) {
+            av_log(avctx, AV_LOG_INFO, "cndecoder jpeg feed eos ... \n");
+        }
+        if (ctx->handle) {
+            ret = cnjpegDecFeedData(ctx->handle, &input, feed_timeout);
+        }
+        if (ctx->trace_flag > 0) {
+            av_log(avctx, AV_LOG_INFO, "cndecoder jpeg feed done \n");
+        }
+        CNCODEC_ERROR_CHECK(avctx,ret);
+        if (ctx->trace_flag > 1) {
+            av_log(avctx, AV_LOG_INFO, "Feed stream info: EOS, flags: %u, pts: (%3" PRId64 ")\n", input.flags, input.pts);
+        }
+    }
+    return ret;
+}
+/***************************************************************************************************************/
+// cncodec callback
+static av_cold int mlumpp_decode_end(AVCodecContext *avctx);
+static int mlumpp_dec_sequence_cb(void *pData, cnvideoDecSequenceInfo *info)
+{
+    MLUMPPContext_t *ctx = (MLUMPPContext_t *)pData;
+    AVCodecContext *avctx = ctx->avctx;
+    int ret = -1;
+    if (ctx->trace_flag > 0) {
+        av_log(avctx, AV_LOG_WARNING, "cndecoder received sequence cb event \n");
+        av_log(avctx, AV_LOG_INFO, "in sequence cb func, handle: %lu \n", (long unsigned)ctx->handle);
+    }
+    if (ctx->trace_flag > 1) {
+        mlumpp_dump_dec_seq_info(avctx,info);
+    }
+    if (ctx->codec_info.width == info->width && ctx->codec_info.height == info->height) {
+        av_log(avctx, AV_LOG_WARNING, "sequece event happend, but video resolution dont' changed \n");
+        return 0;
+    }
+    // resolution changed
+    ctx->codec_info.width = info->width;
+    ctx->codec_info.height = info->height;
+    ctx->vdec_params.codec = info->codec;
+    if ((ctx->resize.width > 0 && ctx->resize.height > 0) && (ctx->resize.width < info->width ||ctx->resize.height < info->height)) {
+        // only support WxH downscaling for vid dec
+        if ((ctx->resize.width == info->width / 2) && ((ctx->resize.height == info->height / 2)) ||
+            (ctx->resize.width == info->width / 4) && ((ctx->resize.height == info->height / 4))) {
+            ctx->vdec_params.width = ctx->resize.width;
+            ctx->vdec_params.height = ctx->resize.height;
+            // reset this value for next mluop resize flow
+            ctx->resize.width = 0;
+            ctx->resize.height = 0;
+        } else if(ctx->mluop_handle) {
+            mlumpp_mluop_resize_yuv_init(ctx->mluop_handle, info->width, info->height,
+                                        ctx->resize.width, ctx->resize.height, ctx->device_id);
+            ctx->vdec_params.width = info->width;
+            ctx->vdec_params.height = info->height;
+        }
+    } else {
+        ctx->vdec_params.width = info->width;
+        ctx->vdec_params.height = info->height;
+    }
+    avctx->width = ctx->vdec_params.width;
+    avctx->height = ctx->vdec_params.height;
+    avctx->coded_width = FFALIGN(avctx->width, ctx->stride_align);
+    avctx->coded_height = avctx->height;
+    if(0 != mlumpp_adapt_resolution(avctx)) {
+        return AVERROR(EINVAL);
+    }
+
+    // this is for synchronous invocation,need keep enough frames for decoder output buffer
+    // if (info->minOutputBufNum + ctx->vdec_params.inputBufNum > ctx->vdec_params.outputBufNum) {
+    //     ctx->vdec_params.outputBufNum = info->minOutputBufNum + ctx->vdec_params.inputBufNum;
+    // }
+    // ctx->vdec_params.outputBufNum = info->minOutputBufNum + ctx->vdec_params.outputBufNum;
+    ctx->vdec_params.outputBufNum = info->minOutputBufNum + 3;
+    ctx->async_queue_depth = ctx->vdec_params.outputBufNum;
+    if (ctx->trace_flag > 0) {
+        av_log(avctx, AV_LOG_INFO, "Set input buffers: %u, output buffers: %u, queue depth: %u\n",
+                    ctx->vdec_params.inputBufNum, ctx->vdec_params.outputBufNum, ctx->async_queue_depth);
+    }
+
+    // t1
+    // ret = mlumpp_create_vid_frame_queue(avctx);
+    // if (ret == -1) {
+    //     av_log(avctx, AV_LOG_ERROR, "Failed to create vid frame queue, in mlumpp create func \n");
+    //     return ret;
+    // }
+
+    // t2
+    ff_mutex_lock(&ctx->queue_mutex);
+    if (ctx->frame_queue) {
+        if (ctx->trace_flag > 0) {
+            av_log(avctx, AV_LOG_WARNING, "Received sequence info again, need flush vid frame queue firstly \n");
+            av_log(avctx, AV_LOG_INFO, "now frame queue exist, flush ... \n");
+        }
+        while (av_fifo_size(ctx->frame_queue) >= sizeof(MLUVideoFrameInfo_t)) {
+            MLUVideoFrameInfo_t video_frame;
+            if (ctx->trace_flag > 0) {
+                av_log(avctx, AV_LOG_INFO, "Thread id: %lu, decoded frames [%lu] are reserved in cache\n", (long unsigned)pthread_self(),
+                    av_fifo_size(ctx->frame_queue) / sizeof(MLUVideoFrameInfo_t));
+            }
+            av_fifo_generic_read(ctx->frame_queue, &video_frame, sizeof(MLUVideoFrameInfo_t), NULL);
+            if (ctx->handle)
+                cnvideoDecReleaseReference(ctx->handle, &(video_frame.outframe.frame));
+        }
+        ctx->frame_queue = NULL;
+        if (ctx->trace_flag > 0) {
+            av_log(avctx, AV_LOG_INFO, "now frame queue exist, flush done \n");
+        }
+    }
+    if (!ctx->frame_queue) {
+        if (ctx->trace_flag > 0) {
+            av_log(avctx, AV_LOG_INFO, "dec frame queue don't exist, create ... \n");
+        }
+        ctx->async_queue_depth = ctx->vdec_params.outputBufNum;
+        ctx->frame_queue = av_fifo_alloc(ctx->async_queue_depth * sizeof(MLUVideoFrameInfo_t));
+        if (!ctx->frame_queue) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to create frame queue \n");
+            return -1;
+        }
+        if (ctx->trace_flag > 0) {
+            av_log(avctx, AV_LOG_INFO, "dec frame queue don't exist, create done \n");
+        }
+    }
+    ff_mutex_unlock(&ctx->queue_mutex);
+
+    if (ctx->trace_flag > 0) {
+        av_log(avctx, AV_LOG_INFO, "vid decoder start ... \n");
+    }
+    ret = cnvideoDecStart(ctx->handle, &ctx->vdec_params);
+    if (ret != CNCODEC_SUCCESS) {
+        av_log(avctx, AV_LOG_ERROR, "cnvideoDecStart error occur, line: %d\n", __LINE__);
+        return -1;
+    }
+    if (ctx->trace_flag > 0) {
+        av_log(avctx, AV_LOG_INFO, "vid decoder start done \n");
+    }
+
+    ctx->total_frame_count = 0;
+    ctx->decoder_start = 1;
+    if (ctx->trace_flag > 0) {
+        av_log(avctx, AV_LOG_INFO, "out sequence cb func, handle: %lu \n", (long unsigned)ctx->handle);
+    }
+    return 0;
+}
+static int mlumpp_ffcopy_helper(AVCodecContext *avctx, AVFrame *avframe, cncodecFrame *cnframe);
+static int mlumpp_dec_newframe_cb(void *userptr, void *data)
+{
+    MLUMPPContext_t *ctx = (MLUMPPContext_t *)userptr;
+    AVCodecContext *avctx = ctx->avctx;
+    ctx->total_frame_count++;
+    if (ctx->codec_type == CNCODEC_JPEG) {
+        cnjpegDecOutput *jPic = (cnjpegDecOutput*)data;
+        do{
+            MLUJpegFrameInfo_t jpeg_frame;
+            memset(&jpeg_frame, 0, sizeof(MLUJpegFrameInfo_t));
+            jpeg_frame.outframe = *jPic;
+            ff_mutex_lock(&ctx->queue_mutex);
+            av_fifo_generic_write(ctx->frame_queue, &jpeg_frame, sizeof(MLUJpegFrameInfo_t), NULL);
+            if (ctx->handle) {
+                cnjpegDecAddReference(ctx->handle, &jPic->frame);
+            }
+            ff_mutex_unlock(&ctx->queue_mutex);
+        }while(0);
+        if (ctx->trace_flag > 1) {
+            mlumpp_dump_jdec_frame(avctx, jPic);
+        }
+    } else {
+        cnvideoDecOutput *pPic = (cnvideoDecOutput*)data;
+        do{
+            MLUVideoFrameInfo_t video_frame;
+            memset(&video_frame,0,sizeof(MLUVideoFrameInfo_t));
+            video_frame.outframe = *pPic;
+            ff_mutex_lock(&ctx->queue_mutex);
+            av_fifo_generic_write(ctx->frame_queue, &video_frame, sizeof(MLUVideoFrameInfo_t), NULL);
+            if (ctx->handle) {
+                cnvideoDecAddReference(ctx->handle,&pPic->frame);
+            }
+            ff_mutex_unlock(&ctx->queue_mutex);
+        }while(0);
+        if (ctx->trace_flag > 1) {
+            mlumpp_dump_vdec_frame(avctx, pPic);
+        }
+    }
+    return 0;
+}
+static int mlumpp_dec_eos_cb(void *userptr, void *data)
+{
+    MLUMPPContext_t *ctx = (MLUMPPContext_t *)userptr;
+    AVCodecContext *avctx = ctx->avctx;
+    sem_post(&ctx->eos_sema);
+    if (ctx->trace_flag > 0) {
+        av_log(avctx, AV_LOG_INFO, "dec got eos callback pthread id: %lu\n", (long unsigned)pthread_self());
+    }
+    ctx->eos_received = 1;
+    return 0;
+}
+
+static int mlumpp_event_cb(cncodecCbEventType event_type, void *userptr, void *data)
+{
+    MLUMPPContext_t *ctx = (MLUMPPContext_t *)userptr;
+    if (ctx == NULL && data == NULL) {
+        av_log(ctx->avctx, AV_LOG_FATAL, "Decoder callback error,event type: %d \n", event_type);
+        return -1;
+    }
+
+    if (ctx->trace_flag > 1) {
+        av_log(ctx->avctx, AV_LOG_INFO, "[%lu]Decoder callback event type: %d \n", (long unsigned)pthread_self(), event_type);
+    }
+    switch (event_type)
+    {
+        case CNCODEC_CB_EVENT_NEW_FRAME:
+            mlumpp_dec_newframe_cb(userptr, data);
+            break;
+        case CNCODEC_CB_EVENT_SEQUENCE:
+            mlumpp_dec_sequence_cb(userptr, data);
+            break;
+        case CNCODEC_CB_EVENT_EOS:
+            mlumpp_dec_eos_cb(userptr, data);
+            break;
+        case CNCODEC_CB_EVENT_SW_RESET:
+        case CNCODEC_CB_EVENT_HW_RESET:
+            av_log(ctx->avctx, AV_LOG_FATAL, "Decoder FATAL Error <Firmware crash Event>: %d \n", event_type);
+            if (!ctx->codec_abort_flag) {
+                sem_post(&ctx->eos_sema);
+                ctx->codec_abort_flag = 1;
+            }
+            break;
+        case CNCODEC_CB_EVENT_OUT_OF_MEMORY:
+            av_log(ctx->avctx, AV_LOG_FATAL, "Decoder FATAL Error <Out of memory Event>: %d \n", event_type);
+            if (!ctx->codec_abort_flag) {
+                sem_post(&ctx->eos_sema);
+                ctx->codec_abort_flag = 1;
+            }
+            break;
+        case CNCODEC_CB_EVENT_ABORT_ERROR:
+            av_log(ctx->avctx, AV_LOG_FATAL, "Decoder FATAL Error <Abort Event>: %d \n", event_type);
+            if (!ctx->codec_abort_flag) {
+                sem_post(&ctx->eos_sema);
+                ctx->codec_abort_flag = 1;
+            }
+            break;
+#ifdef CNCODEC_VERSION_INT
+        case CNCODEC_CB_EVENT_STREAM_CORRUPT:
+            av_log(ctx->avctx, AV_LOG_WARNING, "Decoder Error <corrupt stream>: %d \n", event_type);
+            if (ctx->trace_flag > 0) {
+                cnvideoDecStreamCorruptInfo *err_info = (cnvideoDecStreamCorruptInfo*)data;
+                av_log(ctx->avctx, AV_LOG_INFO, "Decoder stream error frame count: %lu, frame number: %lu \n", \
+                                    err_info->frameCount, err_info->frameNumber);
+            }
+            break;
+#endif
+        default:
+            av_log(ctx->avctx, AV_LOG_FATAL, "Decoder FATAL Error <Unknow Event>: %d \n", event_type);
+            if (!ctx->codec_abort_flag) {
+                sem_post(&ctx->eos_sema);
+                ctx->codec_abort_flag = 1;
+            }
+            break;
+    }
+    return 0;
+}
+static int mlumpp_decode_packet(AVCodecContext *avctx, const AVPacket *avpkt)
+{
+    MLUMPPContext_t *ctx = (MLUMPPContext_t*)avctx->priv_data;
+    AVPacket filter_packet = { 0 };
+    AVPacket filtered_packet = { 0 };
+    int ret = 0;
+    if (ctx->bsf && avpkt && avpkt->size) {
+        if ((ret = av_packet_ref(&filter_packet, avpkt)) < 0) {
+            av_log(avctx, AV_LOG_ERROR, "av_packet_ref failed\n");
+            return ret;
+        }
+        if ((ret = av_bsf_send_packet(ctx->bsf, &filter_packet)) < 0) {
+            av_log(avctx, AV_LOG_ERROR, "av_bsf_send_packet failed\n");
+            av_packet_unref(&filter_packet);
+            return ret;
+        }
+        if ((ret = av_bsf_receive_packet(ctx->bsf, &filtered_packet)) < 0) {
+            av_log(avctx, AV_LOG_ERROR, "av_bsf_receive_packet failed\n");
+            return ret;
+        }
+        avpkt = &filtered_packet;
+    }
+    av_packet_unref(&filter_packet);
+    mlumpp_dec_set_cnrt_ctx(avctx,ctx->device_id,CNRT_CHANNEL_TYPE_NONE);
+    if (avpkt && avpkt->size) {
+        if (ctx->codec_type == CNCODEC_JPEG) {
+            ret = mlumpp_send_jpeg_data(avctx,avpkt,0);
+        } else {
+            ret = mlumpp_send_video_data(avctx,avpkt,0);
+        }
+        if (ret < 0) {
+            av_packet_unref(&filtered_packet);
+            return AVERROR(EAGAIN);
+        }
+    } else if(!ctx->decoder_flushing) {
+        if (ctx->codec_type == CNCODEC_JPEG) {
+            ret = mlumpp_send_jpeg_data(avctx,NULL,1);
+        } else {
+            ret = mlumpp_send_video_data(avctx,NULL,1);
+        }
+        if (ret < 0) {
+            av_packet_unref(&filtered_packet);
+            return AVERROR(EAGAIN);
+        }
+        ctx->decoder_flushing = 1;
+    }
+    av_packet_unref(&filtered_packet);
+    if (ctx->codec_type != CNCODEC_JPEG && (avctx->flags & AV_CODEC_FLAG_LOW_DELAY)) { // workaround for feeding speed control and low delay mode
+        int64_t current = av_gettime_relative();
+        int guess_fps = 30;
+        if (ctx->last_send_pkt_time > 0 && (current - ctx->last_send_pkt_time)/1000 < 1000/guess_fps) {
+            int diff = 1000/(guess_fps) - (current - ctx->last_send_pkt_time)/1000;
+            while (diff-- > 0) {
+                if (ctx->frame_queue && (av_fifo_size(ctx->frame_queue) > 0)) {
+                    break;
+                }
+                av_usleep(1000);
+            }
+        }
+        ctx->last_send_pkt_time = av_gettime_relative();
+    }
+    return 0;
+}
+static int mlumpp_ffcopy_helper_with_mluop(AVCodecContext *avctx, AVFrame *avframe, cncodecFrame *cnframe)
+{
+    cnrtRet_t cnrt_ret;
+    int ret = -1;
+    MLUMPPContext_t *ctx = (MLUMPPContext_t*)avctx->priv_data;
+    if (ctx->resize.width > 0 || ctx->resize.width >0){
+        if (cnframe->pixelFmt == CNCODEC_PIX_FMT_NV21 ||
+            cnframe->pixelFmt == CNCODEC_PIX_FMT_NV12) {
+            // void *output_mlu_y = NULL;
+            // void *output_mlu_uv = NULL;
+            void *output_mlu_y = ctx->resize.out_y_ptr;
+            void *output_mlu_uv = ctx->resize.out_uv_ptr;
+            int output_mlu_y_size = ctx->resize.width * ctx->resize.height;
+            int output_mlu_uv_size = ctx->resize.width * ctx->resize.height/2;
+            ret = mlumpp_mluop_resize_yuv_exec(
+                ctx->mluop_handle, (void *)cnframe->plane[0].addr,
+                (void *)cnframe->plane[1].addr, output_mlu_y, output_mlu_uv);
+            if (ret < 0) {
+                av_log(avctx, AV_LOG_ERROR, "Failed to resize with mluop\n");
+                return -1;
+            }
+            avframe->linesize[0] = ctx->resize.width;
+            avframe->linesize[1] = ctx->resize.width;
+            cnrt_ret = cnrtMemcpy((void *)avframe->data[0], output_mlu_y,
+                                output_mlu_y_size, CNRT_MEM_TRANS_DIR_DEV2HOST);
+            if (cnrt_ret != CNRT_RET_SUCCESS) {
+                av_frame_unref(avframe);
+                av_log(avctx, AV_LOG_ERROR, "Failed to transfer data from D2H, ret(%ld) \n", cnrt_ret);
+                return AVERROR_EXTERNAL;
+            }
+            cnrt_ret = cnrtMemcpy((void *)avframe->data[1], output_mlu_uv,
+                        output_mlu_uv_size, CNRT_MEM_TRANS_DIR_DEV2HOST);
+            if (cnrt_ret != CNRT_RET_SUCCESS) {
+                av_frame_unref(avframe);
+                av_log(avctx, AV_LOG_ERROR, "Failed to transfer data from D2H, ret(%ld)\n", cnrt_ret);
+                return AVERROR_EXTERNAL;
+            }
+            return 0;
+        }
+    }
+    return -1;
+}
+static int mlumpp_ffcopy_helper(AVCodecContext *avctx, AVFrame *avframe, cncodecFrame *cnframe)
+{
+    int i = 0;
+    cnrtRet_t cnrt_ret;
+    int factor = 0;
+    int ret = -1;
+    MLUMPPContext_t *ctx = (MLUMPPContext_t*)avctx->priv_data;
+    ctx->total_outframe_count++;
+    switch (cnframe->pixelFmt) {
+    case CNCODEC_PIX_FMT_NV21:
+    case CNCODEC_PIX_FMT_NV12:
+        if ((ctx->mluop_handle != NULL) && (ctx->resize.width > 0 || ctx->resize.width > 0)) {
+            ret = mlumpp_ffcopy_helper_with_mluop(avctx, avframe, cnframe);
+            if (ret !=0 ) {
+                return AVERROR_EXTERNAL;
+            }
+            avctx->width = ctx->resize.width;
+            avctx->height = ctx->resize.height;
+            avctx->coded_width = FFALIGN(avctx->width, ctx->stride_align);
+            avctx->coded_height = avctx->height;
+        } else {
+            for (i = 0; i < cnframe->planeNum; ++i) {
+                factor = (i == 0) ? 1 : 2;
+                avframe->linesize[i] = cnframe->stride[i];
+                cnrt_ret = cnrtMemcpy((void *)avframe->data[i],
+                                    (void *)cnframe->plane[i].addr,
+                                    cnframe->stride[i] * cnframe->height / factor,
+                                    CNRT_MEM_TRANS_DIR_DEV2HOST);
+                if (cnrt_ret != CNRT_RET_SUCCESS) {
+                    av_log(avctx, AV_LOG_INFO, "Output frame D2h: dev %p -> host %p, size %d \n",
+                        (void *)cnframe->plane[i].addr, (void *)avframe->data[i], cnframe->stride[i] * cnframe->height / factor);
+                    av_frame_unref(avframe);
+                    av_log(avctx, AV_LOG_ERROR, "Failed to transfer data from D2H, ret(%ld) \n", cnrt_ret);
+                    return AVERROR_EXTERNAL;
+                }
+            }
+        }
+        break;
+    case CNCODEC_PIX_FMT_P010:
+        for (i = 0; i < cnframe->planeNum; ++i) {
+            factor = (i == 0) ? 1 : 2;
+            avframe->linesize[i] = cnframe->stride[i];
+            cnrt_ret = cnrtMemcpy((void*)avframe->data[i],\
+                                (void*)cnframe->plane[i].addr,\
+                                cnframe->stride[i] * cnframe->height/factor, \
+                                CNRT_MEM_TRANS_DIR_DEV2HOST);
+            if (cnrt_ret != CNRT_RET_SUCCESS) {
+                av_log(avctx, AV_LOG_INFO, "Output frame D2h: dev %p -> host %p, size %d \n",
+                    (void *)cnframe->plane[i].addr, (void *)avframe->data[i], cnframe->stride[i] * cnframe->height/factor);
+                av_frame_unref(avframe);
+                av_log(avctx, AV_LOG_ERROR, "Failed to transfer data from D2H, ret(%ld) \n", cnrt_ret);
+                return AVERROR_EXTERNAL;
+            }
+        }
+        break;
+    case CNCODEC_PIX_FMT_I420:
+        for (i = 0; i < cnframe->planeNum; ++i) {
+            factor = (i == 0) ? 1 : 2;
+            avframe->linesize[i] = cnframe->stride[i];
+            cnrt_ret = cnrtMemcpy((void*)avframe->data[i],\
+                                (void*)cnframe->plane[i].addr,\
+                                cnframe->stride[i] * cnframe->height/factor, \
+                                CNRT_MEM_TRANS_DIR_DEV2HOST);
+            if (cnrt_ret != CNRT_RET_SUCCESS) {
+                av_log(avctx, AV_LOG_INFO, "Output frame D2h: dev %p -> host %p, size %d \n",
+                    (void *)cnframe->plane[i].addr, (void *)avframe->data[i], cnframe->stride[i] * cnframe->height/factor);
+                av_frame_unref(avframe);
+                av_log(avctx, AV_LOG_ERROR, "Failed to transfer data from D2H, ret(%ld) \n", cnrt_ret);
+                return AVERROR_EXTERNAL;
+            }
+        }
+        break;
+    default:
+        av_log(avctx, AV_LOG_ERROR, "not support pix fmt: %d, except NV12/NV21/I420/P010 \n", cnframe->pixelFmt);
+        break;
+    }
+    return 0;
+}
+/**************************************************************************************/
+//ffmpeg wrapper interface
+static int mlumpp_output_frame(AVCodecContext *avctx, AVFrame *frame)
+{
+    MLUMPPContext_t *ctx = NULL;
+    int ret = 0;
+    int fifo_empty = 1;
+    if (NULL == avctx || NULL == avctx->priv_data) { //Sanity checks... these are all serious usage bugs.
+        av_log(avctx, AV_LOG_ERROR, "Early error in \"mlumpp_output_frame\" \n");
+        return -1;
+    }
+    ctx = (MLUMPPContext_t*)avctx->priv_data;
+    ff_mutex_lock(&ctx->queue_mutex);
+    if (ctx->frame_queue) {
+        fifo_empty = (av_fifo_size(ctx->frame_queue) == 0);
+    }else{
+        fifo_empty = 1;
+    }
+    // ff_mutex_unlock(&ctx->queue_mutex);
+    if (!fifo_empty) {
+        ret = ff_get_buffer(avctx, frame, 0);
+        if (ret < 0) {
+            av_log(avctx, AV_LOG_ERROR, "ff_get_buffer failed\n");
+            return AVERROR(ENOMEM);
+        }
+        if (ctx->codec_type == CNCODEC_JPEG) {
+            MLUJpegFrameInfo_t out_jframe;
+            cnjpegDecOutput *jpeg_info = NULL;
+            av_fifo_generic_read(ctx->frame_queue, &out_jframe, sizeof(MLUJpegFrameInfo_t), NULL);
+            jpeg_info = &out_jframe.outframe;
+            frame->format = avctx->pix_fmt;
+            frame->width = avctx->width;
+            frame->height = avctx->height;
+            frame->pkt_pos = -1;
+            frame->pkt_duration = 0;
+            frame->pkt_size = -1;
+            frame->interlaced_frame = ctx->progressive ? 0 : 1;
+            frame->pts = jpeg_info->pts;
+            //frame->pkt_dts = AV_NOPTS_VALUE;
+#if FF_API_PKT_PTS
+FF_DISABLE_DEPRECATION_WARNINGS
+            frame->pkt_pts = frame->pts;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+            ret = mlumpp_ffcopy_helper(avctx,frame,&jpeg_info->frame);
+            if (ctx->handle) {
+                cnjpegDecReleaseReference(ctx->handle,&jpeg_info->frame);
+            }
+        } else {
+            MLUVideoFrameInfo_t info;
+            cnvideoDecOutput *video_info;
+            av_fifo_generic_read(ctx->frame_queue, &info, sizeof(MLUVideoFrameInfo_t), NULL);
+            video_info = &info.outframe;
+            frame->format = avctx->pix_fmt;
+            frame->pkt_pos = -1;
+            frame->pkt_duration = 0;
+            frame->pkt_size = -1;
+            frame->interlaced_frame = ctx->progressive ? 0 : 1;
+            frame->pts = video_info->pts;
+            //frame->pkt_dts = AV_NOPTS_VALUE;
+#if FF_API_PKT_PTS
+FF_DISABLE_DEPRECATION_WARNINGS
+            frame->pkt_pts = frame->pts;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+            ret = mlumpp_ffcopy_helper(avctx,frame, &video_info->frame);
+            frame->width = avctx->width;
+            frame->height = avctx->height;
+            if (ctx->handle) {
+                cnvideoDecReleaseReference(ctx->handle, &video_info->frame);
+            }
+        }
+    } else {
+        av_usleep(1000);
+        ret = AVERROR(EAGAIN);
+    }
+    ff_mutex_unlock(&ctx->queue_mutex);
+    return ret;
+}
+
+static int mlumpp_receive_frame(AVCodecContext *avctx, AVFrame *frame)
+{
+    MLUMPPContext_t *ctx = NULL;
+    int ret = 0;
+    if (NULL == avctx || NULL == avctx->priv_data) { //Sanity checks... these are all serious usage bugs.
+        av_log(avctx, AV_LOG_ERROR, "Early error in \"mlumpp_receive_frame\" \n");
+        return -1;
+    }
+    ctx = (MLUMPPContext_t*)avctx->priv_data;
+    if (ctx->codec_abort_flag || !ctx->decoder_init_flag) {
+        av_log(avctx, AV_LOG_ERROR, "Decoder got abort flag or not init, return AVERROR_EXTERNAL \n");
+        return AVERROR_EXTERNAL;
+    }
+    if (ctx->eos_received && mlumpp_is_frame_queue_empty(avctx)) {
+        if (ctx->trace_flag > 0)
+            av_log(avctx, AV_LOG_INFO, "MLU decoder return AVERROR_EOF \n");
+        return AVERROR_EOF;
+    }
+    if (!ctx->decoder_flushing) {
+        if (mlumpp_is_input_available(avctx, 0)) {
+            AVPacket pkt = {0};
+            ret = ff_decode_get_packet(avctx, &pkt);
+            if (ret < 0 && ret != AVERROR_EOF) {
+                return ret;
+            }
+            ret = mlumpp_decode_packet(avctx, &pkt);
+            av_packet_unref(&pkt);
+            // mlumpp_is_input_available() should avoid this.
+            if (ret == AVERROR(EAGAIN))  //
+                ret = AVERROR_EXTERNAL;
+            if (ret < 0 && ret != AVERROR_EOF)
+                return ret;
+        }
+    }
+    if (!ctx->decoder_flushing) {
+        if (ctx->codec_type == CNCODEC_JPEG) {
+            while (!ctx->codec_abort_flag) {
+                ret = mlumpp_output_frame(avctx, frame);
+                if(ret == AVERROR(EAGAIN)) {
+                    av_usleep(1000);
+                    continue;
+                }
+                return ret;
+            }
+            av_log(avctx, AV_LOG_ERROR, "[%lu] Receive frame ABORT->EOF \n", (long unsigned)pthread_self());
+            return AVERROR_EOF;
+        }
+        ret = mlumpp_output_frame(avctx, frame);
+        return ret;
+    } else {
+        int count = 5000;
+        while (!ctx->codec_abort_flag) {
+            ret = mlumpp_output_frame(avctx, frame);
+            if( ret == AVERROR(EAGAIN)) { // output frame need wait
+                if (ctx->eos_received && mlumpp_is_frame_queue_empty(avctx)) {
+                    if (ctx->trace_flag > 0)
+                        av_log(avctx, AV_LOG_INFO, "eos_received AVERROR_EOF \n");
+                    return AVERROR_EOF;
+                }
+                av_usleep(1000);
+                --count;
+                if(count <= 0) {
+                    av_log(avctx, AV_LOG_ERROR, "[%lu] Receive frame TIMEOUT->EOF \n",
+                          (long unsigned)pthread_self());
+                    return AVERROR_EOF;
+                }
+                continue;
+            }
+            return ret;
+        }
+        av_log(avctx, AV_LOG_ERROR, "[%lu] Receive frame ABORT->EOF \n", (long unsigned)pthread_self());
+        return AVERROR_EOF;
+    }
+}
+
+static av_cold int mlumpp_decode_end(AVCodecContext *avctx)
+{
+    MLUMPPContext_t *ctx = NULL;
+    int tmp_flag;
+    int ret = -1;
+    int time_cnt = 0;
+    int timeout = 0;
+    cnrtRet_t cnrt_ret;
+    ctx = (MLUMPPContext_t*)avctx->priv_data;
+    if (NULL == avctx || NULL == avctx->priv_data || NULL == ctx->handle) { // Sanity checks... these are all serious usage bugs.
+        av_log(avctx, AV_LOG_ERROR, "Early error in \"mlumpp_decode_end\" \n");
+        return -1;
+    }
+    if (ctx->trace_flag > 0) {
+        av_log(avctx, AV_LOG_INFO, "cndecoder close ..., handle: %lu \n", (long unsigned)ctx->handle);
+    }
+    // flush cached decoded frames to release output buffers
+    mlumpp_empty_frame_queue(avctx);
+    time_cnt = 1000;
+    timeout = 3000;
+    tmp_flag = 0;
+    // timeout = (1000 / 30) * ctx->num_input_buffers * 50;
+    // wait eos cb: 1s
+    while (!ctx->eos_received && time_cnt >= 0) {
+        if (!ctx->eos_sended) {
+            av_log(avctx, AV_LOG_WARNING, "decoder had not feed EOS data, manual operation \n");
+            ctx->eos_sended = 1;
+            if (ctx->codec_type == CNCODEC_JPEG) {
+                cnjpegDecInput jpeg_in;
+                memset(&jpeg_in, 0, sizeof(cnjpegDecInput));
+                jpeg_in.streamBuffer = NULL;
+                jpeg_in.flags |= CNJPEGDEC_FLAG_EOS;
+                if (ctx->trace_flag > 0) {
+                    av_log(avctx, AV_LOG_INFO, "cndec close func feed eos ... \n");
+                }
+                if (ctx->handle) {
+                    ret = cnjpegDecFeedData(ctx->handle, &jpeg_in, timeout);
+                    if (ret != 0) {
+                        av_log(avctx, AV_LOG_ERROR, "Failed to feed EOS data for jpeg dec in decode end\n");
+                    }
+                }
+                if (ctx->trace_flag > 0) {
+                    av_log(avctx, AV_LOG_INFO, "cndec close func feed eos done \n");
+                }
+                ctx->decoder_flushing = 1;
+            } else {
+                cnvideoDecInput vid_in;
+                memset(&vid_in, 0, sizeof(cnvideoDecInput));
+                vid_in.streamBuf = NULL;
+                vid_in.flags |= CNVIDEODEC_FLAG_EOS;
+                if (ctx->trace_flag > 0) {
+                    av_log(avctx, AV_LOG_INFO, "cndec close func feed eos ... \n");
+                }
+                if (ctx->handle) {
+                    ret = cnvideoDecFeedData(ctx->handle, &vid_in, timeout);
+                    if (ret != 0) {
+                        av_log(avctx, AV_LOG_ERROR, "Failed to feed EOS data for vdec in decode end\n");
+                    }
+                }
+                if (ctx->trace_flag > 0) {
+                    av_log(avctx, AV_LOG_INFO, "cndec close func fed eos done \n");
+                }
+                ctx->decoder_flushing = 1;
+            }
+        } else {
+            if (!tmp_flag) {
+                av_log(avctx, AV_LOG_WARNING, "decoder had feed EOS data, waited eos call back \n");
+                tmp_flag = 1;
+            }
+        }
+        mlumpp_empty_frame_queue(avctx);
+        av_usleep(1000);
+        time_cnt--;
+    }
+    if (!ctx->eos_received && ctx->codec_type != CNCODEC_JPEG) {
+        mlumpp_empty_frame_queue(avctx);
+        if (ctx->trace_flag > 0) {
+            av_log(avctx, AV_LOG_INFO, "vid dec stop, not eos cb ... \n");
+        }
+        if (ctx->handle) {
+            cnvideoDecStop(ctx->handle);
+        }
+        if (ctx->trace_flag > 0) {
+            av_log(avctx, AV_LOG_INFO, "vid dec stop done, not eos cb \n");
+        }
+        goto abort_exit;
+    }
+    if (!ctx->decoder_flushing && ctx->handle != NULL) {
+        if (ctx->codec_type == CNCODEC_JPEG) {
+            if (ctx->handle)
+                cnjpegDecAbort(ctx->handle);
+                ctx->handle = NULL;
+        } else {
+            if (ctx->handle)
+                cnvideoDecAbort(ctx->handle);
+                ctx->handle = NULL;
+        }
+        if (ctx->trace_flag > 0) {
+            av_log(avctx, AV_LOG_INFO, "vid dec abort, due to not dec flushing \n");
+        }
+        goto abort_exit;
+    }
+
+    if (ctx->trace_flag > 0) {
+        av_log(avctx, AV_LOG_INFO, "dec wait eos sema post ... \n");
+    }
+    // sem_wait(&ctx->eos_sema);
+    struct timespec ts;
+    clock_gettime(CLOCK_REALTIME, &ts);
+    ts.tv_sec += 5; // 5s
+    mlumpp_empty_frame_queue(avctx);
+    ret = sem_timedwait(&(ctx->eos_sema), &ts);
+    if (ret == -1) {
+        int semvalue = -1;
+        sem_getvalue(&ctx->eos_sema, &semvalue);
+        av_log(avctx, AV_LOG_ERROR, "dec sem_timewait = -1, semvalue = %d ... \n", semvalue);
+    }
+    if (ctx->trace_flag > 0) {
+        av_log(avctx, AV_LOG_INFO, "dec wait eos sema post done \n");
+    }
+
+    // flush cached decoded frames again
+    mlumpp_empty_frame_queue(avctx);
+    if (ctx->codec_type != CNCODEC_JPEG) {
+        if (ctx->decoder_start) {
+            if (ctx->trace_flag > 0) {
+                av_log(avctx, AV_LOG_INFO, "vid dec stop, had eos cb ... \n");
+            }
+            if (ctx->handle) {
+                cnvideoDecStop(ctx->handle);
+            }
+            if (ctx->trace_flag > 0) {
+                av_log(avctx, AV_LOG_INFO, "vid dec stop done, had eos cb \n");
+            }
+        }
+    }
+
+abort_exit:
+    if (ctx->codec_type != CNCODEC_JPEG) {
+        if (ctx->trace_flag > 0) {
+            av_log(avctx, AV_LOG_INFO, "vid dec destroy ... \n");
+        }
+        if (ctx->handle) {
+            cnvideoDecDestroy(ctx->handle);
+            ctx->handle = NULL;
+        }
+        if (ctx->trace_flag > 0) {
+            av_log(avctx, AV_LOG_INFO, "vid dec destroy done \n");
+        }
+        if (ctx->mluop_handle) {
+            mlumpp_mluop_resize_yuv_destroy(ctx->mluop_handle);
+            mlumpp_mluop_unload(ctx->mluop_handle);
+            ctx->mluop_handle = NULL;
+        }
+        if (ctx->resize.out_y_ptr) {
+            cnrt_ret = cnrtFree(ctx->resize.out_y_ptr);
+            CNRT_ERROR_CHECK(avctx, cnrt_ret);
+        }
+        if (ctx->resize.out_uv_ptr) {
+            cnrt_ret = cnrtFree(ctx->resize.out_uv_ptr);
+            CNRT_ERROR_CHECK(avctx, cnrt_ret);
+        }
+    } else {
+        if (ctx->trace_flag > 0) {
+            av_log(avctx, AV_LOG_INFO, "jpeg dec destroy ... \n");
+        }
+        if (ctx->handle) {
+            cnjpegDecDestroy(ctx->handle);
+            ctx->handle = NULL;
+        }
+        if (ctx->trace_flag > 0) {
+            av_log(avctx, AV_LOG_INFO, "jpeg dec destroy done \n");
+        }
+    }
+    sem_destroy(&ctx->eos_sema);
+    if (ctx->frame_queue) {
+        av_fifo_freep(&ctx->frame_queue);
+        ctx->frame_queue = NULL;
+    }
+    ff_mutex_destroy(&ctx->queue_mutex);
+    // ff_mutex_destroy(&ctx->count_mutex);
+    if (ctx->bsf) {
+        av_bsf_free(&ctx->bsf);
+        ctx->bsf = NULL;
+    }
+    if (ctx->cnrt_init_flag) {
+        cnrtDestroy();
+    }
+    ctx->decoder_init_flag = 0;
+    if (ctx->trace_flag > 1) {
+        av_log(avctx, AV_LOG_INFO, "cndecoder status summary: \n");
+        av_log(avctx, AV_LOG_INFO, "decode thread id, %lu \n", (long unsigned)pthread_self());
+        av_log(avctx, AV_LOG_INFO, "decode flushing flag:%d \n", ctx->decoder_flushing);
+        av_log(avctx, AV_LOG_INFO, "decode D2H total pictures count:%llu\n", ctx->total_outframe_count);
+        av_log(avctx, AV_LOG_INFO, "decode received total pictures count:%llu\n", ctx->total_frame_count);
+        av_log(avctx, AV_LOG_INFO, "decode feed data count:%llu\n", ctx->total_packet_count);
+    }
+    if (ctx->trace_flag > 0) {
+        av_log(avctx, AV_LOG_INFO, "cndecoder close done \n");
+    }
+    return 0;
+}
+static av_cold int mlumpp_decode_init(AVCodecContext *avctx)
+{
+    int ret = 0;
+    cnrtRet_t cnrt_ret;
+    int probed_width = 0;
+    int probed_height = 0;
+    unsigned int dev_num = -1;
+    MLUMPPContext_t *ctx = NULL;
+    const AVBitStreamFilter *bsf = NULL;
+    static const char * const mluop_libname = "/usr/local/neuware/lib64/libeasyOP.so";
+
+    if (NULL == avctx || NULL == avctx->priv_data) { // Sanity checks... these are all serious usage bugs.
+        av_log(avctx, AV_LOG_ERROR, "Early error in \"mlumpp_decode_init\" \n");
+        return -1;
+    }
+    ctx = (MLUMPPContext_t*)avctx->priv_data;
+    if (ctx->trace_flag > 0) {
+        av_log(avctx, AV_LOG_INFO, "cndecoder init ... \n");
+    }
+    /*------ Set device start ------*/
+    if (ctx->decoder_init_flag == 1) { //Sanity checks... these are all serious usage bugs.
+        av_log(avctx, AV_LOG_ERROR, "Early error in <mlumpp_decode_init/ctx->decoder_init_flag> \n");
+        return -1;
+    }
+
+    if (ctx->cnrt_init_flag) {
+        cnrt_ret = cnrtInit(0);
+        CNRT_ERROR_CHECK(avctx, cnrt_ret);
+    }
+    cnrt_ret = cnrtGetDeviceCount(&dev_num);
+    if (cnrt_ret != CNRT_RET_SUCCESS || dev_num == 0) {
+        av_log(avctx,AV_LOG_INFO,"Can't find MLU card,device count return 0 \n");
+        return -1;
+    }
+    mlumpp_dec_set_cnrt_ctx(avctx, ctx->device_id, CNRT_CHANNEL_TYPE_NONE);
+    mlumpp_get_version();
+    if(0 != mlumpp_adapt_resolution(avctx)) {
+        return AVERROR(EINVAL);
+    }
+    /*------ Set device end ------*/
+    sem_init(&(ctx->eos_sema), 0, 0);
+    ff_mutex_init(&ctx->queue_mutex, NULL);
+    // ff_mutex_init(&ctx->count_mutex, NULL);
+    ctx->total_frame_count = 0;
+    ctx->total_packet_count = 0;
+    ctx->total_outframe_count = 0;
+    ctx->decoder_flushing = 0;
+    ctx->eos_sended = 0;
+    ctx->eos_received = 0;
+    ctx->resize.height = 0;
+    ctx->resize.width = 0;
+    ctx->resize.in_y_ptr = NULL;
+    ctx->resize.in_uv_ptr = NULL;
+    ctx->resize.out_y_ptr = NULL;
+    ctx->resize.out_uv_ptr = NULL;
+    ctx->first_packet = 1;
+    ctx->codec_abort_flag = 0;
+    switch (avctx->codec->id) {
+#if CONFIG_H264_MLUMPP_DECODER
+    case AV_CODEC_ID_H264:
+        ctx->codec_type = CNCODEC_H264;
+        break;
+#endif
+#if CONFIG_HEVC_MLUMPP_DECODER
+    case AV_CODEC_ID_HEVC:
+        ctx->codec_type = CNCODEC_HEVC;
+        break;
+#endif
+#if CONFIG_MJPEG_MLUMPP_DECODER
+    case AV_CODEC_ID_MJPEG:
+        ctx->codec_type = CNCODEC_JPEG;
+        break;
+#endif
+#if CONFIG_VP8_MLUMPP_DECODER
+    case AV_CODEC_ID_VP8:
+        ctx->codec_type = CNCODEC_VP8;
+        break;
+#endif
+#if CONFIG_VP9_MLUMPP_DECODER
+    case AV_CODEC_ID_VP9:
+        ctx->codec_type = CNCODEC_VP9;
+        break;
+#endif
+    default:
+        av_log(avctx, AV_LOG_ERROR, "Invalid mlumpp codec %d\n",avctx->codec->id);
+        return AVERROR_BUG;
+    }
+
+    if (ctx->resize_str && sscanf(ctx->resize_str, "%dx%d",
+                                   &ctx->resize.width, &ctx->resize.height) != 2) {
+        av_log(avctx, AV_LOG_ERROR, "Invalid resize string\n");
+        ret = AVERROR(EINVAL);
+        goto error;
+    }
+    if (ctx->crop_str && sscanf(ctx->crop_str, "%dx%dx%dx%d",
+                                &ctx->crop.top, &ctx->crop.bottom,
+                                &ctx->crop.left, &ctx->crop.right) != 4) {
+        av_log(avctx, AV_LOG_ERROR, "Invalid cropping string\n");
+        ret = AVERROR(EINVAL);
+        goto error;
+    }
+
+    ctx->bsf = NULL;
+    if (avctx->codec->id == AV_CODEC_ID_H264 || avctx->codec->id == AV_CODEC_ID_HEVC) {
+        if (avctx->codec->id == AV_CODEC_ID_H264)
+            bsf = av_bsf_get_by_name("h264_mp4toannexb");
+        else
+            bsf = av_bsf_get_by_name("hevc_mp4toannexb");
+        if (!bsf) {
+            ret = AVERROR_BSF_NOT_FOUND;
+            goto error;
+        }
+        if (ret = av_bsf_alloc(bsf, &ctx->bsf)) {
+            goto error;
+        }
+        if (((ret = avcodec_parameters_from_context(ctx->bsf->par_in, avctx)) < 0) || ((ret = av_bsf_init(ctx->bsf)) < 0)) {
+            av_bsf_free(&ctx->bsf);
+            goto error;
+        }
+    }
+    /*At this moment, if the demuxer does not set this value (avctx->field_order == UNKNOWN),
+    *   the input stream will be assumed as progressive one.
+    */
+    switch(avctx->field_order){
+    case AV_FIELD_TT:
+    case AV_FIELD_BB:
+    case AV_FIELD_TB:
+    case AV_FIELD_BT:
+        ctx->progressive = 0;
+        break;
+    case AV_FIELD_PROGRESSIVE: //fall through
+    default:
+        ctx->progressive = 1;
+        break;
+    }
+    ctx->avctx = avctx;
+    ctx->frame_queue = NULL;
+    avctx->pix_fmt = mlumpp_dec_map_ff_pixfmt(mlumpp_dec_map_cn_pixfmt(ctx->output_pixfmt));
+    probed_width = avctx->coded_width ? avctx->coded_width : 1920;
+    probed_height = avctx->coded_height ? avctx->coded_height : 1080;
+    // ctx->newframe_got = 0;
+    if (ctx->codec_type != CNCODEC_JPEG) {
+        memset(&(ctx->vdec_params),0,sizeof(cnvideoDecCreateInfo));
+        ctx->vdec_params.deviceId = ctx->device_id;
+        ctx->vdec_params.instance = mlumpp_dec_get_vpu_inst(ctx->instance_id);
+        ctx->vdec_params.codec = ctx->codec_type;
+        ctx->vdec_params.pixelFmt = mlumpp_dec_map_mlu_pixfmt(avctx->pix_fmt);
+        ctx->vdec_params.width = probed_width;
+        ctx->vdec_params.height = probed_height;
+        ctx->vdec_params.bitDepthMinus8 =  0; // need re-design this value
+        ctx->vdec_params.progressive = ctx->progressive;
+        ctx->vdec_params.inputBufNum = ctx->num_input_buffers;
+        ctx->vdec_params.outputBufNum = ctx->num_output_buffers;
+        ctx->vdec_params.allocType = CNCODEC_BUF_ALLOC_LIB;
+        ctx->vdec_params.suggestedLibAllocBitStrmBufSize = FFALIGN(probed_width * probed_height * 3/4 + probed_width * probed_height/2, 4096);
+        // ctx->vdec_params.suggestedLibAllocBitStrmBufSize = FFALIGN(probed_width * probed_height / 2, 4096);
+        ctx->vdec_params.userContext = (void*) ctx;
+        if (ctx->trace_flag > 1) {
+            mlumpp_dump_vdec_create_params(avctx, &ctx->vdec_params);
+        }
+        ret = cnvideoDecCreate(&ctx->handle, &mlumpp_event_cb, &ctx->vdec_params);
+        if (0 != ret) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to create decoder,error code: %d\n",ret);
+            ctx->handle = NULL;
+            ret = AVERROR(EINVAL);
+            goto error;
+        }
+        avctx->pkt_timebase.num = 1;
+        avctx->pkt_timebase.den = 90000;
+        if (ctx->handle) {
+            ret = cnvideoDecSetAttributes(ctx->handle, CNVIDEO_DEC_ATTR_OUT_BUF_ALIGNMENT, &ctx->stride_align);
+            if (0 != ret) {
+                av_log(avctx, AV_LOG_ERROR, "Failed to set output buffer stride alignment,error code: %d\n",ret);
+                ret = AVERROR(EINVAL);
+                goto error;
+            }
+        }
+        ctx->decoder_start = 0;
+    } else {
+        cnjpegDecCreateInfo jdec_params;
+        jdec_params.deviceId = ctx->device_id;
+        jdec_params.instance = mlumpp_dec_get_jpu_inst(ctx->instance_id);
+        jdec_params.pixelFmt = mlumpp_dec_map_mlu_pixfmt(avctx->pix_fmt);
+        jdec_params.width = probed_width;
+        jdec_params.height = probed_height;
+        jdec_params.bitDepthMinus8 = 0;
+        jdec_params.inputBufNum = ctx->num_input_buffers;
+        jdec_params.outputBufNum = ctx->num_output_buffers;
+        jdec_params.colorSpace = CNCODEC_COLOR_SPACE_BT_709; // maybe need modify...
+        jdec_params.allocType = CNCODEC_BUF_ALLOC_LIB;
+        jdec_params.suggestedLibAllocBitStrmBufSize = probed_width * probed_height * 3/4 + probed_width * probed_height/2;
+        jdec_params.userContext = (void *)ctx;
+        ctx->async_queue_depth = ctx->num_output_buffers;
+        avctx->coded_width = FFALIGN(avctx->width, 64); // hard code for MLU200
+        avctx->coded_height = avctx->height;
+        ctx->frame_queue = av_fifo_alloc(ctx->async_queue_depth * sizeof(MLUJpegFrameInfo_t));
+        if (!ctx->frame_queue) {
+            ret = AVERROR(EINVAL);
+            goto error;
+        }
+        if (ctx->trace_flag > 1) {
+            mlumpp_dump_jdec_create_params(avctx, &jdec_params);
+        }
+        ret = cnjpegDecCreate(&ctx->handle, CNJPEGDEC_RUN_MODE_ASYNC, &mlumpp_event_cb, &jdec_params);
+        if (0 != ret) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to create jpeg decoder,error code: %d \n",ret);
+            ctx->handle = NULL;
+            ret = AVERROR(EINVAL);
+            goto error;
+        }
+    }
+    if (!avctx->pkt_timebase.num || !avctx->pkt_timebase.den) {
+        av_log(avctx, AV_LOG_WARNING, "Invalid pkt_timebase, passing timestamps as-is.\n");
+    }
+    if (ctx->codec_type != CNCODEC_JPEG) {
+        ret = mlumpp_mluop_load(&ctx->mluop_handle, mluop_libname, avctx);
+        if (ret < 0) {
+            mlumpp_mluop_unload(ctx->mluop_handle);
+            ctx->mluop_handle = NULL;
+            av_log(avctx, AV_LOG_WARNING, "load mluop failed \n");
+        }
+        if (ctx->mluop_handle && ctx->resize.width > 0 && ctx->resize.height > 0) {
+            int output_mlu_y_size = ctx->resize.width * ctx->resize.height;
+            int output_mlu_uv_size = ctx->resize.width * ctx->resize.height / 2;
+            cnrt_ret = cnrtMalloc((void **)(&ctx->resize.out_y_ptr), sizeof(char) * output_mlu_y_size);
+            CNRT_ERROR_CHECK(avctx, cnrt_ret);
+            cnrt_ret = cnrtMalloc((void **)(&ctx->resize.out_uv_ptr), sizeof(char) * output_mlu_uv_size);
+            CNRT_ERROR_CHECK(avctx, cnrt_ret);
+        }
+    } else {
+        ctx->mluop_handle = NULL;
+    }
+    ctx->decoder_init_flag = 1;
+    if (ctx->trace_flag > 0) {
+        av_log(avctx, AV_LOG_INFO, "cndecoder init done, handle: %lu, thread id: %lu \n", \
+                      (long unsigned)ctx->handle, (long unsigned)pthread_self());
+    }
+    return 0;
+error:
+    sem_post(&ctx->eos_sema);
+    mlumpp_decode_end(avctx);
+    return ret;
+}
+#define OFFSET(x) offsetof(MLUMPPContext_t, x)
+#define VD AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM
+#define MLU2XX_COMMON_OPTS \
+    { "device_id",     "use to choose the accelerator card",     OFFSET(device_id),       AV_OPT_TYPE_INT, { .i64 = 0 },0, INT_MAX, VD },\
+    { "instance_id",   "use to choose which vpu instance",       OFFSET(instance_id),     AV_OPT_TYPE_INT, { .i64 = 0 },0, INT_MAX, VD },\
+    { "cnrt_init_flag", "init/destory cnrt device in ffmpeg",    OFFSET(cnrt_init_flag),  AV_OPT_TYPE_INT, { .i64 = 1 },0, 1, VD },\
+    { "input_buf_num",  "Number of input buffers for decoder",   OFFSET(num_input_buffers),   AV_OPT_TYPE_INT, { .i64 = 4}, 1, 18, VD },\
+    { "output_buf_num","Number of output buffers for decoder",   OFFSET(num_output_buffers),  AV_OPT_TYPE_INT, { .i64 = 3}, 1, 18, VD },\
+    { "stride_align","stride align of output buffers for decoder",OFFSET(stride_align),   AV_OPT_TYPE_INT, { .i64 = 1 },0, 128, VD },\
+    { "output_pixfmt",        "output pix fmt",                   OFFSET(output_pixfmt),   AV_OPT_TYPE_STRING, { .str = "nv12" },0, 0, VD }, /*NV12, NV21, I420, P010*/
+
+static const AVOption options[] = {
+    MLU2XX_COMMON_OPTS
+    { "crop",     "Crop (top)x(bottom)x(left)x(right)", OFFSET(crop_str), AV_OPT_TYPE_STRING, { .str = NULL }, 0, 0, VD },
+    { "resize",   "Resize (width)x(height)", OFFSET(resize_str), AV_OPT_TYPE_STRING, { .str = NULL }, 0, 0, VD },
+    { "trace", "Whether open trace switch or not",    OFFSET(trace_flag),  AV_OPT_TYPE_INT, { .i64 = 0 },0, 3, VD },
+    { NULL }
+};
+
+#define MLUMPP_DEC_CODEC(x, X) \
+    static const AVClass x##_mlumpp_class = { \
+        .class_name = #x "_mludec", \
+        .item_name = av_default_item_name, \
+        .option = options, \
+        .version = LIBAVUTIL_VERSION_INT, \
+    }; \
+    AVCodec ff_##x##_mlumpp_decoder = { \
+        .name           = #x "_mludec", \
+        .long_name      = NULL_IF_CONFIG_SMALL("Cambricon MLUMPP " #X " decoder"), \
+        .type           = AVMEDIA_TYPE_VIDEO, \
+        .id             = AV_CODEC_ID_##X, \
+        .priv_data_size = sizeof(MLUMPPContext_t), \
+        .priv_class     = &x##_mlumpp_class, \
+        .init           = mlumpp_decode_init, \
+        .close          = mlumpp_decode_end, \
+        .receive_frame  = mlumpp_receive_frame, \
+        .capabilities   = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_AVOID_PROBING /*| AV_CODEC_CAP_HARDWARE*/, \
+        .pix_fmts       = (const enum AVPixelFormat[]){ AV_PIX_FMT_NV12,AV_PIX_FMT_NV21, \
+                                                        AV_PIX_FMT_YUV420P,AV_PIX_FMT_YUVJ420P, \
+                                                        AV_PIX_FMT_P010,AV_PIX_FMT_NONE }, \
+        .hw_configs     = NULL, \
+        .wrapper_name   = "mludec", \
+    };
+
+#if CONFIG_HEVC_MLUMPP_DECODER
+MLUMPP_DEC_CODEC(hevc, HEVC)
+#endif
+#if CONFIG_H264_MLUMPP_DECODER
+MLUMPP_DEC_CODEC(h264, H264)
+#endif
+#if CONFIG_MJPEG_MLUMPP_DECODER
+MLUMPP_DEC_CODEC(mjpeg, MJPEG)
+#endif
+#if CONFIG_VP8_MLUMPP_DECODER
+MLUMPP_DEC_CODEC(vp8, VP8)
+#endif
+#if CONFIG_VP9_MLUMPP_DECODER
+MLUMPP_DEC_CODEC(vp9, VP9)
+#endif
\ No newline at end of file
diff --git a/libavcodec/mlumpp_enc_h264.c b/libavcodec/mlumpp_enc_h264.c
new file mode 100755
index 0000000..3df57be
--- /dev/null
+++ b/libavcodec/mlumpp_enc_h264.c
@@ -0,0 +1,155 @@
+/******************************************************************************
+ * Cambricon MLU Media Process Platform(MLU MPP) SDK
+ * Copyright (C) [2019] by Cambricon, Inc. All rights reserved
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *******************************************************************************/
+#include <unistd.h>
+#include <stdint.h>
+#include "libavutil/common.h"
+#include "libavutil/opt.h"
+#include "libavutil/log.h"
+#include "internal.h"
+#include "mlumpp_vid_enc.h"
+typedef struct _CNVIDH264EncContext {
+    AVClass *class;
+    MLUMPPEncContext_t cnvid;
+} CNVIDH264EncContext;
+static av_cold int mlumpp_enc_init(AVCodecContext *avctx)
+{
+    CNVIDH264EncContext *cnctx =(CNVIDH264EncContext*)avctx->priv_data;
+    return ff_mlumpp_vid_enc_init(avctx, &cnctx->cnvid);
+}
+static int mlumpp_enc_send_frame(AVCodecContext *avctx, const AVFrame *frame)
+{
+    CNVIDH264EncContext *cnctx = (CNVIDH264EncContext*)avctx->priv_data;
+    return ff_mlumpp_vid_enc_send_frame(avctx, &cnctx->cnvid, frame);
+}
+static int mlumpp_enc_receive_packet(AVCodecContext *avctx, AVPacket *pkt)
+{
+    CNVIDH264EncContext *cnctx = (CNVIDH264EncContext*)avctx->priv_data;
+    return ff_mlumpp_vid_enc_receive_packet(avctx, &cnctx->cnvid, pkt);
+}
+static av_cold int mlumpp_enc_close(AVCodecContext *avctx)
+{
+    CNVIDH264EncContext *cnctx = (CNVIDH264EncContext*)avctx->priv_data;
+    return ff_mlumpp_vid_enc_close(avctx, &cnctx->cnvid);
+}
+
+static const AVCodecDefault h264_defaults[] = {
+    { "b",                "0" },
+    { "bf",               "0" },
+    { "g",                "200" },
+    { "qmin",             "-1" },
+    { "qmax",             "-1" },
+    { "refs",             "-1" },
+    { NULL },
+};
+#define OFFSET(x) offsetof(CNVIDH264EncContext, x)
+#ifndef VE
+#define VE AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM
+#endif
+#define MLU2XX_COMMON_OPTS \
+    { "device_id",      "use to choose the accelerator card",     OFFSET(cnvid.device_id),       AV_OPT_TYPE_INT, { .i64 = 0 },0, INT_MAX, VE },\
+    { "instance_id",    "use to choose which vpu instance",       OFFSET(cnvid.instance_id),     AV_OPT_TYPE_INT, { .i64 = 0 },0, INT_MAX, VE },\
+    { "cnrt_init_flag", "init/destory cnrt device in ffmpeg",     OFFSET(cnvid.cnrt_init_flag),  AV_OPT_TYPE_INT, { .i64 = 1 },0, 1, VE },\
+    { "input_buf_num",  "number of input buffers for encoder",    OFFSET(cnvid.input_buf_num),   AV_OPT_TYPE_INT, { .i64 = 4 },1, 18, VE },\
+    { "output_buf_num", "number of output buffers for encoder",   OFFSET(cnvid.output_buf_num),  AV_OPT_TYPE_INT, { .i64 = 5 },1, 18, VE },\
+    { "stride_align",   "stride align of output buffers for encoder",OFFSET(cnvid.stride_align),   AV_OPT_TYPE_INT, { .i64 = 1 },0, 128, VE },\
+
+static const AVOption options[] = {
+    MLU2XX_COMMON_OPTS
+    { "resize",       "resize (width)x(height)",      OFFSET(cnvid.resize_str),  AV_OPT_TYPE_STRING, { .str = NULL }, 0, 0, VE },\
+    { "sar",          "sar (width):(height)",         OFFSET(cnvid.vui_sar_str), AV_OPT_TYPE_STRING, { .str = NULL }, 0, 0, VE },\
+    { "trace",        "trace log switch",             OFFSET(cnvid.trace_flag),  AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 3, VE },
+    { "rc",           "Override the preset rate-control",  OFFSET(cnvid.rcmode), AV_OPT_TYPE_INT, { .i64 = CNVIDEOENC_RATE_CTRL_VBR}, CNVIDEOENC_RATE_CTRL_VBR, CNVIDEOENC_RATE_CTRL_CQP, VE, "rc" },
+    { "cqp", "",   0,       AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_RATE_CTRL_CQP },        0, 0, VE, "rc" },
+    { "cbr", "",   0,       AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_RATE_CTRL_CBR },        0, 0, VE, "rc" },
+    { "vbr", "",   0,       AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_RATE_CTRL_VBR },        0, 0, VE, "rc" },
+    { "vbr_minqp",    "Variable bitrate mode with MinQP ",          OFFSET(cnvid.vbr_minqp),    AV_OPT_TYPE_INT, { .i64 = 0},   0, 51, VE},
+    { "vbr_maxqp",    "Variable bitrate mode with MaxQP ",          OFFSET(cnvid.vbr_maxqp),    AV_OPT_TYPE_INT, { .i64 = 51},  0, 51, VE},
+    { "init_qpP",     "Initial QP value for P frame",               OFFSET(cnvid.init_qp_p),    AV_OPT_TYPE_INT, { .i64 = -1 }, -1, 51, VE },
+    { "init_qpB",     "Initial QP value for B frame",               OFFSET(cnvid.init_qp_b),    AV_OPT_TYPE_INT, { .i64 = -1 }, -1, 51, VE },
+    { "init_qpI",     "Initial QP value for I frame",               OFFSET(cnvid.init_qp_i),    AV_OPT_TYPE_INT, { .i64 = -1 }, -1, 51, VE },
+    { "qp",           "Constant QP rate control method",            OFFSET(cnvid.cqp),          AV_OPT_TYPE_INT, { .i64 = -1 }, -1, 51, VE },
+    { "profile",      "Set the encoding profile",                   OFFSET(cnvid.profile),      AV_OPT_TYPE_INT, { .i64 = CNVIDEOENC_PROFILE_H264_HIGH }, CNVIDEOENC_PROFILE_H264_BASELINE, CNVIDEOENC_PROFILE_H264_HIGH_10, VE, "profile" },
+    { "baseline",  "", 0, AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_PROFILE_H264_BASELINE },  0, 0, VE, "profile" },
+    { "main",      "", 0, AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_PROFILE_H264_MAIN },      0, 0, VE, "profile" },
+    { "high",      "", 0, AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_PROFILE_H264_HIGH },      0, 0, VE, "profile" },
+    { "high444p",  "", 0, AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_PROFILE_H264_HIGH_10 }, 0, 0, VE, "profile" },
+    { "level",  "Set the encoding level restriction",  OFFSET(cnvid.level),  AV_OPT_TYPE_INT,   { .i64 = CNVIDEOENC_LEVEL_H264_42 }, CNVIDEOENC_LEVEL_H264_1, CNVIDEOENC_LEVEL_H264_51, VE, "level" },
+    { "auto",  "",     0,      AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H264_13 },       0, 0, VE, "level" },
+    { "1",     "",     0,      AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H264_1 },        0, 0, VE, "level" },
+    { "1.0",   "",     0,      AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H264_1 },        0, 0, VE, "level" },
+    { "1b",    "",     0,      AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H264_1B },       0, 0, VE, "level" },
+    { "1.0b",  "",     0,      AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H264_1B },       0, 0, VE, "level" },
+    { "1.1",   "",     0,      AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H264_11 },       0, 0, VE, "level" },
+    { "1.2",   "",     0,      AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H264_12 },       0, 0, VE, "level" },
+    { "1.3",   "",     0,      AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H264_13 },       0, 0, VE, "level" },
+    { "2",     "",     0,      AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H264_2 },        0, 0, VE, "level" },
+    { "2.0",   "",     0,      AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H264_2 },        0, 0, VE, "level" },
+    { "2.1",   "",     0,      AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H264_21 },       0, 0, VE, "level" },
+    { "2.2",   "",     0,      AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H264_22 },       0, 0, VE, "level" },
+    { "3",     "",     0,      AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H264_3 },        0, 0, VE, "level" },
+    { "3.0",   "",     0,      AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H264_3 },        0, 0, VE, "level" },
+    { "3.1",   "",     0,      AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H264_31 },       0, 0, VE, "level" },
+    { "3.2",   "",     0,      AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H264_32 },       0, 0, VE, "level" },
+    { "4",     "",     0,      AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H264_4 },        0, 0, VE, "level" },
+    { "4.0",   "",     0,      AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H264_4 },        0, 0, VE, "level" },
+    { "4.1",   "",     0,      AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H264_41 },       0, 0, VE, "level" },
+    { "4.2",   "",     0,      AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H264_42 },       0, 0, VE, "level" },
+    { "5",     "",     0,      AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H264_5 },        0, 0, VE, "level" },
+    { "5.0",   "",     0,      AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H264_5 },        0, 0, VE, "level" },
+    { "5.1",   "",     0,      AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H264_51 },       0, 0, VE, "level" },
+    { "coder",        "Coder type",     OFFSET(cnvid.coder),  AV_OPT_TYPE_INT,   { .i64 = CNVIDEOENC_ENTROPY_MODE_CAVLC  }, 0, 1, VE, "coder" },
+    { "cabac",        "",               0,                    AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_ENTROPY_MODE_CABAC  }, 0, 0, VE, "coder" },
+    { "cavlc",        "",               0,                    AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_ENTROPY_MODE_CAVLC  }, 0, 0, VE, "coder" },
+    { NULL },
+};
+static const AVClass class = {
+    .class_name = "h264_mluenc",
+    .item_name  = av_default_item_name,
+    .option     = options,
+    .version    = LIBAVUTIL_VERSION_INT,
+};
+AVCodec ff_h264_mlumpp_encoder = {
+    .name = "h264_mluenc",
+    .long_name = NULL_IF_CONFIG_SMALL("H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (Cambricon Video acceleration)"),
+    .type = AVMEDIA_TYPE_VIDEO,
+    .id = AV_CODEC_ID_H264,
+    .init = mlumpp_enc_init,
+    .send_frame = mlumpp_enc_send_frame,
+    .receive_packet = mlumpp_enc_receive_packet,
+    /*.encode2        = mlumpp_enc_frame,*/
+    .close = mlumpp_enc_close,
+    .priv_data_size = sizeof(CNVIDH264EncContext),
+    .priv_class = &class,
+    .defaults = h264_defaults,
+    .capabilities = AV_CODEC_CAP_DELAY,
+    .caps_internal = FF_CODEC_CAP_INIT_CLEANUP,
+    .pix_fmts = (const enum AVPixelFormat[]){AV_PIX_FMT_NV12,
+                                             AV_PIX_FMT_NV21,
+                                             AV_PIX_FMT_YUV420P,
+                                             AV_PIX_FMT_P010,
+                                             AV_PIX_FMT_YUYV422,
+                                             AV_PIX_FMT_UYVY422,
+                                             AV_PIX_FMT_ARGB,
+                                             AV_PIX_FMT_BGRA,
+                                             AV_PIX_FMT_RGBA,
+                                             AV_PIX_FMT_NONE},
+    .wrapper_name = "mluenc",
+};
\ No newline at end of file
diff --git a/libavcodec/mlumpp_enc_hevc.c b/libavcodec/mlumpp_enc_hevc.c
new file mode 100755
index 0000000..3ce87b8
--- /dev/null
+++ b/libavcodec/mlumpp_enc_hevc.c
@@ -0,0 +1,152 @@
+/******************************************************************************
+ * Cambricon MLU Media Process Platform(MLU MPP) SDK
+ * Copyright (C) [2019] by Cambricon, Inc. All rights reserved
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *******************************************************************************/
+#include <unistd.h>
+#include <stdint.h>
+#include "libavutil/common.h"
+#include "libavutil/opt.h"
+#include "libavutil/log.h"
+#include "internal.h"
+//for cambricon
+#include "mlumpp_vid_enc.h"
+typedef struct _CNVIDHEVCEncContext {
+    AVClass *class;
+    MLUMPPEncContext_t cnvid;
+} CNVIDHEVCEncContext;
+
+static av_cold int mlumpp_enc_init(AVCodecContext *avctx)
+{
+    CNVIDHEVCEncContext *cnctx =(CNVIDHEVCEncContext*)avctx->priv_data;
+    return ff_mlumpp_vid_enc_init(avctx, &cnctx->cnvid);
+}
+static int mlumpp_enc_send_frame(AVCodecContext *avctx, const AVFrame *frame){
+    CNVIDHEVCEncContext *cnctx = (CNVIDHEVCEncContext*)avctx->priv_data;
+    return ff_mlumpp_vid_enc_send_frame(avctx, &cnctx->cnvid, frame);
+}
+static int mlumpp_enc_receive_packet(AVCodecContext *avctx, AVPacket *pkt){
+    CNVIDHEVCEncContext *cnctx = (CNVIDHEVCEncContext*)avctx->priv_data;
+    return ff_mlumpp_vid_enc_receive_packet(avctx, &cnctx->cnvid, pkt);
+}
+static av_cold int mlumpp_enc_close(AVCodecContext *avctx)
+{
+    CNVIDHEVCEncContext *cnctx = (CNVIDHEVCEncContext*)avctx->priv_data;
+    return ff_mlumpp_vid_enc_close(avctx, &cnctx->cnvid);
+}
+
+static const AVCodecDefault hevc_defaults[] = {
+    { "b",                "0" },
+    { "bf",               "0" },
+    { "g",                "200" },
+    { "qmin",             "-1" },
+    { "qmax",             "-1" },
+    { "refs",             "0" },
+#if FF_API_CODER_TYPE
+    { "coder",            "-1" },
+#endif
+    { NULL },
+};
+#define OFFSET(x) offsetof(CNVIDHEVCEncContext, x)
+#ifndef VE
+#define VE AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM
+#endif
+#define MLU2XX_COMMON_OPTS \
+    { "device_id",      "use to choose the accelerator card",     OFFSET(cnvid.device_id),       AV_OPT_TYPE_INT, { .i64 = 0 },0, INT_MAX, VE },\
+    { "instance_id",    "use to choose which vpu instance",       OFFSET(cnvid.instance_id),     AV_OPT_TYPE_INT, { .i64 = 0 },0, INT_MAX, VE },\
+    { "cnrt_init_flag", "init/destory cnrt device in ffmpeg",     OFFSET(cnvid.cnrt_init_flag),  AV_OPT_TYPE_INT, { .i64 = 1 },0, 1, VE },\
+    { "input_buf_num",  "Number of input buffers for encoder",    OFFSET(cnvid.input_buf_num),   AV_OPT_TYPE_INT, { .i64 = 3 },1, 18, VE },\
+    { "output_buf_num","Number of output buffers for encoder",    OFFSET(cnvid.output_buf_num),  AV_OPT_TYPE_INT, { .i64 = 5 },1, 18, VE },\
+    { "stride_align","stride align of output buffers for encoder",OFFSET(cnvid.stride_align),   AV_OPT_TYPE_INT, { .i64 = 1 },0, 128, VE },\
+
+static const AVOption options[] = {
+    MLU2XX_COMMON_OPTS
+    { "resize",       "resize (width)x(height)",      OFFSET(cnvid.resize_str),  AV_OPT_TYPE_STRING, { .str = NULL }, 0, 0, VE },\
+    { "sar",          "sar (width):(height)",         OFFSET(cnvid.vui_sar_str), AV_OPT_TYPE_STRING, { .str = NULL }, 0, 0, VE },\
+    { "trace",        "trace log switch",             OFFSET(cnvid.trace_flag),  AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 3, VE },
+    { "rc",  "Override the preset rate-control",   OFFSET(cnvid.rcmode), AV_OPT_TYPE_INT,   { .i64 = CNVIDEOENC_RATE_CTRL_VBR}, CNVIDEOENC_RATE_CTRL_VBR, CNVIDEOENC_RATE_CTRL_CQP, VE, "rc" },
+    { "cqp", "",  0,    AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_RATE_CTRL_CQP },        0, 0, VE, "rc" },
+    { "cbr", "",  0,    AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_RATE_CTRL_CBR },        0, 0, VE, "rc" },
+    { "vbr", "",  0,    AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_RATE_CTRL_VBR },        0, 0, VE, "rc" },
+    { "vbr_minqp",    "Variable bitrate mode with MinQP ",          OFFSET(cnvid.vbr_minqp),    AV_OPT_TYPE_CONST, { .i64 = 0},   0, INT_MAX, VE },
+    { "vbr_maxqp",    "Variable bitrate mode with MinQP ",          OFFSET(cnvid.vbr_maxqp),    AV_OPT_TYPE_CONST, { .i64 = 0},   0, INT_MAX, VE },
+    { "init_qpP",     "Initial QP value for P frame",               OFFSET(cnvid.init_qp_p),    AV_OPT_TYPE_INT, { .i64 = -1 }, -1, 51, VE },
+    { "init_qpB",     "Initial QP value for B frame",               OFFSET(cnvid.init_qp_b),    AV_OPT_TYPE_INT, { .i64 = -1 }, -1, 51, VE },
+    { "init_qpI",     "Initial QP value for I frame",               OFFSET(cnvid.init_qp_i),    AV_OPT_TYPE_INT, { .i64 = -1 }, -1, 51, VE },
+    { "qp",           "Constant QP rate control method",            OFFSET(cnvid.cqp),          AV_OPT_TYPE_INT, { .i64 = -1 }, -1, 51, VE },
+    { "profile",      "Set the encoding profile",                   OFFSET(cnvid.profile),      AV_OPT_TYPE_INT,   { .i64 = CNVIDEOENC_PROFILE_H265_MAIN }, CNVIDEOENC_PROFILE_H265_MAIN, CNVIDEOENC_PROFILE_H265_MAIN_10, VE, "profile" },
+    { "main",       "", 0, AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_PROFILE_H265_MAIN },       0, 0, VE, "profile" },
+    { "main_still", "", 0, AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_PROFILE_H265_MAIN_STILL }, 0, 0, VE, "profile" },
+    { "main_intra", "", 0, AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_PROFILE_H265_MAIN_INTRA }, 0, 0, VE, "profile" },
+    { "main10",     "", 0, AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_PROFILE_H265_MAIN_10 },    0, 0, VE, "profile" },
+    { "level","Set the encoding level restriction", OFFSET(cnvid.level),        AV_OPT_TYPE_INT,   { .i64 = CNVIDEOENC_LEVEL_H265_MAIN_1 }, CNVIDEOENC_LEVEL_H265_MAIN_1, CNVIDEOENC_LEVEL_H265_HIGH_62, VE, "level" },
+    { "auto",  "",   0,   AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H265_MAIN_5 },        0, 0, VE, "level" },
+    { "1",     "",   0,   AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H265_MAIN_1 },        0, 0, VE, "level" },
+    { "1.0",   "",   0,   AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H265_HIGH_1 },        0, 0, VE, "level" },
+    { "2",     "",   0,   AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H265_MAIN_2 },        0, 0, VE, "level" },
+    { "2.0",   "",   0,   AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H265_HIGH_2 },        0, 0, VE, "level" },
+    { "2.1",   "",   0,   AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H265_MAIN_21 },       0, 0, VE, "level" },
+    { "3",     "",   0,   AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H265_MAIN_3 },        0, 0, VE, "level" },
+    { "3.0",   "",   0,   AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H265_HIGH_3 },        0, 0, VE, "level" },
+    { "3.1",   "",   0,   AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H265_HIGH_31 },       0, 0, VE, "level" },
+    { "4",     "",   0,   AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H265_MAIN_4 },        0, 0, VE, "level" },
+    { "4.0",   "",   0,   AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H265_HIGH_4 },        0, 0, VE, "level" },
+    { "4.1",   "",   0,   AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H265_HIGH_41 },       0, 0, VE, "level" },
+    { "5",     "",   0,   AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H265_MAIN_5 },        0, 0, VE, "level" },
+    { "5.0",   "",   0,   AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H265_HIGH_5 },        0, 0, VE, "level" },
+    { "5.1",   "",   0,   AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H265_MAIN_51 },       0, 0, VE, "level" },
+    { "5.2",   "",   0,   AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H265_HIGH_52 },       0, 0, VE, "level" },
+    { "6",     "",   0,   AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H265_HIGH_6 },        0, 0, VE, "level" },
+    { "6.0",   "",   0,   AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H265_HIGH_6 },        0, 0, VE, "level" },
+    { "6.1",   "",   0,   AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H265_MAIN_61 },       0, 0, VE, "level" },
+    { "6.2",   "",   0,   AV_OPT_TYPE_CONST, { .i64 = CNVIDEOENC_LEVEL_H265_HIGH_62 },       0, 0, VE, "level" },
+    { NULL },
+};
+static const AVClass class = {
+    .class_name = "hevc_mluenc",
+    .item_name  = av_default_item_name,
+    .option     = options,
+    .version    = LIBAVUTIL_VERSION_INT,
+};
+AVCodec ff_hevc_mlumpp_encoder = {
+    .name = "hevc_mluenc",
+    .long_name = NULL_IF_CONFIG_SMALL("HEVC ENCODER(Cambricon Video acceleration)"),
+    .type = AVMEDIA_TYPE_VIDEO,
+    .id = AV_CODEC_ID_HEVC,
+    .init = mlumpp_enc_init,
+    .send_frame = mlumpp_enc_send_frame,
+    .receive_packet = mlumpp_enc_receive_packet,
+    /*.encode2 = mlumpp_enc_frame,*/
+    .close = mlumpp_enc_close,
+    .priv_data_size = sizeof(CNVIDHEVCEncContext),
+    .priv_class = &class,
+    .defaults = hevc_defaults,
+    .capabilities = AV_CODEC_CAP_DELAY,
+    .caps_internal = FF_CODEC_CAP_INIT_CLEANUP,
+    .pix_fmts = (const enum AVPixelFormat[]){AV_PIX_FMT_NV12,
+                                             AV_PIX_FMT_NV21,
+                                             AV_PIX_FMT_YUV420P,
+                                             AV_PIX_FMT_P010,
+                                             AV_PIX_FMT_YUYV422,
+                                             AV_PIX_FMT_UYVY422,
+                                             AV_PIX_FMT_ARGB,
+                                             AV_PIX_FMT_BGRA,
+                                             AV_PIX_FMT_RGBA,
+                                             AV_PIX_FMT_NONE},
+    .wrapper_name = "mluenc",
+};
\ No newline at end of file
diff --git a/libavcodec/mlumpp_enc_jpeg.c b/libavcodec/mlumpp_enc_jpeg.c
new file mode 100755
index 0000000..59c839e
--- /dev/null
+++ b/libavcodec/mlumpp_enc_jpeg.c
@@ -0,0 +1,844 @@
+/******************************************************************************
+ * Cambricon MLU Media Process Platform(MLU MPP) SDK
+ * Copyright (C) [2019] by Cambricon, Inc. All rights reserved
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *******************************************************************************/
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <stdint.h>
+#include <string.h>
+#include <stdbool.h>
+#include <pthread.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include "libavutil/common.h"
+#include "libavutil/opt.h"
+#include "libavutil/time.h"
+#include "libavutil/log.h"
+#include "internal.h"
+
+#include "cnrt.h"
+#include "mlumpp_mluop.h"
+#include "cn_codec_common.h"
+#include "cn_jpeg_enc.h"
+
+#define CNRT_ERROR_CHECK(avctx, ret)                                                       \
+    if (ret != CNRT_RET_SUCCESS) {                                                         \
+        av_log(avctx,AV_LOG_ERROR,"error occur, func: %s, line: %d\n", __func__, __LINE__);\
+        return -1;                                                                         \
+    }
+#define CNCODEC_ERROR_CHECK(avctx, ret)                                                     \
+    if (ret != CNCODEC_SUCCESS) {                                                           \
+        av_log(avctx,AV_LOG_ERROR,"error occur, func: %s, line: %d\n", __func__, __LINE__); \
+        return -1;                                                                          \
+    }
+#define OUTPUT_BUFFER_SIZE_FOR_ENCODE (1024 * 4096) // must be 4k align
+#define ALIGN128(x)    ((x + 128 -1 ) & (~(128 - 1)))
+#define ALIGN256(x)    ((x + 256 -1 ) & (~(256 - 1)))
+#define ALIGN64(x)     ((x + 64 - 1)  & (~(64 - 1)))
+
+typedef struct CNJpegEncContext{
+    AVClass                             *class;
+    AVCodecContext                      *avctx;
+    int                                 width;
+    int                                 height;
+    int                                 frame_size;
+    int                                 jpeg_quality;
+    int                                 device_id;
+    int                                 instance_id;
+    int                                 input_buf_num;
+    int                                 output_buf_num;
+    int                                 trace_flag;
+    int                                 codec_abort_flag;
+    volatile int                        encoder_init_flag;
+
+    cnjpegEncInput                      input_buf;
+    cnjpegEncOutput                     output_buf;
+    cnjpegEncParameters                 enFrameParam;
+
+    cnjpegEncoder                       handle;
+    cncodecPixelFormat                  pixelFmt;
+    cncodecColorSpace                   color_space;
+    cncodecBufAllocType                 allocType;
+    cnjpegEncCreateInfo                 *enc_create_params;
+
+    // the below only for debug
+    unsigned long long                  total_frame_count;
+    unsigned long long                  total_packet_count;
+    unsigned long long                  total_outframe_count;
+}CNJpegEncContext_t;
+
+static void _dump_jpeg_enc_params(AVCodecContext *avctx, cnjpegEncCreateInfo *encode_params)
+{
+    av_log(avctx, AV_LOG_INFO, "---------------------Encoder attributes dump before----------------------\n");
+    av_log(avctx, AV_LOG_INFO, "encode_params->instance:%u\n", encode_params->instance);
+    av_log(avctx, AV_LOG_INFO, "encode_params->deviceId:%u\n", encode_params->deviceId);
+    av_log(avctx, AV_LOG_INFO, "encode_params->width:%u\n", encode_params->width);
+    av_log(avctx, AV_LOG_INFO, "encode_params->height:%u\n", encode_params->height);
+    av_log(avctx, AV_LOG_INFO, "encode_params->pixelFmt:%u\n", encode_params->pixelFmt);
+    av_log(avctx, AV_LOG_INFO, "encode_params->inputbuffernum:%u\n", encode_params->inputBufNum);
+    av_log(avctx, AV_LOG_INFO, "encode_params->outputbuffernum:%u\n", encode_params->outputBufNum);
+    av_log(avctx, AV_LOG_INFO, "encode_params->allocType:(%s)\n", encode_params->allocType == CNCODEC_BUF_ALLOC_APP ? "app" : "lib");
+    av_log(avctx, AV_LOG_INFO, "encode_params->suggestedLibAllocBitStrmBufSize:%u K\n", encode_params->suggestedLibAllocBitStrmBufSize / 1024);
+    av_log(avctx, AV_LOG_INFO, "thread id: %lu\n", (long unsigned)pthread_self());
+    av_log(avctx, AV_LOG_INFO, "---------------------Encoder attributes dump after---------------------\n");
+}
+static void _dump_output_pkt(CNJpegEncContext_t *cnctx, cnjpegEncOutput *outpkt)
+{
+    av_log(cnctx->avctx, AV_LOG_INFO, "-------------Encoder output packet dump before-------------\n");
+    av_log(cnctx->avctx, AV_LOG_INFO, "cnjpegEncOutput->streamLength:%u\n", outpkt->streamLength);
+    av_log(cnctx->avctx, AV_LOG_INFO, "cnjpegEncOutput->dataOffset:%u\n", outpkt->dataOffset);
+    av_log(cnctx->avctx, AV_LOG_INFO, "cnjpegEncOutput->pts:(%" PRId64 ")\n", outpkt->pts);
+    av_log(cnctx->avctx, AV_LOG_INFO, "cnjpegEncOutput->flags:%u\n", outpkt->flags);
+    av_log(cnctx->avctx, AV_LOG_INFO, "cnjpegEncOutput->streamBuffer.addr:%lu\n", outpkt->streamBuffer.addr);
+    av_log(cnctx->avctx, AV_LOG_INFO, "cnjpegEncOutput->streamBuffer.size:%u\n", outpkt->streamBuffer.size);
+    av_log(cnctx->avctx, AV_LOG_INFO, "-------------Encoder output packet dump end----------------\n");
+}
+static void _dump_feeding_frame(CNJpegEncContext_t *cnctx, cnjpegEncInput *enc_params)
+{
+    av_log(cnctx->avctx, AV_LOG_INFO, "--------------Encoder feed params dump before--------------\n");
+    av_log(cnctx->avctx, AV_LOG_INFO, "enc_params->flags: %u\n", enc_params->flags);
+    av_log(cnctx->avctx, AV_LOG_INFO, "enc_params->pts: (%" PRId64 ")\n", enc_params->pts);
+    av_log(cnctx->avctx, AV_LOG_INFO, "feeding frame counts: %llu \n", cnctx->total_frame_count);
+    av_log(cnctx->avctx, AV_LOG_INFO, "thread id: %lu\n", (long unsigned)pthread_self());
+    av_log(cnctx->avctx, AV_LOG_INFO, "--------------Encoder feed params dump after---------------\n");
+    return;
+}
+static int _jpeg_enc_abort_handler(CNJpegEncContext_t *cnctx)
+{
+    if (cnctx->trace_flag) {
+        av_log(cnctx->avctx, AV_LOG_INFO, "------------_jpeg_enc_abort_handler start-----------\n");
+    }
+    int ret;
+    ret = cnjpegEncAbort(cnctx->handle);
+    if (CNCODEC_SUCCESS != ret) {
+        av_log(cnctx->avctx, AV_LOG_ERROR, "Call cnjpegDecAbort failed, ret(%d)\n", ret);
+        return -1;
+    }
+    cnctx->codec_abort_flag = 1;
+    if (cnctx->trace_flag) {
+        av_log(cnctx->avctx, AV_LOG_INFO, "------------_jpeg_enc_abort_handler end-----------\n");
+    }
+    return 0;
+}
+
+static inline int mlumpp_adapt_resolution(AVCodecContext* avctx) {
+    if (avctx->width < 64 ||  avctx->width > 8192 || avctx->height < 64 || avctx->height > 4320) {
+        av_log(avctx, AV_LOG_ERROR, "Unsupport resoution: %dx%d\n", avctx->width, avctx->height);
+        av_log(avctx, AV_LOG_ERROR, "MLU jpeg encoder only support resolution: 64x64~8192x4320\n");
+        return -1;
+    }
+    return 0;
+}
+
+static inline unsigned int get_plane_height(CNJpegEncContext_t *cnctx, unsigned int height, int plane)
+{
+    if (cnctx->pixelFmt == CNCODEC_PIX_FMT_NV12 ||
+        cnctx->pixelFmt == CNCODEC_PIX_FMT_NV21 ||
+        cnctx->pixelFmt == CNCODEC_PIX_FMT_I420 )
+         {
+       return plane == 0 ? height : height / 2;
+    }
+    return height;
+}
+static inline unsigned int get_plane_width(CNJpegEncContext_t *cnctx, unsigned int width, int plane)
+{
+    unsigned int planWidth = 0;
+    switch (cnctx->pixelFmt) {
+    case CNCODEC_PIX_FMT_NV12:
+    case CNCODEC_PIX_FMT_NV21:
+        planWidth = width;
+        break;
+    case CNCODEC_PIX_FMT_YUYV:
+    case CNCODEC_PIX_FMT_UYVY:
+        planWidth = width * 2;
+        break;
+    default:
+        av_log(cnctx->avctx, AV_LOG_ERROR, "Unknown fmt(%d)\n", cnctx->pixelFmt);
+        break;
+    }
+    return planWidth;
+}
+static inline cnjpegEncInstance mlump_jpeg_enc_get_vpu_inst(unsigned int id)
+{
+    switch (id) {
+    case 0:
+        return CNJPEGENC_INSTANCE_AUTO;
+    case 1:
+        return CNJPEGENC_INSTANCE_0;
+    case 2:
+        return CNJPEGENC_INSTANCE_1;
+    case 3:
+        return CNJPEGENC_INSTANCE_2;
+    case 4:
+        return CNJPEGENC_INSTANCE_3;
+    case 5:
+        return CNJPEGENC_INSTANCE_4;
+    case 6:
+        return CNJPEGENC_INSTANCE_5;
+    case 7:
+        return CNJPEGENC_INSTANCE_INVALID;
+    default:
+        return CNJPEGENC_INSTANCE_AUTO;
+    }
+}
+static int mlumpp_enc_get_cnrt_ctx(AVCodecContext *avctx, CNJpegEncContext_t *cnctx, cnrtChannelType_t channel_id)
+{
+    if (cnctx->trace_flag) {
+        av_log(avctx, AV_LOG_INFO, "------------mlumpp_enc_get_cnrt_ctx start-----------\n");
+    }
+    cnrtDev_t dev;
+    cnrtRet_t ret;
+    unsigned int dev_num;
+    ret = cnrtInit(0);
+    CNRT_ERROR_CHECK(avctx, ret);
+    cnrtGetDeviceCount(&dev_num);
+    if (dev_num == 0) {
+        av_log(avctx, AV_LOG_ERROR, "Can't find MLU card in jpeg encode, device count return 0 \n");
+        return -1;
+    }
+
+    ret = cnrtGetDeviceHandle(&dev, cnctx->device_id);
+    CNRT_ERROR_CHECK(avctx, ret);
+    ret = cnrtSetCurrentDevice(dev);
+    CNRT_ERROR_CHECK(avctx,ret);
+    if (channel_id >= CNRT_CHANNEL_TYPE_0) {
+        ret = cnrtSetCurrentChannel(channel_id);
+        CNRT_ERROR_CHECK(avctx, ret);
+    }
+    if (cnctx->trace_flag) {
+        av_log(avctx, AV_LOG_INFO, "------------mlumpp_enc_get_cnrt_ctx end-----------\n");
+    }
+    return 0;
+}
+
+static int jpeg_enc_input_frame(CNJpegEncContext_t *cnctx, cncodecFrame *tempInput, const AVFrame *frame)
+{
+    if (cnctx->trace_flag) {
+        av_log(cnctx->avctx, AV_LOG_INFO, "------------jpeg_enc_input_frame start-----------\n");
+    }
+    int ret = -1;
+    cnrtRet_t cnrt_ret;
+    unsigned int fake_height = 0;
+    unsigned int fake_width = 0;
+    switch (cnctx->pixelFmt) {
+    case CNCODEC_PIX_FMT_YUYV:
+    case CNCODEC_PIX_FMT_UYVY:
+        fake_height = cnctx->height;
+        fake_width = 2 * cnctx->width;
+        if (fake_width == tempInput->stride[0]) {
+            if (NULL == (void *)tempInput->plane[0].addr) {
+                av_log(cnctx->avctx, AV_LOG_ERROR, "Jpeg encoder input buffer address(MLU) is NULL \n");
+                return -1;
+            }
+            if (NULL == frame->data[0]) {
+                av_log(cnctx->avctx, AV_LOG_ERROR, "Jpeg encoder input data address(CPU) is NULL \n");
+                return -1;
+            }
+            cnrt_ret = cnrtMemcpy((void *)tempInput->plane[0].addr, (void *)frame->data[0],
+                                   tempInput->plane[0].size, CNRT_MEM_TRANS_DIR_HOST2DEV);
+            if (cnctx->trace_flag) {
+                av_log(cnctx->avctx, AV_LOG_INFO, "Yuv h2d plane: host %p -> devi %p, size %d \n",
+                       frame->data[0], tempInput->plane[0].addr, tempInput->plane[0].size);
+            }
+            CNRT_ERROR_CHECK(cnctx->avctx, cnrt_ret);
+        } else {
+            for (int i = 0; i < fake_height; i++) {
+                void *host_ptr = (void *)frame->data[0] + i * fake_width;
+                void *devi_ptr = (void *)tempInput->plane[0].addr + i * tempInput->stride[0];
+                if (NULL == host_ptr) {
+                  av_log(cnctx->avctx, AV_LOG_ERROR, "Jpeg encoder input buffer address(CPU) is NULL \n");
+                  return -1;
+                }
+                if (NULL == devi_ptr) {
+                  av_log(cnctx->avctx, AV_LOG_ERROR, "Jpeg encoder input data address(MLU) is NULL \n");
+                  return -1;
+                }
+                cnrt_ret = cnrtMemcpy(devi_ptr, host_ptr, fake_width, CNRT_MEM_TRANS_DIR_HOST2DEV);
+                if (cnctx->trace_flag) {
+                  av_log(cnctx->avctx, AV_LOG_INFO, "Yuv h2d plane: host %p -> devi %p, size %d \n",
+                        host_ptr, devi_ptr, fake_width);
+                }
+                CNRT_ERROR_CHECK(cnctx->avctx, cnrt_ret);
+            }
+        }
+        break;
+    case CNCODEC_PIX_FMT_NV12:
+    case CNCODEC_PIX_FMT_NV21:
+        if (cnctx->width == tempInput->stride[0]) {
+            if (NULL == (void *)tempInput->plane[0].addr || NULL == (void *)tempInput->plane[1].addr) {
+                av_log(cnctx->avctx, AV_LOG_ERROR, "Jpeg encoder input buffer address(MLU) is NULL \n");
+                return -1;
+            }
+            if (NULL == frame->data[0] || NULL == frame->data[1]) {
+                av_log(cnctx->avctx, AV_LOG_ERROR, "Jpeg encoder input data address(CPU) is NULL \n");
+                return -1;
+            }
+            cnrt_ret = cnrtMemcpy((void *)tempInput->plane[0].addr, (void *)frame->data[0],
+                                  tempInput->plane[0].size, CNRT_MEM_TRANS_DIR_HOST2DEV);
+            if (cnctx->trace_flag) {
+                av_log(cnctx->avctx, AV_LOG_INFO, "palne[0].size: %d  width * height: %d\n",
+                      tempInput->plane[0].size, cnctx->width * cnctx->height);
+                av_log(cnctx->avctx, AV_LOG_INFO, "yuv h2d plane[0]: src %p -> dst %p, size: %d\n",
+                      frame->data[0], tempInput->plane[0].addr, tempInput->plane[0].size);
+            }
+            CNRT_ERROR_CHECK(cnctx->avctx, cnrt_ret);
+            cnrt_ret = cnrtMemcpy((void *)tempInput->plane[1].addr, (void *)frame->data[1],
+                                  tempInput->plane[1].size, CNRT_MEM_TRANS_DIR_HOST2DEV);
+            if (cnctx->trace_flag) {
+                av_log(cnctx->avctx, AV_LOG_INFO, "palne[1].size: %d  width * height / 2: %d\n",
+                       tempInput->plane[1].size, cnctx->width * cnctx->height / 2);
+                av_log(cnctx->avctx, AV_LOG_INFO, "yuv h2d plane[1]: src %p -> dst %p, size: %d\n",
+                       frame->data[1], tempInput->plane[1].addr, tempInput->plane[1].size);
+            }
+            CNRT_ERROR_CHECK(cnctx->avctx, cnrt_ret);
+        } else {
+            for (int i = 0; i < cnctx->height; i++) {
+                void *host_ptr = (void *)frame->data[0] + i * cnctx->width;
+                void *devi_ptr = (void *)tempInput->plane[0].addr + i * tempInput->stride[0];
+                if (NULL == host_ptr) {
+                  av_log(cnctx->avctx, AV_LOG_ERROR, "Jpeg encoder input buffer address(CPU) is NULL \n");
+                  return -1;
+                }
+                if (NULL == devi_ptr) {
+                  av_log(cnctx->avctx, AV_LOG_ERROR, "Jpeg encoder input data address(MLU) is NULL \n");
+                  return -1;
+                }
+                cnrt_ret = cnrtMemcpy(devi_ptr, host_ptr, cnctx->width, CNRT_MEM_TRANS_DIR_HOST2DEV);
+                if (cnctx->trace_flag) {
+                  av_log(cnctx->avctx, AV_LOG_INFO, "Yuv h2d plane: host %p -> devi %p, size(host) %d \n",
+                        host_ptr, devi_ptr, cnctx->width);
+                }
+                CNRT_ERROR_CHECK(cnctx->avctx, cnrt_ret);
+            }
+            for (int i = 0; i < cnctx->height / 2; i++) {
+                void *host_ptr = (void *)frame->data[1] + i * cnctx->width;
+                void *devi_ptr = (void *)tempInput->plane[1].addr + i * tempInput->stride[1];
+                if (NULL == host_ptr) {
+                  av_log(cnctx->avctx, AV_LOG_ERROR, "Jpeg encoder input buffer address(CPU) is NULL \n");
+                  return -1;
+                }
+                if (NULL == devi_ptr) {
+                  av_log(cnctx->avctx, AV_LOG_ERROR, "Jpeg encoder input data address(MLU) is NULL \n");
+                  return -1;
+                }
+                cnrt_ret = cnrtMemcpy(devi_ptr, host_ptr, cnctx->width, CNRT_MEM_TRANS_DIR_HOST2DEV);
+                if (cnctx->trace_flag) {
+                  av_log(cnctx->avctx, AV_LOG_INFO, "Yuv h2d plane: host %p -> devi %p, size(host) %d \n",
+                        host_ptr, devi_ptr, cnctx->width);
+                }
+                CNRT_ERROR_CHECK(cnctx->avctx, cnrt_ret);
+            }
+        }
+        break;
+    default:
+        av_log(cnctx->avctx, AV_LOG_ERROR, "Not supported format:%d\n", ret);
+        break;
+    }
+    if (cnctx->trace_flag) {
+        av_log(cnctx->avctx, AV_LOG_INFO, "------------jpeg_enc_input_frame end-----------\n");
+    }
+    return ret;
+}
+static int jpeg_enc_output_packet(CNJpegEncContext_t *cnctx, AVPacket *pkt, int *got_packet)
+{
+    if (cnctx->trace_flag) {
+        av_log(cnctx->avctx, AV_LOG_INFO, "------------jpeg_enc_output_packet start-----------\n");
+    }
+    int ret = 0;
+    enum AVPictureType pict_type = AV_PICTURE_TYPE_NONE;
+    if (cnctx->trace_flag) {
+        _dump_output_pkt(cnctx, &cnctx->output_buf);
+    }
+    if (cnctx->output_buf.flags & CNJPEGENC_FLAG_EOS) {
+        // EOS got.
+        *got_packet = 0;
+        return AVERROR_EOF;
+    }
+    ret = pkt->data ? ff_alloc_packet2(cnctx->avctx, pkt, cnctx->output_buf.streamLength,
+          cnctx->output_buf.streamLength) : av_new_packet(pkt, cnctx->output_buf.streamLength);
+    if (ret < 0) {
+        av_log(cnctx->avctx, AV_LOG_ERROR, "Failed to allocate pkt memory\n");
+        *got_packet = 0;
+        return AVERROR(EINVAL);
+    }
+
+    cnrtRet_t rtRet;
+    void *validDataAddr = NULL;
+    validDataAddr = (void *)(cnctx->output_buf.streamBuffer.addr + cnctx->output_buf.dataOffset);
+    rtRet  = cnrtMemcpy((void *)pkt->data, (void *)validDataAddr, cnctx->output_buf.streamLength, CNRT_MEM_TRANS_DIR_DEV2HOST);
+    if(rtRet != CNRT_RET_SUCCESS) {
+        av_log(cnctx->avctx, AV_LOG_INFO, "cnrtmemcpy d2h: src %p -> dst %p size: %d  \n",
+               validDataAddr, pkt->data, cnctx->output_buf.streamLength);
+        av_log(cnctx->avctx, AV_LOG_ERROR, "output packet: cnrtMemcpy error ...\n");
+        return -1;
+    }
+
+    *got_packet = 1;
+    cnctx->total_outframe_count++;
+    pkt->pts = cnctx->output_buf.pts;
+    pkt->size = cnctx->output_buf.streamLength;
+
+    pkt->dts = pkt->pts;
+    pkt->pts = av_rescale_q_rnd(pkt->pts, (AVRational){1, 90000}, cnctx->avctx->time_base, (AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX));
+    pkt->dts = av_rescale_q_rnd(pkt->dts, (AVRational){1, 90000}, cnctx->avctx->time_base, (AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX));
+    pkt->duration = av_rescale_q(pkt->duration, (AVRational){1, 90000}, cnctx->avctx->time_base);
+    if (cnctx->trace_flag) {
+        av_log(cnctx->avctx, AV_LOG_INFO, "------------jpeg_enc_output_packet end-----------\n");
+    }
+    return ret;
+}
+
+static int allocateEncCodecFrameBuffer(CNJpegEncContext_t *cnctx)
+{
+    if (cnctx->trace_flag) {
+        av_log(cnctx->avctx, AV_LOG_INFO, "------------allocateEncCodecFrameBuffer start-----------\n");
+    }
+    unsigned int j = 0;
+    unsigned int size;
+    unsigned int width;
+    unsigned int height;
+    cnrtRet_t  rtRet;
+    uint32_t planes_num;
+    cnrtChannelType_t channel;
+
+    if (!(&cnctx->input_buf.frame)) {
+        av_log(cnctx->avctx, AV_LOG_ERROR, "cnctx->input_buf.frame address is null...\n");
+        return -1;
+    }
+    if (cnctx->pixelFmt == CNCODEC_PIX_FMT_NV12 || cnctx->pixelFmt == CNCODEC_PIX_FMT_NV21) {
+        planes_num = 2;
+    }
+    else if (cnctx->pixelFmt == CNCODEC_PIX_FMT_I420 || cnctx->pixelFmt == CNCODEC_PIX_FMT_YV12)
+    {
+        planes_num = 3;
+    } else {
+        planes_num = 1;
+    }
+    width = cnctx->width > 0 ? cnctx->width : 1920;
+    height = cnctx->height > 0 ? cnctx->height : 1080;
+
+    memset(&cnctx->input_buf.frame, 0, sizeof(cncodecFrame));
+    rtRet = cnrtGetCurrentChannel(&channel);
+    CNRT_ERROR_CHECK(cnctx->avctx, rtRet);
+    cnctx->input_buf.frame.channel = (int)channel;
+    cnctx->input_buf.frame.width    = width;
+    cnctx->input_buf.frame.height   = height;
+    cnctx->input_buf.frame.planeNum = planes_num;
+    cnctx->input_buf.frame.pixelFmt = cnctx->pixelFmt;
+    cnctx->input_buf.frame.deviceId = cnctx->device_id;
+
+    for (j = 0; j < planes_num; j++) {
+        unsigned int planeW = get_plane_width(cnctx, width, j);
+        unsigned int stride = ALIGN64(planeW);
+        size  = stride * get_plane_height(cnctx, height, j);
+        cnctx->input_buf.frame.plane[j].addr = NULL;
+        rtRet = cnrtMallocFrameBuffer((void **)(&cnctx->input_buf.frame.plane[j].addr), size);
+        if (rtRet != CNRT_RET_SUCCESS) {
+            av_log(cnctx->avctx, AV_LOG_ERROR, "%s() call cnrtMallocFrameBuffer failed\n", __FUNCTION__);
+            goto alloc_failed;
+        }
+        cnctx->input_buf.frame.plane[j].size = size;
+        cnctx->input_buf.frame.stride[j]     = stride;
+    }
+    if (cnctx->trace_flag) {
+        av_log(cnctx->avctx, AV_LOG_INFO, "------------allocateEncCodecFrameBuffer end-----------\n");
+    }
+    return 0;
+
+alloc_failed:
+    for (j = 0; j < planes_num; ++j) {
+        if (cnctx->input_buf.frame.plane[j].addr != 0) {
+            rtRet = cnrtFree((void *)cnctx->input_buf.frame.plane[j].addr);
+            CNRT_ERROR_CHECK(cnctx->avctx, rtRet);
+        }
+    }
+    return -1;
+}
+static int releaseEncodeCodecFrameBuffer(CNJpegEncContext_t *cnctx)
+{
+    if (cnctx->trace_flag) {
+        av_log(cnctx->avctx, AV_LOG_INFO, "------------releaseEncodeCodecFrameBuffer start-----------\n");
+    }
+    cnrtRet_t rtRet;
+    if (!(&cnctx->input_buf.frame)) {
+        return -1;
+    }
+    for (unsigned j = 0; j < cnctx->input_buf.frame.planeNum; j++) {
+        rtRet = cnrtFree((void *)(cnctx->input_buf.frame.plane[j].addr));
+        if (rtRet != CNRT_RET_SUCCESS) {
+            av_log(cnctx->avctx, AV_LOG_INFO, "Release input buffer faile ...\n");
+        }
+        CNRT_ERROR_CHECK(cnctx->avctx, rtRet);
+    }
+    CNRT_ERROR_CHECK(cnctx->avctx, rtRet);
+    if (cnctx->trace_flag) {
+        av_log(cnctx->avctx, AV_LOG_INFO, "------------releaseEncodeCodecFrameBuffer end-----------\n");
+    }
+    return 0;
+}
+static int allocateEncodeDevMemBuf(CNJpegEncContext_t *cnctx)
+{
+    if (cnctx->trace_flag) {
+        av_log(cnctx->avctx, AV_LOG_INFO, "------------allocateEncodeDevMemBuf start-----------\n");
+    }
+    cnrtRet_t  rtRet;
+    if (!(&cnctx->output_buf.streamBuffer)) {
+        av_log(cnctx->avctx, AV_LOG_ERROR, "cnctx->output_buf.streamBuffer address is null...\n");
+        return -1;
+    }
+    memset(&cnctx->output_buf.streamBuffer, 0, sizeof(cncodecDevMemory));
+    rtRet = cnrtMallocFrameBuffer((void **)(&cnctx->output_buf.streamBuffer.addr), OUTPUT_BUFFER_SIZE_FOR_ENCODE);
+    if (rtRet != CNRT_RET_SUCCESS) {
+        av_log(cnctx->avctx, AV_LOG_ERROR, "%s() call cnrtMallocFrameBuffer failed\n", __FUNCTION__);
+        return -1;
+    }
+    cnctx->output_buf.streamBuffer.size = OUTPUT_BUFFER_SIZE_FOR_ENCODE;
+    if (cnctx->trace_flag) {
+        av_log(cnctx->avctx, AV_LOG_INFO, "------------allocateEncodeDevMemBuf end-----------\n");
+    }
+    return 0;
+}
+static int releaseEncodeDevMemBuf(CNJpegEncContext_t *cnctx)
+{
+    if (cnctx->trace_flag) {
+        av_log(cnctx->avctx, AV_LOG_INFO, "------------releaseEncodeDevMemBuf start-----------\n");
+    }
+    cnrtRet_t rtRet;
+    if (!(&cnctx->output_buf.streamBuffer)) {
+        return -1;
+    }
+    if (cnctx->output_buf.streamBuffer.addr != 0) {
+        rtRet = cnrtFree((void *)cnctx->output_buf.streamBuffer.addr);
+        CNRT_ERROR_CHECK(cnctx->avctx, rtRet);
+    }
+    if (cnctx->trace_flag) {
+        av_log(cnctx->avctx, AV_LOG_INFO, "------------releaseEncodeDevMemBuf end-----------\n");
+    }
+    return 0;
+}
+
+static int alloc_syncencode_in_and_out_buffer(CNJpegEncContext_t *cnctx)
+{
+    if (cnctx->trace_flag) {
+        av_log(cnctx->avctx, AV_LOG_INFO, "------------alloc_syncencode_in_and_out_buffer start-----------\n");
+    }
+    int ret;
+    ret = allocateEncCodecFrameBuffer(cnctx);
+    if (ret < 0) {
+        av_log(cnctx->avctx, AV_LOG_ERROR, "allocateEncCodecFrameBuffer failed ...\n");
+        return -1;
+    }
+    ret = allocateEncodeDevMemBuf(cnctx);
+    if (ret < 0) {
+        av_log(cnctx->avctx, AV_LOG_ERROR, "allocateEncodeDevMemBuf failed ...\n");
+        return -1;
+    }
+    if (cnctx->trace_flag) {
+        av_log(cnctx->avctx, AV_LOG_INFO, "------------alloc_syncencode_in_and_out_buffer end-----------\n");
+    }
+    return 0;
+}
+static int release_syncencode_in_and_out_buffer(CNJpegEncContext_t *cnctx)
+{
+    if (cnctx->trace_flag) {
+        av_log(cnctx->avctx, AV_LOG_INFO, "------------release_syncencode_in_and_out_buffer start-----------\n");
+    }
+    int ret;
+    ret = releaseEncodeCodecFrameBuffer(cnctx);
+    if (ret < 0) {
+        av_log(cnctx->avctx, AV_LOG_ERROR, "releaseEncodeCodecFrameBuffer failed ...\n");
+        return -1;
+    }
+    ret = releaseEncodeDevMemBuf(cnctx);
+    if (ret < 0) {
+        av_log(cnctx->avctx, AV_LOG_ERROR, "releaseEncodeDevMemBuf failed ...\n");
+        return -1;
+    }
+    if (cnctx->trace_flag) {
+        av_log(cnctx->avctx, AV_LOG_INFO, "------------release_syncencode_in_and_out_buffer end-----------\n");
+    }
+    return 0;
+}
+
+// main functions
+static int ff_mlumpp_jpeg_enc_frame(AVCodecContext *avctx, AVPacket *pkt,
+                                    const AVFrame *frame, int *got_packet) {
+    CNJpegEncContext_t *cnctx;
+    cnctx = (CNJpegEncContext_t *)avctx->priv_data;
+    if (cnctx->trace_flag) {
+        av_log(avctx, AV_LOG_INFO, "---------------------ff_mlumpp_jpeg_enc_frame start------------------\n");
+    }
+    int ret = -1;
+    cnjpegEncInput *input;
+    input = &cnctx->input_buf;
+    if (NULL == avctx || NULL == cnctx || !cnctx->encoder_init_flag) { // Sanity checks... these are all serious usage bugs.
+        av_log(avctx, AV_LOG_ERROR, "Early error in \"ff_mlumpp_jpeg_enc_frame\" \n");
+        return -1;
+    }
+    if (cnctx->codec_abort_flag) {
+        av_log(avctx, AV_LOG_ERROR, "Jpeg encoder got abort flag before sending frame, return AVERROR_EXTERNAL\n");
+        return AVERROR_EXTERNAL;
+    }
+    if (cnctx->trace_flag) {
+        av_log(avctx, AV_LOG_INFO, "Send frame: %ux%u (%" PRId64 "),frame tpe:%d\n",\
+               frame->width, frame->height, frame->pts, frame->pict_type);
+    }
+    input->frame = cnctx->input_buf.frame;
+    input->pts = av_rescale_q(frame->pts, avctx->time_base, (AVRational){1, 90000});
+    jpeg_enc_input_frame(cnctx, &(input->frame), frame);
+
+    cnjpegEncOutput *output;
+    output = &cnctx->output_buf;
+    if (cnctx->handle) {
+        int timeout = (1000 / 25) * cnctx->input_buf_num * 50;
+        if (cnctx->trace_flag) {
+            av_log(avctx, AV_LOG_INFO, "cnjpegEncSyncEncode before ...\n");
+            av_log(avctx, AV_LOG_INFO, "enFrameParam: %d  %d  %d \n", cnctx->enFrameParam.quality,\
+               cnctx->enFrameParam.restartInterval, cnctx->enFrameParam.metaData);
+        }
+        ret = cnjpegEncSyncEncode(cnctx->handle, output, input, &cnctx->enFrameParam, timeout);
+        if (cnctx->trace_flag) {
+            av_log(avctx, AV_LOG_INFO, "input frame width: %d height: %d planeNum: %d\n",
+                   input->frame.width, input->frame.height, input->frame.planeNum);
+            av_log(avctx, AV_LOG_INFO, "output length: %d  size: %d\n", output->streamLength, output->streamBuffer.size);
+            av_log(avctx, AV_LOG_INFO, "cnjpegEncSyncEncode after ...\n");
+        }
+        if (ret == CNCODEC_SUCCESS) {
+            if (cnctx->trace_flag) {
+                av_log(avctx, AV_LOG_INFO, "cnjpegEncSyncEncode success ...\n");
+            }
+            cnctx->total_frame_count++;
+            if (output->result == 0) {
+                if (cnctx->trace_flag) {
+                    av_log(avctx, AV_LOG_INFO, "Jpeg encoded yuv data is succeeed\n");
+                }
+                ret = jpeg_enc_output_packet(cnctx, pkt, got_packet);
+                if (ret < 0) {
+                  av_log(avctx, AV_LOG_WARNING, "Jpeg enc output packet failed ...\n");
+                }
+            } else {
+                av_log(avctx, AV_LOG_WARNING, "Jpeg encoded yuv data is failed, skip this frame ...\n");
+            }
+        } else if (ret == CNCODEC_JPU_ENC_FAIL | ret == CNCODEC_TIMEOUT) {
+            av_log(avctx, AV_LOG_INFO, "cnjpegEncSyncEncode faile or timeout ...\n");
+            ret = _jpeg_enc_abort_handler(cnctx);
+        }
+        CNCODEC_ERROR_CHECK(avctx, ret);
+    } else {
+        av_log(avctx, AV_LOG_WARNING, "Jpeg encoder handle is NULL, skip cnjpegEncSyncEncode\n");
+    }
+    if (cnctx->trace_flag) {
+        _dump_feeding_frame(cnctx, input);
+        av_log(avctx, AV_LOG_INFO, "---------------------ff_mlumpp_jpeg_enc_frame end------------------\n");
+    }
+    return ret;
+}
+static int ff_mlumpp_jpeg_enc_init(AVCodecContext *avctx)
+{
+    CNJpegEncContext_t *cnctx;
+    cnctx = (CNJpegEncContext_t *)avctx->priv_data;
+    if (cnctx->trace_flag) {
+        av_log(avctx, AV_LOG_INFO, "---------------------ff mlumpp jpeg enc init start------------------\n");
+    }
+    int ret = -1;
+    cnjpegEncCreateInfo enc_params;
+    cnctx->enc_create_params = &enc_params;
+    if (NULL == avctx || NULL == cnctx || 1 == cnctx->encoder_init_flag) { //Sanity checks... these are all serious usage bugs.
+        av_log(avctx, AV_LOG_ERROR, "Early error in \"ff_mlumpp_jpeg_enc_init\" \n");
+        return -1;
+    }
+    if(0 != mlumpp_adapt_resolution(avctx)) {
+        return AVERROR(EINVAL);
+    }
+    // set device
+    mlumpp_enc_get_cnrt_ctx(avctx, cnctx, CNRT_CHANNEL_TYPE_NONE);
+
+    cnctx->width = avctx->width;
+    cnctx->height = avctx->height;
+    int bitstream_buf_size = 0;
+    bitstream_buf_size = cnctx->width * cnctx->height;
+    switch (avctx->pix_fmt) {
+    case AV_PIX_FMT_NV12:
+        if (cnctx->trace_flag) av_log(avctx, AV_LOG_INFO, "pix fmt：AV_PIX_FMT_NV12\n");
+        cnctx->pixelFmt = CNCODEC_PIX_FMT_NV12;
+        bitstream_buf_size += (bitstream_buf_size >> 1);
+        break;
+    case AV_PIX_FMT_NV21:
+        if (cnctx->trace_flag) av_log(avctx, AV_LOG_INFO, "pix fmt: AV_PIX_FMT_NV21\n");
+        cnctx->pixelFmt = CNCODEC_PIX_FMT_NV21;
+        bitstream_buf_size += (bitstream_buf_size >> 1);
+        break;
+    case AV_PIX_FMT_YUYV422:
+        if (cnctx->trace_flag) av_log(avctx, AV_LOG_INFO, "pix fmt: AV_PIX_FMT_YUYV422\n");
+        cnctx->pixelFmt = CNCODEC_PIX_FMT_YUYV;
+        bitstream_buf_size = (bitstream_buf_size << 1);
+        break;
+    case AV_PIX_FMT_UYVY422:
+        if (cnctx->trace_flag) av_log(avctx, AV_LOG_INFO, "pix fmt: AV_PIX_FMT_UYUV422\n");
+        cnctx->pixelFmt = CNCODEC_PIX_FMT_UYVY;
+        bitstream_buf_size = (bitstream_buf_size << 1);
+        break;
+    default:
+        av_log(avctx, AV_LOG_WARNING, "default: pix fmt: AV_PIX_FMT_NV12\n");
+        cnctx->pixelFmt = CNCODEC_PIX_FMT_NV12;
+        bitstream_buf_size += (bitstream_buf_size >> 1);
+        break;
+    }
+    bitstream_buf_size *= 0.75; // 0.75 for save buf size
+
+    cnctx->total_frame_count = 0;
+    cnctx->total_packet_count = 0;
+    cnctx->total_outframe_count = 0;
+    cnctx->codec_abort_flag = 0;
+
+    memset(&enc_params, 0, sizeof(cnjpegEncCreateInfo));
+    enc_params.width = cnctx->width;
+    enc_params.height = cnctx->height;
+    enc_params.pixelFmt = cnctx->pixelFmt;
+    enc_params.deviceId = cnctx->device_id;
+    enc_params.allocType = CNCODEC_BUF_ALLOC_LIB;
+    enc_params.inputBufNum = cnctx->input_buf_num;
+    enc_params.outputBufNum = cnctx->output_buf_num;
+    enc_params.instance = mlump_jpeg_enc_get_vpu_inst(cnctx->instance_id);
+    enc_params.userContext = (void *)cnctx;
+    if ( FFALIGN(bitstream_buf_size, 4096) < OUTPUT_BUFFER_SIZE_FOR_ENCODE) {
+        enc_params.suggestedLibAllocBitStrmBufSize = FFALIGN(bitstream_buf_size, 4096);
+    } else {
+        enc_params.suggestedLibAllocBitStrmBufSize = OUTPUT_BUFFER_SIZE_FOR_ENCODE;
+    }
+
+    if (cnctx->trace_flag > 0) {
+        _dump_jpeg_enc_params(avctx, &enc_params);
+    }
+    cnctx->avctx = avctx;
+    cnctx->total_frame_count = 0;
+    cnctx->total_packet_count = 0;
+    cnctx->total_outframe_count = 0;
+
+    /*-------------------------- create jpeg encoder ------------------------*/
+    ret = cnjpegEncCreate(&cnctx->handle, CNJPEGENC_RUN_MODE_SYNC, NULL, &enc_params);
+    if (ret != CNCODEC_SUCCESS) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to create jpeg encoder, ret(%d)\n", ret);
+        cnctx->handle = NULL;
+        return AVERROR_EXTERNAL; //  notice user
+    }
+    if (cnctx->trace_flag) {
+        av_log(avctx, AV_LOG_INFO, "Create JPEG encoder succeeded\n");
+    }
+
+    /*--------------------- allocate input & output buffer --------------------*/
+    memset(&cnctx->enFrameParam, 1, sizeof(cnjpegEncParameters));
+    cnctx->enFrameParam.quality = cnctx->jpeg_quality; // jpeg_quality
+    cnctx->enFrameParam.restartInterval = 0;
+    cnctx->enFrameParam.metaData = 0;
+    if (cnctx->trace_flag) {
+        av_log(avctx, AV_LOG_INFO, "sync encode in out buffer before ...\n");
+    }
+    alloc_syncencode_in_and_out_buffer(cnctx);
+    if (cnctx->trace_flag) {
+        av_log(avctx, AV_LOG_INFO, "sync encode in out buffer after ...\n");
+    }
+    cnctx->encoder_init_flag = 1;
+    if (cnctx->trace_flag) {
+        av_log(avctx, AV_LOG_INFO, "---------------------ff mlumpp jpeg enc init end------------------\n");
+    }
+    return 0;
+}
+static int ff_mlumpp_jpeg_enc_close(AVCodecContext *avctx)
+{
+    CNJpegEncContext_t *cnctx;
+    cnctx = (CNJpegEncContext_t *)avctx->priv_data;
+    if (cnctx->trace_flag) {
+        av_log(avctx, AV_LOG_INFO, "-------------------ff mlumpp jpeg enc close start------------------\n");
+    }
+    int ret = -1;
+    if (NULL == avctx || NULL == cnctx) { // Sanity checks... these are all serious usage bugs.
+        av_log(avctx, AV_LOG_ERROR, "Early error in \"ff_mlumpp_jpeg_enc_close\" \n");
+        return -1;
+    }
+    if (cnctx->trace_flag) {
+        av_log(avctx, AV_LOG_INFO, "User start to release encoder device\n");
+    }
+    if (cnctx->handle) {
+        release_syncencode_in_and_out_buffer(cnctx);
+        ret = cnjpegEncDestroy(cnctx->handle);
+        if (ret != CNCODEC_SUCCESS) {
+            av_log(avctx, AV_LOG_ERROR, "Call CN_Encode_Desroy failed, ret(%u)\n", ret);
+            return -1;
+        }
+        cnctx->handle = NULL;
+    }
+    CNCODEC_ERROR_CHECK(avctx, ret);
+    cnrtDestroy();
+    cnctx->encoder_init_flag = 0;
+    if (cnctx->trace_flag) {
+        av_log(avctx, AV_LOG_INFO, "--------------MLU MPP Jpeg encoder status summary-------------\n");
+        av_log(avctx, AV_LOG_INFO, "Jpeg encode thread id, %lu \n", (long unsigned)pthread_self());
+        av_log(avctx, AV_LOG_INFO, "Jpeg encode D2H total packet count:%llu\n", cnctx->total_outframe_count);
+        av_log(avctx, AV_LOG_INFO, "Jpeg encode received total packet count:%llu\n", cnctx->total_packet_count);
+        av_log(avctx, AV_LOG_INFO, "Jpeg encode feed data count:%llu\n", cnctx->total_frame_count);
+        av_log(avctx, AV_LOG_INFO, "---------------------ff mlumpp jpeg enc init end------------------\n");
+    }
+    return 0;
+}
+
+#define OFFSET(x) offsetof(CNJpegEncContext_t, x)
+#ifndef VE
+#define VE AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM
+#endif
+
+static const AVOption options[] = {
+    { "device_id",     "use to choose the accelerator card",       OFFSET(device_id),       AV_OPT_TYPE_INT, { .i64 = 0 },0, INT_MAX, VE },
+    { "instance_id",   "use to choose which vpu instance",         OFFSET(instance_id),     AV_OPT_TYPE_INT, { .i64 = 0 },0, INT_MAX, VE },
+    { "input_buf_num",  "Number of input buffers for encoder",     OFFSET(input_buf_num),   AV_OPT_TYPE_INT, { .i64 = 3 },1, 18, VE },
+    { "output_buf_num","Number of output buffers for encoder",     OFFSET(output_buf_num),  AV_OPT_TYPE_INT, { .i64 = 3 },1, 18, VE },
+    { "trace", "Whether open trace switch or not",                 OFFSET(trace_flag),      AV_OPT_TYPE_INT, { .i64 = 0 },0, 1, VE },
+    { "quality", "Encode quality",                                 OFFSET(jpeg_quality),    AV_OPT_TYPE_INT, { .i64 = 80 },0, 100, VE },
+    { NULL },
+};
+static const AVClass mjpeg_mluenc_class = {
+    .class_name = "mjpeg_mluenc",
+    .item_name  = av_default_item_name,
+    .option     = options,
+    .version    = LIBAVUTIL_VERSION_INT,
+};
+AVCodec ff_mjpeg_mlumpp_encoder = {
+    .name = "mjpeg_mluenc",
+    .long_name = NULL_IF_CONFIG_SMALL("Jpeg (Cambricon Jpeg acceleration)"),
+    .type = AVMEDIA_TYPE_VIDEO,
+    .id = AV_CODEC_ID_MJPEG,
+    .init = ff_mlumpp_jpeg_enc_init,
+    //.send_frame = ff_mlumpp_jpeg_enc_send_frame,
+    //.receive_packet = ff_mlumpp_jpeg_enc_receive_packet,
+    .encode2 = ff_mlumpp_jpeg_enc_frame,
+    .close = ff_mlumpp_jpeg_enc_close,
+    .priv_data_size = sizeof(CNJpegEncContext_t),
+    .priv_class = &mjpeg_mluenc_class,
+    .capabilities = AV_CODEC_CAP_FRAME_THREADS | AV_CODEC_CAP_INTRA_ONLY,
+    .caps_internal = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .pix_fmts = (const enum AVPixelFormat[]){AV_PIX_FMT_NV12,
+                                             AV_PIX_FMT_NV21,
+                                             AV_PIX_FMT_YUYV422,
+                                             AV_PIX_FMT_UYVY422,
+                                             AV_PIX_FMT_NONE},
+    .wrapper_name = "mluenc",
+};
\ No newline at end of file
diff --git a/libavcodec/mlumpp_mluop.c b/libavcodec/mlumpp_mluop.c
new file mode 100755
index 0000000..8266887
--- /dev/null
+++ b/libavcodec/mlumpp_mluop.c
@@ -0,0 +1,122 @@
+/******************************************************************************
+ * Cambricon MLU Media Process Platform(MLU MPP) SDK
+ * Copyright (C) [2019] by Cambricon, Inc. All rights reserved
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *******************************************************************************/
+#include "mlumpp_mluop.h"
+#include "libavutil/avstring.h"
+#include "libavutil/log.h"
+#include "cnrt.h"
+#include <dlfcn.h>
+#define CNRT_ERROR_CHECK(avctx, ret)                                                       \
+    if (ret != CNRT_RET_SUCCESS) {                                                         \
+        av_log(avctx,AV_LOG_ERROR,"error occur, func: %s, line: %d\n", __func__, __LINE__);\
+        return -1;                                                                         \
+    }
+typedef struct mlumpp_mluop_ctx {
+    void *lib;
+    HANDLE_MLU_OP mlu_handle;
+    void *logctx;
+    int (*ptr_resize_yuv_init)(void **, int, int, int, int, int, int,int);
+    int (*ptr_resize_yuv_exec)(void *, void *, void *, void *, void *);
+    int (*ptr_resize_yuv_destroy)(void *);
+} mlumpp_mluop_ctx_t;
+
+static av_cold void *dlsym_prefixed(void *handle, const char *symbol,
+                                    const char *prefix) {
+    char buf[50];
+    snprintf(buf, sizeof(buf), "%s_%s", prefix ? prefix : "", symbol);
+    return dlsym(handle, buf);
+}
+
+int mlumpp_mluop_load(HANDLE_MLU_OP *h, const char *libname, void *logctx) {
+    mlumpp_mluop_ctx_t *mluop_ctx;
+    mluop_ctx = av_mallocz(sizeof(*mluop_ctx));
+    if (mluop_ctx == NULL) {
+        return AVERROR(ENOMEM);
+    }
+    if (libname) {
+        mluop_ctx->lib = dlopen(libname, RTLD_NOW | RTLD_GLOBAL);
+        if (!mluop_ctx->lib) {
+            // av_log(logctx, AV_LOG_WARNING, "%s not found\n", libname);
+            av_free(mluop_ctx);
+            return AVERROR_EXTERNAL;
+        } else {
+            av_log(logctx, AV_LOG_TRACE, "%s found\n", libname);
+        }
+    }
+    mluop_ctx->ptr_resize_yuv_init =
+        dlsym_prefixed(mluop_ctx->lib, "resize_yuv_invoke_init", "mluop");
+    mluop_ctx->ptr_resize_yuv_exec =
+        dlsym_prefixed(mluop_ctx->lib, "resize_yuv_invoke_exec", "mluop");
+    mluop_ctx->ptr_resize_yuv_destroy =
+        dlsym_prefixed(mluop_ctx->lib, "resize_yuv_invoke_destroy", "mluop");
+    if (!mluop_ctx->ptr_resize_yuv_init || !mluop_ctx->ptr_resize_yuv_exec ||
+        !mluop_ctx->ptr_resize_yuv_destroy) {
+        av_log(logctx, AV_LOG_WARNING, "Not all functions found in %s\n",
+                libname);
+        dlclose(mluop_ctx->lib);
+        mluop_ctx->lib = NULL;
+        av_free(mluop_ctx);
+        return AVERROR_EXTERNAL;
+    }
+    mluop_ctx->logctx = logctx;
+    *h = (void *)mluop_ctx;
+    return 0;
+}
+int mlumpp_mluop_resize_yuv_init(HANDLE_MLU_OP h, int src_w, int src_h, int dst_w,
+                                 int dst_h, int dev_id) {
+    cnrtRet_t cnrt_ret;
+    mlumpp_mluop_ctx_t *mluop_ctx = (mlumpp_mluop_ctx_t *)h;
+    if (!mluop_ctx->lib || !mluop_ctx->ptr_resize_yuv_init) {
+        return AVERROR_EXTERNAL;
+    }
+    return mluop_ctx->ptr_resize_yuv_init(&mluop_ctx->mlu_handle, src_w, src_h,
+                                          -1, dst_w, dst_h, -1, dev_id);
+}
+int mlumpp_mluop_resize_yuv_exec(HANDLE_MLU_OP h, void *src_y, void *src_uv,
+                                 void *dst_y, void *dst_uv) {
+
+    mlumpp_mluop_ctx_t *mluop_ctx = (mlumpp_mluop_ctx_t *)h;
+    if (!mluop_ctx || !mluop_ctx->lib || !mluop_ctx->ptr_resize_yuv_exec) {
+        return AVERROR_EXTERNAL;
+    }
+    return mluop_ctx->ptr_resize_yuv_exec(mluop_ctx->mlu_handle, src_y, src_uv, dst_y, dst_uv);
+}
+int mlumpp_mluop_resize_yuv_destroy(HANDLE_MLU_OP h) {
+    mlumpp_mluop_ctx_t *mluop_ctx = (mlumpp_mluop_ctx_t *)h;
+    if (!mluop_ctx || !mluop_ctx->lib || !mluop_ctx->ptr_resize_yuv_destroy) {
+        return AVERROR_EXTERNAL;
+    }
+    return mluop_ctx->ptr_resize_yuv_destroy(mluop_ctx->mlu_handle);
+}
+
+int mlumpp_mluop_unload(HANDLE_MLU_OP h) {
+    cnrtRet_t cnrt_ret;
+    mlumpp_mluop_ctx_t *mluop_ctx = (mlumpp_mluop_ctx_t *)h;
+    if (!mluop_ctx) {
+        return -1;
+    }
+    if (mluop_ctx->lib) {
+        dlclose(mluop_ctx->lib);
+        mluop_ctx->lib = NULL;
+    }
+    av_free(mluop_ctx);
+    mluop_ctx = NULL;
+    return 0;
+}
diff --git a/libavcodec/mlumpp_mluop.h b/libavcodec/mlumpp_mluop.h
new file mode 100755
index 0000000..45dc55a
--- /dev/null
+++ b/libavcodec/mlumpp_mluop.h
@@ -0,0 +1,33 @@
+/******************************************************************************
+ * Cambricon MLU Media Process Platform(MLU MPP) SDK
+ * Copyright (C) [2019] by Cambricon, Inc. All rights reserved
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *******************************************************************************/
+#ifndef AVCODEC_MLUMPP_MLUOP_H
+#define AVCODEC_MLUMPP_MLUOP_H
+
+typedef void *HANDLE_MLU_OP;
+int mlumpp_mluop_load(HANDLE_MLU_OP *h, const char *path, void *logctx);
+int mlumpp_mluop_resize_yuv_init(HANDLE_MLU_OP h, int src_w, int src_h, int dst_w,
+                                 int dst_h, int dev_id);
+int mlumpp_mluop_resize_yuv_exec(HANDLE_MLU_OP h, void *src_y, void *src_uv,
+                                 void *dst_y, void *dst_uv);
+int mlumpp_mluop_resize_yuv_destroy(HANDLE_MLU_OP h);
+int mlumpp_mluop_unload(HANDLE_MLU_OP h);
+
+#endif /* AVCODEC_MLUMPP_MLUOP_H */
diff --git a/libavcodec/mlumpp_vid_enc.c b/libavcodec/mlumpp_vid_enc.c
new file mode 100755
index 0000000..dae846e
--- /dev/null
+++ b/libavcodec/mlumpp_vid_enc.c
@@ -0,0 +1,1321 @@
+/******************************************************************************
+ * Cambricon MLU Media Process Platform(MLU MPP) SDK
+ * Copyright (C) [2019] by Cambricon, Inc. All rights reserved
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *******************************************************************************/
+#include <unistd.h>
+#include <stdint.h>
+
+#include <fcntl.h>
+#include <time.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include "libavutil/common.h"
+#include "libavutil/opt.h"
+#include "libavutil/time.h"
+#include "libavutil/log.h"
+#include "internal.h"
+#include"mlumpp_vid_enc.h"
+
+#define CNRT_ERROR_CHECK(avctx, ret)                                                       \
+    if (ret != CNRT_RET_SUCCESS) {                                                         \
+        av_log(avctx,AV_LOG_ERROR,"error occur, func: %s, line: %d\n", __func__, __LINE__);\
+        return -1;                                                                         \
+    }
+#define CNCODEC_ERROR_CHECK(avctx, ret)                                                     \
+    if (ret != CNCODEC_SUCCESS) {                                                           \
+        av_log(avctx,AV_LOG_ERROR,"error occur, func: %s, line: %d\n", __func__, __LINE__); \
+        return -1;                                                                          \
+    }
+#define OUTPUT_BUFFER_SIZE_FOR_ENCODE (1024 * 4096) //must be 4k align
+typedef struct MLUVideoFrameInfo {
+    cnvideoEncOutput info;
+    unsigned char* buf;
+} MLUVideoFrameInfo_t;
+static void _ff_debug_bytes(AVCodecContext *avctx, uint8_t *buf, int len)
+{
+    int i;
+    av_log(avctx,AV_LOG_INFO, "print bytes ...  \n");
+    for (i = 0; i < len; i++) {
+        printf("%02X ", buf[i]);
+        if ((i+1) % 16 == 0) { printf ("\n"); }
+    }
+    printf("\n");
+    av_log(avctx,AV_LOG_INFO, "print bytes done \n");
+}
+static inline int mlumpp_adapt_resolution(AVCodecContext* avctx) {
+    if (avctx->width < 64 ||  avctx->width > 4096 || avctx->height < 64 || avctx->height > 4096) {
+        av_log(avctx, AV_LOG_ERROR, "Unsupport resoution: %dx%d\n", avctx->width, avctx->height);
+        av_log(avctx, AV_LOG_ERROR, "MLU video encoder only support resolution: 64x64~4096x4096\n");
+        return -1;
+    }
+    return 0;
+}
+static inline int mlumpp_check_stride_align(AVCodecContext* avctx, MLUMPPEncContext_t *cnctx) {
+    int align = cnctx->stride_align;
+    if (align & (align - 1)) {
+        av_log(avctx, AV_LOG_ERROR,
+              "Parames error, stride align must be a power of 2, now is %d\n", cnctx->stride_align);
+        return -1;
+    }
+    int tmp = 0;
+    while (align > 1) {
+        align >>= 1;
+        tmp++;
+    }
+    if (cnctx->trace_flag > 0) {
+        av_log(cnctx->avctx, AV_LOG_INFO, "stride align is the %d power of 2.\n", tmp);
+    }
+    return 0;
+}
+static int mlumpp_enc_set_cnrt_ctx(AVCodecContext *avctx, unsigned int device_id, cnrtChannelType_t channel_id)
+{
+    cnrtDev_t dev;
+    cnrtRet_t ret;
+    ret = cnrtGetDeviceHandle(&dev, device_id);
+    CNRT_ERROR_CHECK(avctx, ret);
+    ret = cnrtSetCurrentDevice(dev);
+    CNRT_ERROR_CHECK(avctx,ret);
+    if (channel_id >= CNRT_CHANNEL_TYPE_0) {
+        ret = cnrtSetCurrentChannel(channel_id);
+        CNRT_ERROR_CHECK(avctx, ret);
+    }
+    return 0;
+}
+static int _process_sps_pps(void *pData, cnvideoEncOutput *pStream)
+{
+    cnrtRet_t cnrt_ret;
+    MLUMPPEncContext_t* cnctx = (MLUMPPEncContext_t*)pData;
+    if (cnctx->trace_flag > 0) {
+        av_log(cnctx->avctx, AV_LOG_INFO, "First frame, will process sps/pps header data \n");
+    }
+    if (cnctx->trace_flag > 1) {
+        av_log(cnctx->avctx, AV_LOG_INFO, "Bitstream info: streamLength:%d, dataOffset:%u\n", pStream->streamLength, pStream->dataOffset);
+    }
+    if (pStream->streamLength > 0 && NULL == cnctx->avctx->extradata) { // check pps/sps
+        cnctx->pkt_sps_pps_len = pStream->streamLength;
+        cnctx->avctx->extradata_size = cnctx->pkt_sps_pps_len;
+        cnctx->avctx->extradata = av_mallocz(cnctx->avctx->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
+        memset(cnctx->avctx->extradata, 0, cnctx->avctx->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
+        if (NULL == (void *)pStream->streamBuffer.addr) {
+            av_log(cnctx->avctx, AV_LOG_ERROR, "encoder output buffer address(MLU) is NULL \n");
+            return -1;
+        }
+        if (NULL == cnctx->avctx->extradata) {
+            av_log(cnctx->avctx, AV_LOG_ERROR, "malloc sps/pps pkt buff(CPU) failed\n");
+            return -1;
+        }
+        ff_mutex_lock(&cnctx->queue_mutex);
+        cnrt_ret = cnrtMemcpy((void *)cnctx->avctx->extradata, (void *)pStream->streamBuffer.addr + pStream->dataOffset,
+                            cnctx->avctx->extradata_size, CNRT_MEM_TRANS_DIR_DEV2HOST);
+        ff_mutex_unlock(&cnctx->queue_mutex);
+        if(cnrt_ret != CNRT_RET_SUCCESS){
+            av_log(cnctx->avctx, AV_LOG_ERROR, "Can't get SPS/PPS, D2H failed, ret(%ld)\n", cnrt_ret);
+            return AVERROR_EXTERNAL;
+        }
+
+        if (cnctx->trace_flag > 0) {
+            av_log(cnctx->avctx, AV_LOG_INFO, "Fill SPS/PPS packet, size: %d\n", cnctx->pkt_sps_pps_len);
+            _ff_debug_bytes(cnctx->avctx, cnctx->avctx->extradata, cnctx->pkt_sps_pps_len);
+        }
+        return 0;
+    } else {
+        return -1;
+    }
+}
+static int _newframe_callback(void *pData, cnvideoEncOutput *pStream)
+{
+    if (pData && pStream) {
+        MLUMPPEncContext_t* cnctx = (MLUMPPEncContext_t*)pData;
+        MLUVideoFrameInfo_t encoded_frame;
+        /*sps/pps generated by the encoder as first newframe
+        *  will be saved and inserted before IDR frame later...
+        */
+        if ((pStream->sliceType == CNCODEC_SLICE_H264_SPS_PPS
+            || pStream->sliceType == CNCODEC_SLICE_HEVC_VPS_SPS_PPS
+            || pStream->sliceType == CNCODEC_SLICE_NALU_VPS
+            || pStream->sliceType == CNCODEC_SLICE_NALU_SPS)) {
+            _process_sps_pps(pData, pStream);
+            if (!cnctx->spspps_post_flag) {
+                sem_post(&(cnctx->spspps_sema));
+                cnctx->spspps_post_flag = 1;
+                if (cnctx->trace_flag > 0) {
+                    av_log(cnctx->avctx, AV_LOG_INFO, "spspps post flag set 1 \n");
+                }
+            }
+            if (cnctx->trace_flag > 0) {
+                av_log(cnctx->avctx, AV_LOG_INFO, "spspps slice type \n");
+            }
+            return 0;
+        }
+
+        memcpy((void *)&encoded_frame.info, pStream, sizeof(MLUVideoFrameInfo_t));
+
+        ff_mutex_lock(&cnctx->queue_mutex);
+        av_fifo_generic_write(cnctx->frame_queue, &encoded_frame, sizeof(MLUVideoFrameInfo_t), NULL);
+        if (cnctx->handle) {
+            cnctx->total_add_ref_num++;
+            cnvideoEncAddReference(cnctx->handle, &encoded_frame.info.streamBuffer);
+        }
+        ff_mutex_unlock(&cnctx->queue_mutex);
+        if (cnctx->trace_flag > 1) {
+            av_log(cnctx->avctx, AV_LOG_INFO, "channel:%d,frame offset:%u,flags:%u,encoded frames counts: %llu,pts:(%" PRId64 "), frame size: %u\n",
+                   cnctx->instance_id, pStream->dataOffset, pStream->flags, cnctx->total_packet_count, pStream->pts, pStream->streamLength);
+        }
+    }
+    return 0;
+}
+static int mlumpp_enc_event_cb(cncodecCbEventType eventType, void *pUserData, void *cbInfo)
+{
+    MLUMPPEncContext_t *cnctx = (MLUMPPEncContext_t *)pUserData;
+
+    if (cnctx->trace_flag > 1) {
+        av_log(cnctx->avctx,AV_LOG_INFO,"Encoder callback event type: %d \n", eventType);
+    }
+    switch (eventType)
+    {
+        case CNCODEC_CB_EVENT_NEW_FRAME:
+            _newframe_callback(pUserData, (cnvideoEncOutput *)cbInfo);
+            break;
+        case CNCODEC_CB_EVENT_EOS:
+            if (!cnctx->eos_post_flag) {
+                sem_post(&(cnctx->eos_sema));
+                cnctx->eos_post_flag = 1;
+            }
+            if (cnctx->trace_flag > 0) {
+                av_log(cnctx->avctx, AV_LOG_WARNING, "[%lu]enc get eos callback \n", (long unsigned)pthread_self());
+            }
+            cnctx->eos_reached = 1;
+            break;
+        case CNCODEC_CB_EVENT_SW_RESET:
+        case CNCODEC_CB_EVENT_HW_RESET:
+            av_log(cnctx->avctx, AV_LOG_FATAL, "Encoder FATAL Error <Firmware crash Event>: %d \n", eventType);
+            if (!cnctx->codec_abort_flag) {
+                sem_post(&cnctx->eos_sema);
+                cnctx->codec_abort_flag = 1;
+            }
+            break;
+        case CNCODEC_CB_EVENT_OUT_OF_MEMORY:
+            av_log(cnctx->avctx, AV_LOG_FATAL, "Encoder FATAL Error <Out of memory Event>: %d \n", eventType);
+            if (!cnctx->codec_abort_flag) {
+                sem_post(&cnctx->eos_sema);
+                cnctx->codec_abort_flag = 1;
+            }
+            break;
+        case CNCODEC_CB_EVENT_ABORT_ERROR:
+            av_log(cnctx->avctx, AV_LOG_FATAL, "Encoder FATAL Error <Abort Event>: %d \n", eventType);
+            if (!cnctx->codec_abort_flag) {
+                sem_post(&cnctx->eos_sema);
+                cnctx->codec_abort_flag = 1;
+            }
+            break;
+        default:
+            av_log(cnctx->avctx, AV_LOG_FATAL, "Encoder FATAL Error <Unknow Event>: %d \n", eventType);
+            if (!cnctx->codec_abort_flag) {
+                sem_post(&cnctx->eos_sema);
+                cnctx->codec_abort_flag = 1;
+            }
+            break;
+    }
+    return 0;
+}
+static inline cnvideoEncInstance mlump_enc_get_vpu_inst(unsigned int id)
+{
+    switch (id) {
+    case 0:
+        return CNVIDEOENC_INSTANCE_AUTO;
+    case 1:
+        return CNVIDEOENC_INSTANCE_0;
+    case 2:
+        return CNVIDEOENC_INSTANCE_1;
+    default:
+        return CNVIDEOENC_INSTANCE_AUTO;
+    }
+}
+static inline unsigned int _cnvid_fifo_item_size(void)
+{
+    return sizeof(MLUVideoFrameInfo_t);
+}
+static inline unsigned int _cnvid_fifo_size(const AVFifoBuffer *fifo)
+{
+    return av_fifo_size(fifo) / _cnvid_fifo_item_size();
+}
+static void _dump_enc_params(AVCodecContext *avctx, cnvideoEncCreateInfo *encode_params)
+{
+    av_log(avctx, AV_LOG_INFO, "************************Encoder attributes dump before************************\n");
+    av_log(avctx, AV_LOG_INFO, "encode_params->instance:%u\n", encode_params->instance);
+    av_log(avctx, AV_LOG_INFO, "encode_params->deviceId:%u\n", encode_params->deviceId);
+    av_log(avctx, AV_LOG_INFO, "encode_params->width:%u\n", encode_params->width);
+    av_log(avctx, AV_LOG_INFO, "encode_params->height:%u\n", encode_params->height);
+    av_log(avctx, AV_LOG_INFO, "encode_params->codec:%u\n", encode_params->codec);
+    av_log(avctx, AV_LOG_INFO, "encode_params->colorSpace:%u\n", encode_params->colorSpace);
+    av_log(avctx, AV_LOG_INFO, "encode_params->pixelFmt:%u\n", encode_params->pixelFmt);
+    av_log(avctx, AV_LOG_INFO, "encode_params->fpsNumerator:%u\n", encode_params->fpsNumerator);
+    av_log(avctx, AV_LOG_INFO, "encode_params->fpsDenominator:%u\n", encode_params->fpsDenominator);
+    av_log(avctx, AV_LOG_INFO, "encode_params->rateCtrl.gopLength:%u\n", encode_params->rateCtrl.gopLength);
+    av_log(avctx, AV_LOG_INFO, "encode_params->rateCtrl.constBQP:%u\n", encode_params->rateCtrl.constBQP);
+    av_log(avctx, AV_LOG_INFO, "encode_params->rateCtrl.constIQP:%u\n", encode_params->rateCtrl.constIQP);
+    av_log(avctx, AV_LOG_INFO, "encode_params->rateCtrl.constPQP:%u\n", encode_params->rateCtrl.constPQP);
+    av_log(avctx, AV_LOG_INFO, "encode_params->rateCtrl.initBQP:%u\n", encode_params->rateCtrl.initBQP);
+    av_log(avctx, AV_LOG_INFO, "encode_params->rateCtrl.initIQP:%u\n", encode_params->rateCtrl.initIQP);
+    av_log(avctx, AV_LOG_INFO, "encode_params->rateCtrl.initPQP:%u\n", encode_params->rateCtrl.initPQP);
+    av_log(avctx, AV_LOG_INFO, "encode_params->rateCtrl.maxBQP:%u\n", encode_params->rateCtrl.maxBQP);
+    av_log(avctx, AV_LOG_INFO, "encode_params->rateCtrl.maxIQP:%u\n", encode_params->rateCtrl.maxIQP);
+    av_log(avctx, AV_LOG_INFO, "encode_params->rateCtrl.maxPQP:%u\n", encode_params->rateCtrl.maxPQP);
+    av_log(avctx, AV_LOG_INFO, "encode_params->rateCtrl.minBQP:%u\n", encode_params->rateCtrl.minBQP);
+    av_log(avctx, AV_LOG_INFO, "encode_params->rateCtrl.minIQP:%u\n", encode_params->rateCtrl.minIQP);
+    av_log(avctx, AV_LOG_INFO, "encode_params->rateCtrl.minPQP:%u\n", encode_params->rateCtrl.minPQP);
+    av_log(avctx, AV_LOG_INFO, "encode_params->rateCtrl.peakBitrate:%u\n", encode_params->rateCtrl.peakBitrate);
+    av_log(avctx, AV_LOG_INFO, "encode_params->rateCtrl.rcMode:%u\n", encode_params->rateCtrl.rcMode);
+    av_log(avctx, AV_LOG_INFO, "encode_params->rateCtrl.targetBitrate:%u\n", encode_params->rateCtrl.targetBitrate);
+    av_log(avctx, AV_LOG_INFO, "encode_params->rateCtrl.virtualBufferSize:%u\n", encode_params->rateCtrl.virtualBufferSize);
+    av_log(avctx, AV_LOG_INFO, "encode_params->rateCtrl.enableQPRange:%u\n", encode_params->rateCtrl.enableQPRange);
+    if (encode_params->codec == CNCODEC_H264) {
+        av_log(avctx, AV_LOG_INFO, "encode_params->uCfg.h264.bitDepth:%u\n", encode_params->uCfg.h264.bitDepth);
+        av_log(avctx, AV_LOG_INFO, "encode_params->uCfg.h264.BFramesNum:%u\n", encode_params->uCfg.h264.BFramesNum);
+        av_log(avctx, AV_LOG_INFO, "encode_params->uCfg.h264.maxRefFramesNum:%u\n", encode_params->uCfg.h264.maxRefFramesNum);
+        av_log(avctx, AV_LOG_INFO, "encode_params->uCfg.h264.profile:%u\n", encode_params->uCfg.h264.profile);
+        av_log(avctx, AV_LOG_INFO, "encode_params->uCfg.h264.level:%u\n", encode_params->uCfg.h264.level);
+        av_log(avctx, AV_LOG_INFO, "encode_params->uCfg.h264.entropyMode:%u\n", encode_params->uCfg.h264.entropyMode);
+    }else if (encode_params->codec == CNCODEC_HEVC) {
+        av_log(avctx, AV_LOG_INFO, "encode_params->uCfg.h265.bitDepth:%u\n", encode_params->uCfg.h265.bitDepth);
+        av_log(avctx, AV_LOG_INFO, "encode_params->uCfg.h265.BFramesNum:%u\n", encode_params->uCfg.h265.BFramesNum);
+        av_log(avctx, AV_LOG_INFO, "encode_params->uCfg.h265.maxRefFramesNum:%u\n", encode_params->uCfg.h265.maxRefFramesNum);
+        av_log(avctx, AV_LOG_INFO, "encode_params->uCfg.h265.profile:%u\n", encode_params->uCfg.h265.profile);
+        av_log(avctx, AV_LOG_INFO, "encode_params->uCfg.h265.level:%u\n", encode_params->uCfg.h265.level);
+    }
+    av_log(avctx, AV_LOG_INFO, "encode_params->allocType:(%s)\n", encode_params->allocType == CNCODEC_BUF_ALLOC_APP ? "app" : "mlu");
+    av_log(avctx, AV_LOG_INFO, "encode_params->suggestedLibAllocBitStrmBufSize:%u K\n", encode_params->suggestedLibAllocBitStrmBufSize / 1024);
+    av_log(avctx, AV_LOG_INFO, "thread id: %lu\n", (long unsigned)pthread_self());
+    av_log(avctx, AV_LOG_INFO, "************************Encoder attributes dump after*************************\n");
+}
+
+static int get_sps_pps_header (MLUMPPEncContext_t *cnctx) {
+    int ret = -1;
+    int timeout = 3000;
+    cnvideoEncInput input_probe;
+    // for H264/H265, fill extradata
+    cnctx->insert_spspps_to_extradata = 1;
+    if (cnctx->trace_flag > 0) {
+        av_log(cnctx->avctx, AV_LOG_INFO, "enc init func get sps/pps ... \n");
+    }
+    memset(&input_probe, 0, sizeof(cnvideoEncInput));
+    if (cnctx->trace_flag > 0) {
+        av_log(cnctx->avctx, AV_LOG_INFO, "enc init func wait avail input buf to send data, get sps/pps ... \n");
+    }
+    if (cnctx->handle) {
+        ret = cnvideoEncWaitAvailInputBuf(cnctx->handle, &input_probe.frame, timeout);
+    }
+    if (cnctx->trace_flag > 0) {
+        av_log(cnctx->avctx, AV_LOG_INFO, "enc init func wait avail input buf to send data done, get sps/pps, ret(%d)\n", ret);
+    }
+    CNCODEC_ERROR_CHECK(cnctx->avctx, ret);
+    if (cnctx->trace_flag > 0) {
+        av_log(cnctx->avctx, AV_LOG_INFO, "enc init func feed data, get sps/pps ... \n");
+    }
+    if (cnctx->handle) {
+        ret = cnvideoEncFeedFrame(cnctx->handle, &input_probe, timeout);
+    }
+    if (cnctx->trace_flag > 0) {
+        av_log(cnctx->avctx, AV_LOG_INFO, "enc init func feed data done , get sps/pps, ret(%d) \n", ret);
+    }
+    CNCODEC_ERROR_CHECK(cnctx->avctx, ret);
+    if (cnctx->trace_flag > 0) {
+        av_log(cnctx->avctx, AV_LOG_INFO, "cnencoder spspps sema wait ..., for sps/pps \n");
+    }
+
+    struct timespec ts;
+    clock_gettime(CLOCK_REALTIME, &ts);
+    ts.tv_sec += 8; // 8s
+    ret = sem_timedwait(&(cnctx->spspps_sema), &ts);
+    if (ret != 0) {
+        int semvalue = -1;
+        sem_getvalue(&cnctx->spspps_sema, &semvalue);
+        av_log(cnctx->avctx, AV_LOG_ERROR, "enc sem_timewait error \n");
+        av_log(cnctx->avctx, AV_LOG_ERROR, "enc sem_timewait = -1, semvalue = %d ... \n", semvalue);
+    }
+    // sem_wait(&(cnctx->spspps_sema));
+    if (cnctx->trace_flag > 0) {
+        av_log(cnctx->avctx, AV_LOG_INFO, "cnencoder spspps sema wait done, for sps/pps \n");
+    }
+    sem_destroy(&(cnctx->spspps_sema));
+    if (cnctx->trace_flag > 0) {
+        av_log(cnctx->avctx, AV_LOG_INFO, "enc init func get sps/pps done \n");
+    }
+    return ret;
+}
+
+static void empty_fifo_queue(AVCodecContext *avctx, MLUMPPEncContext_t *cnctx);
+int ff_mlumpp_vid_enc_init(AVCodecContext *avctx, MLUMPPEncContext_t *cnctx)
+{
+    int ret = -1;
+    cnrtRet_t cnrt_ret;
+    unsigned int dev_num = 0;
+    cnvideoEncVUISar vui_sar;
+    cnvideoEncCreateInfo enc_params;
+    int bitstream_buf_size = 0;
+    int mluop_in_y_size = 0;
+    int mluop_in_uv_size = 0;
+
+    static const char * const mluop_libname = "/usr/local/neuware/lib64/libeasyOP.so";
+    if (NULL == avctx || NULL == cnctx || 1 == cnctx->encoder_init_flag) { //Sanity checks... these are all serious usage bugs.
+        av_log(avctx, AV_LOG_ERROR, "Early error in \"ff_mlumpp_vid_enc_init\" \n");
+        return -1;
+    }
+    if (cnctx->trace_flag > 0) {
+        av_log(avctx, AV_LOG_INFO, "cnencoder init ... \n");
+    }
+    ret = mlumpp_check_stride_align(avctx, cnctx);
+    if (ret != 0) {
+        return AVERROR(EINVAL);
+    }
+    /***************************Set device start*****************************/
+    if (cnctx->cnrt_init_flag) {
+        cnrt_ret = cnrtInit(0);
+        CNRT_ERROR_CHECK(avctx, cnrt_ret);
+    }
+    cnrt_ret = cnrtGetDeviceCount(&dev_num);
+    if (cnrt_ret != CNRT_RET_SUCCESS && dev_num == 0) {
+        av_log(avctx, AV_LOG_INFO, "Can't find MLU card,device count return 0 \n");
+        return -1;
+    }
+    mlumpp_enc_set_cnrt_ctx(avctx, cnctx->device_id, CNRT_CHANNEL_TYPE_NONE);
+    /********************************Set device end**************************/
+    cnctx->resize.height = 0;
+    cnctx->resize.width = 0;
+    cnctx->resize.in_y_ptr = NULL;
+    cnctx->resize.in_uv_ptr = NULL;
+    cnctx->resize.out_y_ptr = NULL;
+    cnctx->resize.out_uv_ptr = NULL;
+    if (cnctx->resize_str && sscanf(cnctx->resize_str, "%dx%d",
+                                   &cnctx->resize.width, &cnctx->resize.height) != 2) {
+        av_log(avctx, AV_LOG_ERROR, "Invalid resize string\n");
+        ret = AVERROR(EINVAL);
+        return ret;
+    }
+    ret = mlumpp_mluop_load(&cnctx->mluop_handle, mluop_libname, avctx);
+    if (ret < 0) {
+        mlumpp_mluop_unload(cnctx->mluop_handle);
+        cnctx->mluop_handle = NULL;
+        av_log(avctx, AV_LOG_WARNING, "load mluop failed \n");
+    }
+    if (cnctx->resize_str && cnctx->mluop_handle &&cnctx->resize.width > 0 && cnctx->resize.height > 0) {
+        mlumpp_mluop_resize_yuv_init(cnctx->mluop_handle, avctx->width, avctx->height,
+                            cnctx->resize.width, cnctx->resize.height, cnctx->device_id);
+        mluop_in_y_size = avctx->width * avctx->height;
+        mluop_in_uv_size = avctx->width * avctx->height / 2;
+        cnrt_ret = cnrtMalloc((void **)(&cnctx->resize.in_y_ptr), sizeof(char) * mluop_in_y_size);
+        CNRT_ERROR_CHECK(avctx, cnrt_ret);
+        cnrt_ret = cnrtMalloc((void **)(&cnctx->resize.in_uv_ptr), sizeof(char) * mluop_in_uv_size);
+        CNRT_ERROR_CHECK(avctx, cnrt_ret);
+    }
+    cnctx->width = cnctx->resize.width ? cnctx->resize.width : avctx->width;
+    cnctx->height = cnctx->resize.height ? cnctx->resize.height : avctx->height;
+    avctx->coded_width = FFALIGN(avctx->width, cnctx->stride_align);
+    avctx->coded_height = avctx->height;
+    cnctx->coded_width = avctx->coded_width;
+    cnctx->coded_height = avctx->height;
+    if(0 != mlumpp_adapt_resolution(avctx)) {
+        return AVERROR(EINVAL);
+    }
+
+    cnctx->insert_spspps_idr = (avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER) ? 0 : 1;
+    // bitstream_buf_size = cnctx->width * cnctx->height;
+    bitstream_buf_size = cnctx->coded_width * cnctx->height;
+    switch (avctx->pix_fmt) {
+    case AV_PIX_FMT_NV12:
+        cnctx->pixelFmt = CNCODEC_PIX_FMT_NV12;
+        bitstream_buf_size += (bitstream_buf_size >> 1);
+        break;
+    case AV_PIX_FMT_NV21:
+        cnctx->pixelFmt = CNCODEC_PIX_FMT_NV21;
+        bitstream_buf_size += (bitstream_buf_size >> 1);
+        break;
+    case AV_PIX_FMT_YUV420P:
+        cnctx->pixelFmt = CNCODEC_PIX_FMT_I420; // not sure.
+        bitstream_buf_size += (bitstream_buf_size >> 1);
+        break;
+    case AV_PIX_FMT_P010:
+        cnctx->pixelFmt = CNCODEC_PIX_FMT_P010;
+        bitstream_buf_size += (bitstream_buf_size << 1);
+        break;
+    case AV_PIX_FMT_YUYV422:
+        cnctx->pixelFmt = CNCODEC_PIX_FMT_YUYV;
+        bitstream_buf_size = (bitstream_buf_size << 1);
+        break;
+    case AV_PIX_FMT_UYVY422:
+        cnctx->pixelFmt = CNCODEC_PIX_FMT_UYVY;
+        bitstream_buf_size = (bitstream_buf_size << 1);
+        break;
+    case AV_PIX_FMT_ARGB:
+        cnctx->pixelFmt = CNCODEC_PIX_FMT_ARGB;
+        bitstream_buf_size = (bitstream_buf_size << 2);
+        break;
+    case AV_PIX_FMT_BGRA:
+        cnctx->pixelFmt = CNCODEC_PIX_FMT_BGRA;
+        bitstream_buf_size = (bitstream_buf_size << 2);
+        break;
+    case AV_PIX_FMT_RGBA:
+        cnctx->pixelFmt = CNCODEC_PIX_FMT_RGBA;
+        bitstream_buf_size = (bitstream_buf_size << 2);
+        break;
+    default:
+        cnctx->pixelFmt = CNCODEC_PIX_FMT_NV12;
+        bitstream_buf_size += (bitstream_buf_size >> 1);
+        break;
+    }
+    switch (avctx->codec_id) {
+    case AV_CODEC_ID_H264:
+        cnctx->codec_type = CNCODEC_H264;
+        break;
+    case AV_CODEC_ID_HEVC:
+        cnctx->codec_type = CNCODEC_HEVC;
+        break;
+    default:
+        cnctx->codec_type = CNCODEC_H264;
+        break;
+    }
+    switch (avctx->colorspace) {
+    case AVCOL_SPC_BT709:
+        cnctx->color_space = CNCODEC_COLOR_SPACE_BT_709;
+        break;
+    case AVCOL_SPC_BT2020_CL:
+        cnctx->color_space = CNCODEC_COLOR_SPACE_BT_2020;
+        break;
+    default:
+        cnctx->color_space = CNCODEC_COLOR_SPACE_BT_2020;
+        break;
+    }
+    cnctx->bitrate = avctx->bit_rate; // average bitrate
+    cnctx->gop_size = avctx->gop_size;
+    cnctx->max_b_frames = avctx->max_b_frames;
+    cnctx->encoder_flushing = 0;
+    cnctx->eos_reached = 0;
+    cnctx->total_frame_count = 0;
+    cnctx->total_packet_count = 0;
+    cnctx->total_outframe_count = 0;
+    cnctx->eos_post_flag = 0;
+    cnctx->spspps_post_flag = 0;
+    cnctx->last_send_frame_time = 0;
+    cnctx->codec_abort_flag = 0;
+    memset(&enc_params, 0, sizeof(enc_params));
+    enc_params.width = cnctx->width;
+    enc_params.height = cnctx->height;
+    enc_params.codec = cnctx->codec_type;
+    if (avctx->framerate.den > 0 && avctx->framerate.num > 0) {
+        enc_params.fpsNumerator = avctx->framerate.num;
+        enc_params.fpsDenominator = avctx->framerate.den;
+    } else { // just guess
+        enc_params.fpsNumerator = avctx->time_base.den;
+        enc_params.fpsDenominator = avctx->time_base.num * avctx->ticks_per_frame;
+        av_log(avctx, AV_LOG_WARNING, "Can't get valid framerate[%d]&framerateDen[%d],use default:[%d][%d]\n",
+               avctx->framerate.num, avctx->framerate.den, enc_params.fpsNumerator, enc_params.fpsDenominator);
+    }
+    cnctx->fps_num = enc_params.fpsNumerator;
+    cnctx->fps_den = enc_params.fpsDenominator;
+    // enc_params.allocType = CNCODEC_BUF_ALLOC_LIB;
+    enc_params.allocType = CNCODEC_BUF_ALLOC_LIB_USER_SPECIFY_BUF_ALIGNMENT;
+    enc_params.pixelFmt = cnctx->pixelFmt;
+    enc_params.inputBufNum = cnctx->input_buf_num;
+    enc_params.outputBufNum = cnctx->output_buf_num;
+    if ( FFALIGN(bitstream_buf_size, 4096) < OUTPUT_BUFFER_SIZE_FOR_ENCODE) {
+        enc_params.suggestedLibAllocBitStrmBufSize = FFALIGN(bitstream_buf_size, 4096);
+    } else {
+        enc_params.suggestedLibAllocBitStrmBufSize = OUTPUT_BUFFER_SIZE_FOR_ENCODE;
+    }
+    enc_params.deviceId = cnctx->device_id;
+    enc_params.instance = mlump_enc_get_vpu_inst(cnctx->instance_id);
+    enc_params.rateCtrl.targetBitrate = cnctx->bitrate;
+    if (avctx->rc_max_rate > 0) {
+        enc_params.rateCtrl.peakBitrate = avctx->rc_max_rate; //invalid
+    }
+    enc_params.colorSpace = cnctx->color_space;
+    if (cnctx->rcmode == 0) { // VBR
+        if (avctx->qmin >= 0 && avctx->qmax >= 0) {
+            enc_params.rateCtrl.maxIQP = avctx->qmax;
+            enc_params.rateCtrl.maxPQP = avctx->qmax;
+            enc_params.rateCtrl.maxBQP = avctx->qmax;
+            enc_params.rateCtrl.minIQP = avctx->qmin;
+            enc_params.rateCtrl.minPQP = avctx->qmin;
+            enc_params.rateCtrl.minBQP = avctx->qmin;
+        } else {
+            if (cnctx->vbr_maxqp > 0) {
+                enc_params.rateCtrl.maxIQP = cnctx->vbr_maxqp;
+                enc_params.rateCtrl.maxPQP = cnctx->vbr_maxqp;
+                enc_params.rateCtrl.maxBQP = cnctx->vbr_maxqp;
+            }
+            if (cnctx->vbr_minqp > 0) {
+                enc_params.rateCtrl.minIQP = cnctx->vbr_minqp;
+                enc_params.rateCtrl.minPQP = cnctx->vbr_minqp;
+                enc_params.rateCtrl.minBQP = cnctx->vbr_minqp;
+            }
+        }
+        enc_params.rateCtrl.rcMode = CNVIDEOENC_RATE_CTRL_VBR;
+    } else if (cnctx->rcmode == 1) { // CBR
+        enc_params.rateCtrl.maxIQP = avctx->qmax;
+        enc_params.rateCtrl.maxPQP = avctx->qmax;
+        enc_params.rateCtrl.maxBQP = avctx->qmax;
+        enc_params.rateCtrl.minIQP = avctx->qmin;
+        enc_params.rateCtrl.minPQP = avctx->qmin;
+        enc_params.rateCtrl.minBQP = avctx->qmin;
+        enc_params.rateCtrl.rcMode = CNVIDEOENC_RATE_CTRL_CBR;
+    } else if (cnctx->rcmode == 2) { // CQP(cn1.5.0+)
+        if (cnctx->init_qp_i > 0) {
+            enc_params.rateCtrl.constIQP = cnctx->init_qp_i;
+            enc_params.rateCtrl.constPQP = cnctx->init_qp_p;
+            enc_params.rateCtrl.constBQP = cnctx->init_qp_b;
+            avctx->qmin = -1;
+            avctx->qmax = -1;
+        } else if (cnctx->cqp > 0) {
+            enc_params.rateCtrl.constIQP = cnctx->cqp;
+            enc_params.rateCtrl.constPQP = cnctx->cqp;
+            enc_params.rateCtrl.constBQP = cnctx->cqp;
+            avctx->qmin = -1;
+            avctx->qmax = -1;
+        } else {// default cqp value
+            enc_params.rateCtrl.constIQP = (cnctx->codec_type == CNCODEC_H264) ? 27 : 26;
+            enc_params.rateCtrl.constPQP = (cnctx->codec_type == CNCODEC_H264) ? 27 : 26;
+            enc_params.rateCtrl.constBQP = (cnctx->codec_type == CNCODEC_H264) ? 27 : 26;
+            avctx->qmin = -1;
+            avctx->qmax = -1;
+        }
+        enc_params.rateCtrl.rcMode = CNVIDEOENC_RATE_CTRL_CQP;
+    }
+    enc_params.rateCtrl.gopLength = cnctx->gop_size;
+    switch (enc_params.codec) {
+    case CNCODEC_H264:
+        enc_params.uCfg.h264.profile = cnctx->profile;
+        enc_params.uCfg.h264.level = cnctx->level;
+        if (cnctx->max_b_frames > 0) {
+            enc_params.uCfg.h264.BFramesNum = cnctx->max_b_frames;
+        }
+        enc_params.uCfg.h264.gopType = CNVIDEOENC_GOP_TYPE_LOW_DELAY;
+        if (avctx->refs > 0) {
+            enc_params.uCfg.h264.maxRefFramesNum = avctx->refs;
+        }
+        // enc_params.uCfg.h264.insertSpsPpsWhenIDR = cnctx->insert_spspps_idr;
+        if (cnctx->pixelFmt == CNCODEC_PIX_FMT_P010) { // 10bit
+            enc_params.uCfg.h264.bitDepth = 2;
+        }
+#if FF_API_CODER_TYPE
+FF_DISABLE_DEPRECATION_WARNINGS
+        if (avctx->coder_type >= 0)
+            enc_params.uCfg.h264.entropyMode = avctx->coder_type == FF_CODER_TYPE_VLC ? CNVIDEOENC_ENTROPY_MODE_CAVLC : CNVIDEOENC_ENTROPY_MODE_CABAC;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+        if (cnctx->coder >=0) {
+            enc_params.uCfg.h264.entropyMode = cnctx->coder;
+        }
+        break;
+    case CNCODEC_HEVC:
+        enc_params.uCfg.h265.profile = cnctx->profile;
+        enc_params.uCfg.h265.level = cnctx->level;
+        if (cnctx->max_b_frames > 0) {
+            enc_params.uCfg.h265.BFramesNum = cnctx->max_b_frames;
+        }
+        enc_params.uCfg.h265.gopType = CNVIDEOENC_GOP_TYPE_LOW_DELAY;
+        if (avctx->refs > 0) {
+            enc_params.uCfg.h265.maxRefFramesNum = avctx->refs;
+        }
+        // enc_params.uCfg.h265.insertSpsPpsWhenIDR = cnctx->insert_spspps_idr;
+        if (cnctx->pixelFmt == CNCODEC_PIX_FMT_P010) { // 10bit
+            enc_params.uCfg.h265.bitDepth = 2;
+        }
+        break;
+    default:
+        av_log(avctx, AV_LOG_ERROR, "Can't support this type: %d\n", enc_params.codec);
+        break;
+    }
+    if (cnctx->trace_flag > 1) {
+        _dump_enc_params(avctx, &enc_params);
+    }
+    enc_params.extCfg.bufCfg.frameBufAlignment = cnctx->stride_align;
+    enc_params.userContext = (void *)cnctx;
+    sem_init(&(cnctx->eos_sema), 0, 0);
+    sem_init(&(cnctx->spspps_sema), 0, 0);
+    cnctx->async_queue_depth = cnctx->output_buf_num * 2;
+    cnctx->frame_queue = av_fifo_alloc(cnctx->async_queue_depth * _cnvid_fifo_item_size());
+    if (!cnctx->frame_queue) {
+        sem_post(&(cnctx->eos_sema));
+        av_log(avctx, AV_LOG_FATAL, "Failed to alloc memory for async fifo\n");
+        return -1;
+    }
+    ff_mutex_init(&cnctx->queue_mutex, NULL);
+    cnctx->insert_spspps_to_extradata = 0;
+    cnctx->pkt_sps_pps = NULL;
+    cnctx->is_spspps_packet_flag = 0;
+    cnctx->avctx = avctx;
+
+    cnctx->vuisar.sar_h = 0;
+    cnctx->vuisar.sar_w = 0;
+    if (cnctx->vui_sar_str && sscanf(cnctx->vui_sar_str, "%d:%d",
+                                   &cnctx->vuisar.sar_w, &cnctx->vuisar.sar_h) != 2) {
+        av_log(avctx, AV_LOG_ERROR, "Invalid vui sar string\n");
+        ret = AVERROR(EINVAL);
+        return ret;
+    }
+
+    if (cnctx->pkt_sps_pps) {
+        free(cnctx->pkt_sps_pps);
+        cnctx->pkt_sps_pps = NULL;
+    }
+    cnctx->encoder_flushing = 0;
+    cnctx->eos_reached = 0;
+    cnctx->total_add_ref_num = 0;
+    cnctx->total_frame_count = 0;
+    cnctx->total_packet_count = 0;
+    cnctx->total_outframe_count = 0;
+    if (cnctx->trace_flag > 0) {
+        av_log(avctx, AV_LOG_INFO, "enc init func create enc ... \n");
+    }
+    ret = cnvideoEncCreate(&cnctx->handle, mlumpp_enc_event_cb, &enc_params);
+    if (cnctx->trace_flag > 0) {
+        av_log(avctx, AV_LOG_INFO, "enc init func create enc done, ret(%d) \n", ret);
+    }
+    if (ret != CNCODEC_SUCCESS) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to create encoder \n");
+        cnctx->handle = NULL;
+        sem_post(&(cnctx->eos_sema));
+        return AVERROR_EXTERNAL;
+    }
+
+    memset(&vui_sar, 0, sizeof(vui_sar));
+    if (cnctx->vuisar.sar_w > 0 || cnctx->vuisar.sar_h > 0) {
+        vui_sar.sarWidth = cnctx->vuisar.sar_w;
+        vui_sar.sarHeight = cnctx->vuisar.sar_h;
+    } else {
+        vui_sar.sarWidth = avctx->sample_aspect_ratio.num;
+        vui_sar.sarHeight = avctx->sample_aspect_ratio.den;
+    }
+
+    cnvideoEncSetAttributes(cnctx->handle, CNVIDEO_ENC_ATTR_VUI_SAR, &vui_sar);
+    if (cnctx->trace_flag > 0) {
+        av_log(avctx, AV_LOG_INFO, "dst w: %d, h: %d \n", avctx->width, avctx->height);
+        av_log(avctx, AV_LOG_INFO, "vui_sar.sarWidth: %d, vui_sar.sarHeight: %d \n",
+                     vui_sar.sarWidth,  vui_sar.sarHeight);
+    }
+
+    // feed data, get spspps data
+    if (avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER) {
+        av_log(avctx, AV_LOG_INFO, "get sps/pps header in init func ... \n");
+        ret = get_sps_pps_header(cnctx);
+        if (ret < 0) {
+            av_log(avctx, AV_LOG_ERROR, "get header info in init func failed \n");
+        }
+        av_log(avctx, AV_LOG_INFO, "get header info in init func done \n");
+    }
+
+    cnctx->encoder_init_flag = 1;
+    if (cnctx->trace_flag > 0) {
+        av_log(avctx, AV_LOG_INFO, "cnencoder init done, handle: %lu \n", cnctx->handle);
+    }
+    return 0;
+}
+
+static int _cnvid_enc_build_std_buffer(MLUMPPEncContext_t *cnctx, cncodecFrame *tempInput, const AVFrame *frame)
+{
+    int ret = -1;
+    cnrtRet_t cnrt_ret;
+    void *mluop_in_y_ptr = NULL;
+    void *mluop_in_uv_ptr = NULL;
+    void *mluop_out_y_ptr = NULL;
+    void *mluop_out_uv_ptr = NULL;
+    int time_out_ = (1000 / 25) * cnctx->input_buf_num * 50;
+
+    ret = cnvideoEncWaitAvailInputBuf(cnctx->handle, tempInput, time_out_);
+    if (ret >= 0) {
+        // mluop nv12/nv21
+        if (cnctx->resize_str && cnctx->mluop_handle &&cnctx->resize.width > 0 && cnctx->resize.height > 0) {
+            int in_one_plane_size = frame->width * frame->height;
+            switch (cnctx->pixelFmt) {
+            case CNCODEC_PIX_FMT_NV12:
+            case CNCODEC_PIX_FMT_NV21:
+                if (NULL == (void *)tempInput->plane[0].addr || NULL == (void *)tempInput->plane[1].addr) {
+                    av_log(cnctx->avctx, AV_LOG_ERROR, "Encoder input buffer address(MLU) is NULL \n");
+                    return -1;
+                }
+                if (NULL == frame->data[0] || NULL == frame->data[1]) {
+                    av_log(cnctx->avctx, AV_LOG_ERROR, "Encoder input data address(CPU) is NULL \n");
+                    return -1;
+                }
+                cnrt_ret = cnrtMemcpy((void *)(cnctx->resize.in_y_ptr), (void *)frame->data[0], in_one_plane_size,
+                        CNRT_MEM_TRANS_DIR_HOST2DEV);
+                // CNRT_ERROR_CHECK(cnctx->avctx, cnrt_ret);
+                if (cnrt_ret != CNRT_RET_SUCCESS) {
+                    av_log(cnctx->avctx, AV_LOG_WARNING,"enc: h2d y warning, ret(%ld), func: %s, line: %d\n",
+                           cnrt_ret, __func__, __LINE__);
+                    return AVERROR_EXTERNAL;
+                }
+                cnrt_ret = cnrtMemcpy((void *)(cnctx->resize.in_uv_ptr), (void *)frame->data[1],
+                                    in_one_plane_size / 2, CNRT_MEM_TRANS_DIR_HOST2DEV);
+                // CNRT_ERROR_CHECK(cnctx->avctx, cnrt_ret);
+                if (cnrt_ret != CNRT_RET_SUCCESS) {
+                    av_log(cnctx->avctx, AV_LOG_WARNING,"enc: h2d uv warning, ret(%ld), func: %s, line: %d\n",
+                           cnrt_ret, __func__, __LINE__);
+                    return AVERROR_EXTERNAL;
+                }
+                break;
+            default:
+                av_log(cnctx->avctx, AV_LOG_ERROR, "not supported format:%d\n", ret);
+                break;
+            }
+            mluop_in_y_ptr = (uint8_t *)(cnctx->resize.in_y_ptr);
+            mluop_in_uv_ptr = (uint8_t *)(cnctx->resize.in_uv_ptr);
+            mluop_out_y_ptr = (void *)tempInput->plane[0].addr;
+            mluop_out_uv_ptr = (void *)tempInput->plane[1].addr;
+            ret = mlumpp_mluop_resize_yuv_exec(cnctx->mluop_handle, mluop_in_y_ptr, mluop_in_uv_ptr,
+                            mluop_out_y_ptr, mluop_out_uv_ptr);
+            if (ret < 0) {
+                av_log(cnctx->avctx, AV_LOG_ERROR, "Failed to exec resize with mluop\n");
+                return -1;
+            }
+        }
+        else // don't use mluop
+        {
+            //mlumpp_enc_set_cnrt_ctx(cnctx->handle,cnctx->device_id,CNRT_CHANNEL_TYPE_NONE);
+            switch (cnctx->pixelFmt) {
+            case CNCODEC_PIX_FMT_YUYV:
+            case CNCODEC_PIX_FMT_UYVY:
+            case CNCODEC_PIX_FMT_ARGB:
+            case CNCODEC_PIX_FMT_BGRA:
+            case CNCODEC_PIX_FMT_RGBA:
+                if (NULL == (void *)tempInput->plane[0].addr) {
+                    av_log(cnctx->avctx, AV_LOG_ERROR, "Encoder input buffer address(MLU) is NULL \n");
+                    return -1;
+                }
+                if (NULL == frame->data[0]) {
+                    av_log(cnctx->avctx, AV_LOG_ERROR, "Encoder input data address(CPU) is NULL \n");
+                    return -1;
+                }
+                cnrt_ret = cnrtMemcpy((void *)tempInput->plane[0].addr, (void *)frame->data[0],
+                                    cnctx->coded_width * cnctx->height, CNRT_MEM_TRANS_DIR_HOST2DEV);
+                // CNRT_ERROR_CHECK(cnctx->avctx, cnrt_ret);
+                if (cnrt_ret != CNRT_RET_SUCCESS) {
+                    av_log(cnctx->avctx, AV_LOG_WARNING,"enc: h2d warning, ret(%ld), func: %s, line: %d\n",
+                           cnrt_ret, __func__, __LINE__);
+                    return AVERROR_EXTERNAL;
+                }
+                break;
+            case CNCODEC_PIX_FMT_NV12:
+            case CNCODEC_PIX_FMT_NV21:
+                if (NULL == (void *)tempInput->plane[0].addr || NULL == (void *)tempInput->plane[1].addr) {
+                    av_log(cnctx->avctx, AV_LOG_ERROR, "Encoder input buffer address(MLU) is NULL \n");
+                    return -1;
+                }
+                if (NULL == frame->data[0] || NULL == frame->data[1]) {
+                    av_log(cnctx->avctx, AV_LOG_ERROR, "Encoder input data address(CPU) is NULL \n");
+                    return -1;
+                }
+                cnrt_ret = cnrtMemcpy((void *)tempInput->plane[0].addr, (void *)frame->data[0],
+                                    cnctx->coded_width * cnctx->height, CNRT_MEM_TRANS_DIR_HOST2DEV);
+                // CNRT_ERROR_CHECK(cnctx->avctx, cnrt_ret);
+                if (cnrt_ret != CNRT_RET_SUCCESS) {
+                    av_log(cnctx->avctx, AV_LOG_WARNING,"enc: h2d warning, ret(%ld), func: %s, line: %d\n",
+                           cnrt_ret, __func__, __LINE__);
+                    return AVERROR_EXTERNAL;
+                }
+                cnrt_ret = cnrtMemcpy((void *)tempInput->plane[1].addr, (void *)frame->data[1],
+                                    cnctx->coded_width * cnctx->height / 2, CNRT_MEM_TRANS_DIR_HOST2DEV);
+                // CNRT_ERROR_CHECK(cnctx->avctx, cnrt_ret);
+                if (cnrt_ret != CNRT_RET_SUCCESS) {
+                    av_log(cnctx->avctx, AV_LOG_WARNING,"enc: h2d warning, ret(%ld), func: %s, line: %d\n",
+                           cnrt_ret, __func__, __LINE__);
+                    return AVERROR_EXTERNAL;
+                }
+                break;
+            case CNCODEC_PIX_FMT_P010:
+                if (NULL == (void *)tempInput->plane[0].addr || NULL == (void *)tempInput->plane[1].addr) {
+                    av_log(cnctx->avctx, AV_LOG_ERROR, "Encoder input buffer address(MLU) is NULL \n");
+                    return -1;
+                }
+                if (NULL == frame->data[0] || NULL == frame->data[1]) {
+                    av_log(cnctx->avctx, AV_LOG_ERROR, "Encoder input data address(CPU) is NULL \n");
+                    return -1;
+                }
+                cnrt_ret = cnrtMemcpy((void *)tempInput->plane[0].addr, (void *)frame->data[0],
+                                    cnctx->coded_width * 2 * cnctx->height, CNRT_MEM_TRANS_DIR_HOST2DEV);
+                // CNRT_ERROR_CHECK(cnctx->avctx, cnrt_ret);
+                if (cnrt_ret != CNRT_RET_SUCCESS) {
+                    av_log(cnctx->avctx, AV_LOG_WARNING,"enc: h2d warning, ret(%ld), func: %s, line: %d\n",
+                           cnrt_ret, __func__, __LINE__);
+                    return AVERROR_EXTERNAL;
+                }
+                cnrt_ret = cnrtMemcpy((void *)tempInput->plane[1].addr, (void *)frame->data[1],
+                                    cnctx->coded_width * 2 * cnctx->height / 2, CNRT_MEM_TRANS_DIR_HOST2DEV);
+                // CNRT_ERROR_CHECK(cnctx->avctx, cnrt_ret);
+                if (cnrt_ret != CNRT_RET_SUCCESS) {
+                    av_log(cnctx->avctx, AV_LOG_WARNING,"enc: h2d warning, ret(%ld), func: %s, line: %d\n",
+                           cnrt_ret, __func__, __LINE__);
+                    return AVERROR_EXTERNAL;
+                }
+                break;
+            case CNCODEC_PIX_FMT_I420:
+                if (NULL == (void *)tempInput->plane[0].addr || NULL == (void *)tempInput->plane[1].addr
+                    || NULL == (void *)tempInput->plane[2].addr) {
+                    av_log(cnctx->avctx, AV_LOG_ERROR, "Encoder input buffer address(MLU) is NULL \n");
+                    return -1;
+                }
+                if (NULL == frame->data[0] || NULL == frame->data[1] || NULL == frame->data[2]) {
+                    av_log(cnctx->avctx, AV_LOG_ERROR, "Encoder input data address(CPU) is NULL \n");
+                    return -1;
+                }
+                cnrt_ret = cnrtMemcpy((void *)tempInput->plane[0].addr, (void *)frame->data[0],
+                                    cnctx->coded_width * cnctx->height, CNRT_MEM_TRANS_DIR_HOST2DEV);
+                CNRT_ERROR_CHECK(cnctx->avctx, cnrt_ret);
+                cnrt_ret = cnrtMemcpy((void *)tempInput->plane[1].addr, (void *)frame->data[1],
+                                    cnctx->coded_width * cnctx->height / 4, CNRT_MEM_TRANS_DIR_HOST2DEV);
+                CNRT_ERROR_CHECK(cnctx->avctx, cnrt_ret);
+                cnrt_ret = cnrtMemcpy((void *)tempInput->plane[2].addr, (void *)frame->data[2],
+                                    cnctx->coded_width * cnctx->height / 4, CNRT_MEM_TRANS_DIR_HOST2DEV);
+                CNRT_ERROR_CHECK(cnctx->avctx, cnrt_ret);
+                break;
+            default:
+                av_log(cnctx->avctx, AV_LOG_ERROR, "not supported format:%d\n", cnctx->pixelFmt);
+                break;
+            }
+        }
+    } else {
+        if (cnctx->trace_flag > 0) {
+            av_log(cnctx->avctx, AV_LOG_INFO, "enc wait avail input buf failed, ret(%d) \n", ret);
+        }
+    }
+    return ret;
+}
+static void _dump_output_pkt(MLUMPPEncContext_t *cnctx, cnvideoEncOutput *outpkt)
+{
+    av_log(cnctx->avctx, AV_LOG_INFO, "***********Encoder output packet dump before***************\n");
+    av_log(cnctx->avctx, AV_LOG_INFO, "cnvideoEncOutput->streamLength:%u\n", outpkt->streamLength);
+    av_log(cnctx->avctx, AV_LOG_INFO, "cnvideoEncOutput->dataOffset:%u\n", outpkt->dataOffset);
+    av_log(cnctx->avctx, AV_LOG_INFO, "cnvideoEncOutput->pts:(%" PRId64 ")\n", outpkt->pts);
+    av_log(cnctx->avctx, AV_LOG_INFO, "cnvideoEncOutput->sliceType:%d\n", outpkt->sliceType);
+    av_log(cnctx->avctx, AV_LOG_INFO, "cnvideoEncOutput->flags:%u\n", outpkt->flags);
+    av_log(cnctx->avctx, AV_LOG_INFO, "cnvideoEncOutput->streamBuffer.addr:%lu\n", outpkt->streamBuffer.addr);
+    av_log(cnctx->avctx, AV_LOG_INFO, "cnvideoEncOutput->streamBuffer.size:%u\n", outpkt->streamBuffer.size);
+    av_log(cnctx->avctx, AV_LOG_INFO, "***********Encoder output packet dump end******************\n");
+}
+static int is_cnvid_fifo_empty(MLUMPPEncContext_t *cnctx) {
+    int is_fifo_empty = 0;
+    ff_mutex_lock(&cnctx->queue_mutex);
+    is_fifo_empty = (_cnvid_fifo_size(cnctx->frame_queue) == 0);
+    ff_mutex_unlock(&cnctx->queue_mutex);
+    return is_fifo_empty;
+}
+static int _cnvid_output_packet(MLUMPPEncContext_t *cnctx, AVPacket *pkt, int *got_packet)
+{
+    int ret = 0;
+    int tmp_len = 0;
+    int is_fifo_empty;
+    cnrtRet_t cnrt_ret;
+    MLUVideoFrameInfo_t encodedframe;
+    enum AVPictureType pict_type = AV_PICTURE_TYPE_NONE;
+    // mlumpp_enc_set_cnrt_ctx(cnctx->handle,cnctx->device_id,CNRT_CHANNEL_TYPE_NONE);
+    is_fifo_empty = is_cnvid_fifo_empty(cnctx);
+    if (!is_fifo_empty) {
+        ff_mutex_lock(&cnctx->queue_mutex);
+        av_fifo_generic_read(cnctx->frame_queue, &encodedframe, sizeof(MLUVideoFrameInfo_t), NULL);
+        ff_mutex_unlock(&cnctx->queue_mutex);
+        if (cnctx->trace_flag > 1) {
+            _dump_output_pkt(cnctx, &encodedframe.info);
+        }
+
+        /* Only insert once before first HDR, when IDR frame comes, insert extradata first */
+        if (CNCODEC_SLICE_NALU_IDR == encodedframe.info.sliceType && !cnctx->is_spspps_packet_flag) {
+            encodedframe.info.streamLength += cnctx->avctx->extradata_size;
+        }
+        ret = pkt->data ? ff_alloc_packet2(cnctx->avctx, pkt, encodedframe.info.streamLength,
+              encodedframe.info.streamLength) : av_new_packet(pkt, encodedframe.info.streamLength);
+        if (ret < 0) {
+            av_log(cnctx->avctx, AV_LOG_ERROR, "Failed to allocate pkt memory\n");
+            *got_packet = 0;
+            return AVERROR(ENOMEM);
+        }
+
+        // if (encodedframe.info.streamLength > 0 && !(encodedframe.info.flags & CNVIDEOENC_FLAG_EOS)) {
+        if (encodedframe.info.streamLength > 0) {
+            if (CNCODEC_SLICE_NALU_IDR == encodedframe.info.sliceType && !cnctx->is_spspps_packet_flag) {
+                if (NULL == pkt->data) {
+                    av_log(cnctx->avctx, AV_LOG_ERROR, "pkt data buff is null, func: %s, line: %d \n", __func__, __LINE__);
+                    return AVERROR_EXTERNAL;
+                }
+                tmp_len = cnctx->avctx->extradata_size;
+                memcpy((void *)pkt->data, cnctx->avctx->extradata, cnctx->avctx->extradata_size);
+            }
+
+            if (NULL == (void *)(encodedframe.info.streamBuffer.addr + encodedframe.info.dataOffset)) {
+                av_log(cnctx->avctx, AV_LOG_ERROR, " encodedframe data buffer[MLU] address is nullfunc: %s, line: %d\n",
+                       __func__, __LINE__);
+                return AVERROR_EXTERNAL;
+            }
+            ff_mutex_lock(&cnctx->queue_mutex);
+            cnrt_ret = cnrtMemcpy((void *)&pkt->data[tmp_len],
+                                    (void *)(encodedframe.info.streamBuffer.addr + encodedframe.info.dataOffset),
+                                    encodedframe.info.streamLength - tmp_len, CNRT_MEM_TRANS_DIR_DEV2HOST);
+            if (cnctx->handle) {
+                cnctx->total_add_ref_num--;
+                cnvideoEncReleaseReference(cnctx->handle, &encodedframe.info.streamBuffer);
+            }
+            ff_mutex_unlock(&cnctx->queue_mutex);
+            // CNRT_ERROR_CHECK(cnctx->avctx, cnrt_ret);
+            if (cnrt_ret != CNRT_RET_SUCCESS) {
+                av_log(cnctx->avctx, AV_LOG_WARNING,"enc: d2h warning, ret(%ld), func: %s, line: %d\n", cnrt_ret, __func__, __LINE__);
+                return AVERROR_EXTERNAL;
+            }
+
+            if (!cnctx->insert_spspps_idr) {
+                cnctx->is_spspps_packet_flag = 1;
+            }
+            cnctx->total_packet_count ++;
+        }
+
+        pkt->size = encodedframe.info.streamLength;
+        cnctx->total_outframe_count++;
+        *got_packet = 1;
+        pkt->pts = encodedframe.info.pts;
+        /* FIXME
+          For CNVIDEOENC_GOP_TYPE_LOW_DELAY, dts equals to pts.
+        */
+        pkt->dts = pkt->pts;
+        pkt->pts = av_rescale_q_rnd(pkt->pts, (AVRational){1, 90000}, cnctx->avctx->time_base, (AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX));
+        pkt->dts = av_rescale_q_rnd(pkt->dts, (AVRational){1, 90000}, cnctx->avctx->time_base, (AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX));
+        pkt->duration = av_rescale_q(pkt->duration, (AVRational){1, 90000}, cnctx->avctx->time_base);
+        switch (encodedframe.info.sliceType) {
+        case CNCODEC_SLICE_NALU_IDR:
+            pkt->flags |= AV_PKT_FLAG_KEY;
+        case CNCODEC_SLICE_NALU_I:
+            pict_type = AV_PICTURE_TYPE_I;
+            break;
+        case CNCODEC_SLICE_NALU_P:
+            pict_type = AV_PICTURE_TYPE_P;
+            break;
+        case CNCODEC_SLICE_NALU_B:
+            pict_type = AV_PICTURE_TYPE_B;
+            break;
+        case CNCODEC_SLICE_NALU_BI:
+            pict_type = AV_PICTURE_TYPE_BI;
+            break;
+        case CNCODEC_SLICE_UNKNOWN_TYPE:
+            // av_log(cnctx->avctx, AV_LOG_WARNING, "Unknown picture type encountered from cncodec, type:%d \n",encodedframe.info.sliceType);
+            break;
+        default:
+            av_log(cnctx->avctx, AV_LOG_ERROR, "Error picture type encountered, type:%d \n", encodedframe.info.sliceType);
+            break;
+        }
+#if FF_API_CODED_FRAME
+FF_DISABLE_DEPRECATION_WARNINGS
+        cnctx->avctx->coded_frame->pict_type = pict_type;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+        if (encodedframe.info.flags & CNVIDEOENC_FLAG_EOS) { // EOS got.
+          ret = AVERROR_EOF;
+        }
+    } else {
+        *got_packet = 0;
+        ret = AVERROR(EAGAIN);
+    }
+    return ret;
+}
+static void _dump_feeding_frame(MLUMPPEncContext_t *cnctx, cnvideoEncInput *enc_params)
+{
+    av_log(cnctx->avctx, AV_LOG_INFO, "*************Encoder feed params dump before***************\n");
+    av_log(cnctx->avctx, AV_LOG_INFO, "enc_params->flags: %u,", enc_params->flags);
+    av_log(cnctx->avctx, AV_LOG_INFO, "enc_params->pts: (%" PRId64 "),", enc_params->pts);
+    av_log(cnctx->avctx, AV_LOG_INFO, "feeding frame counts: %llu,", cnctx->total_frame_count);
+    av_log(cnctx->avctx, AV_LOG_INFO, "thread id: %lu\n", (long unsigned)pthread_self());
+    av_log(cnctx->avctx, AV_LOG_INFO, "*************Encoder feed params dump after****************\n");
+    return;
+}
+
+int ff_mlumpp_vid_enc_send_frame(AVCodecContext *avctx, MLUMPPEncContext_t *cnctx, const AVFrame *frame)
+{
+    int timeout;
+    int ret = -1;
+    cnvideoEncInput enc_params;
+    timeout = 3000;
+    // timeout = (1000 / 25) * cnctx->input_buf_num * 50;
+    if (NULL == avctx || NULL == cnctx || !cnctx->encoder_init_flag) { // Sanity checks... these are all serious usage bugs.
+        av_log(avctx, AV_LOG_ERROR, "Early error in \"ff_mlumpp_vid_enc_send_frame\" \n");
+        return AVERROR_EXTERNAL;
+    }
+    if (cnctx->codec_abort_flag) {
+        av_log(avctx, AV_LOG_ERROR, "Encoder got abort flag before sending frame, return AVERROR_EXTERNAL\n");
+        return AVERROR_EXTERNAL;
+    }
+    if (frame && !cnctx->encoder_flushing) {
+        if (cnctx->trace_flag > 1) {
+            av_log(avctx, AV_LOG_INFO, "Send frame: %ux%u (%" PRId64 "),frame tpe:%d\n",
+                   frame->width, frame->height, frame->pts, frame->pict_type);
+        }
+        memset(&enc_params, 0, sizeof(cnvideoEncInput));
+        ret = _cnvid_enc_build_std_buffer(cnctx, &enc_params.frame, frame);
+        if (ret < 0) {
+            av_usleep(1000);
+            av_log(avctx, AV_LOG_WARNING, "Get cnvideo encode build std buffer failed, ret(%ld)\n", ret);
+            return AVERROR(EAGAIN);
+        }
+        enc_params.pts = av_rescale_q(frame->pts, avctx->time_base, (AVRational){1, 90000});
+        if (cnctx->handle) {
+            ret = cnvideoEncFeedFrame(cnctx->handle, &enc_params, timeout);
+            // CNCODEC_ERROR_CHECK(avctx, ret);
+            if (ret != CNCODEC_SUCCESS) {
+                av_log(avctx, AV_LOG_ERROR, "enc feed frame failed, ret(%ld), func: %s, line: %d\n", ret, __func__, __LINE__);
+                return AVERROR_EXTERNAL;
+            } else {
+                cnctx->total_frame_count++;
+            }
+        } else {
+            av_log(avctx, AV_LOG_WARNING, "Encoder handle is NULL, skip cnvideoFeedFrame\n");
+        }
+    } else if(cnctx->encoder_flushing) {
+        if (NULL == frame) {
+            if (cnctx->trace_flag > 1) {
+                av_log(avctx, AV_LOG_INFO, "Flush encoders flow, let feeding null frames\n");
+            }
+        } else {
+            av_log(avctx, AV_LOG_ERROR, "Flush flow, never send valid packet\n");
+        }
+        return 0;
+    } else {
+        memset(&enc_params, 0, sizeof(cnvideoEncInput));
+        if (cnctx->trace_flag > 0) {
+            av_log(avctx, AV_LOG_INFO, "wait avail input buf to send eos, flush enc ... \n");
+        }
+        ret = cnvideoEncWaitAvailInputBuf(cnctx->handle, &enc_params.frame, timeout);
+        if (cnctx->trace_flag > 0) {
+            av_log(avctx, AV_LOG_INFO, "wait avail input buf to send eos, flush enc done, ret(%ld) \n", ret);
+        }
+        if (ret < 0) {
+            av_log(avctx, AV_LOG_WARNING, "Use cnvideoEncWaitAvailInputBuf failed, ret(%ld)\n", ret);
+            av_usleep(1000);
+            return AVERROR(EAGAIN);
+        }
+        if (cnctx->trace_flag > 0) {
+            av_log(avctx, AV_LOG_INFO, "cnenc feed eos, flush ... \n");
+        }
+        enc_params.flags |= (CNVIDEOENC_FLAG_EOS | CNVIDEOENC_FLAG_INVALID_FRAME);
+        if (cnctx->handle) {
+            ret = cnvideoEncFeedFrame(cnctx->handle, &enc_params, timeout);
+            if (ret < 0 && enc_params.flags) {
+                av_log(avctx, AV_LOG_WARNING, "Use cnvideoEncFeedFrame send eos failed, ret(%ld)\n", ret);
+            } else if (ret < 0 && !enc_params.flags) {
+                av_log(avctx, AV_LOG_WARNING, "Use cnvideoEncFeedFrame send null frame failed, ret(%ld)\n", ret);
+            }
+            if (ret < 0) {
+                av_log(avctx, AV_LOG_ERROR, "enc feed eos failed, ret(%ld), func: %s, line: %d\n", ret, __func__, __LINE__);
+                return AVERROR_EXTERNAL;
+            }
+        } else {
+            av_log(avctx, AV_LOG_WARNING, "Encoder cnctx handle is NULL, skip cnvideoEncFeedFrame\n");
+        }
+        if (cnctx->trace_flag > 0) {
+            av_log(avctx, AV_LOG_INFO, "cnenc feed eos, flush done \n");
+        }
+        // CNCODEC_ERROR_CHECK(avctx, ret);
+        cnctx->encoder_flushing = 1;
+    }
+    if (cnctx->trace_flag > 1) {
+        _dump_feeding_frame(cnctx, &enc_params);
+    }
+    return ret;
+}
+int ff_mlumpp_vid_enc_receive_packet(AVCodecContext *avctx, MLUMPPEncContext_t *cnctx, AVPacket *pkt)
+{
+    int ret = -1;
+    int got_packet = 0;
+    if (NULL == avctx || NULL == cnctx || NULL == pkt || !cnctx->encoder_init_flag) { //Sanity checks... these are all serious usage bugs.
+        av_log(avctx, AV_LOG_ERROR, "Early error in \"ff_mlumpp_vid_enc_receive_packet\" \n");
+        return AVERROR_EXTERNAL;
+    }
+    if (cnctx->codec_abort_flag) {
+        av_log(avctx, AV_LOG_ERROR, "encoder got abort flag before receiving packet, return AVERROR_EXTERNAL \n");
+        return AVERROR_EXTERNAL;
+    }
+    if (!cnctx->encoder_flushing) {
+        ret = _cnvid_output_packet(cnctx, pkt, &got_packet);
+        return ret;
+    }else {
+        int count = 1000;
+        while (1) {
+            ret = _cnvid_output_packet(cnctx, pkt, &got_packet);
+            if (!ret)
+                return 0;
+            if (ret == AVERROR(EAGAIN)) {
+                av_usleep(1000);
+                --count;
+                if (count <= 0 || (cnctx->eos_post_flag && is_cnvid_fifo_empty(cnctx))) {
+                    if (!cnctx->eos_post_flag)
+                        av_log(cnctx->avctx, AV_LOG_ERROR, "[%lu] Receive packet TIMEOUT->EOF\n", (long unsigned)pthread_self());
+                    return AVERROR_EOF;
+                }
+                continue;
+            }
+            return ret;
+        }
+    }
+    av_log(avctx, AV_LOG_ERROR, "[%lu] Receive frame ABORT->EOF\n", (long unsigned)pthread_self());
+    return ret;
+}
+
+static void empty_fifo_queue(AVCodecContext *avctx, MLUMPPEncContext_t *cnctx) {
+    ff_mutex_lock(&cnctx->queue_mutex);
+    if (cnctx->trace_flag > 0) {
+        av_log(avctx, AV_LOG_INFO, "cnenc empty fifo ..., add ref num: %ld \n", cnctx->total_add_ref_num);
+    }
+    while (cnctx->frame_queue && _cnvid_fifo_size(cnctx->frame_queue) > 0) {
+        MLUVideoFrameInfo_t pkt;
+        if (cnctx->trace_flag > 0) {
+            av_log(avctx, AV_LOG_INFO, "Thread id: %lu, encoded frames [%u] are reserved in cache\n", (long unsigned)pthread_self(),
+                          _cnvid_fifo_size(cnctx->frame_queue));
+        }
+        av_fifo_generic_read(cnctx->frame_queue, &pkt, sizeof(pkt), NULL);
+        if (cnctx->handle) {
+            cnctx->total_add_ref_num--;
+            cnvideoEncReleaseReference(cnctx->handle, &pkt.info.streamBuffer);
+        }
+    }
+    if (cnctx->trace_flag > 0) {
+        av_log(avctx, AV_LOG_INFO, "cnenc empty fifo done, add ref num: %ld \n", cnctx->total_add_ref_num);
+    }
+    ff_mutex_unlock(&cnctx->queue_mutex);
+}
+int ff_mlumpp_vid_enc_close(AVCodecContext *avctx, MLUMPPEncContext_t *cnctx)
+{
+    int ret = -1;
+    int timeout = 0;
+    cnrtRet_t cnrt_ret;
+    cnvideoEncInput enc_params;
+    if (NULL == avctx || NULL == cnctx || NULL == cnctx->handle) { // Sanity checks... these are all serious usage bugs.
+        av_log(avctx, AV_LOG_ERROR, "Early error in \"ff_mlumpp_vid_enc_close\" \n");
+        return -1;
+    }
+    if (cnctx->trace_flag > 0) {
+        av_log(avctx, AV_LOG_INFO, "cnencoder close ... \n");
+        av_log(avctx, AV_LOG_INFO, "enc output buf add ref num: %ld \n", cnctx->total_add_ref_num);
+    }
+    if (!cnctx->eos_reached && !cnctx->codec_abort_flag) { // workaround solution.
+        timeout = 3000;
+        // timeout = (1000 / 25) * cnctx->input_buf_num * 50;
+        if (cnctx->trace_flag > 0) {
+            av_log(avctx, AV_LOG_INFO, "enc eos not received, sent manual ..., add ref num: %ll \n", cnctx->total_add_ref_num);
+        }
+        empty_fifo_queue(avctx, cnctx);
+        memset(&enc_params, 0, sizeof(cnvideoEncInput));
+        if (cnctx->handle) {
+            if (cnctx->trace_flag > 0) {
+                av_log(avctx, AV_LOG_INFO, "enc close func wait avail input buf to send eos ... \n");
+            }
+            ret = cnvideoEncWaitAvailInputBuf(cnctx->handle, &enc_params.frame, timeout);
+            if (ret != 0) {
+                av_log(avctx, AV_LOG_ERROR, "enc close func wait avail input buf timeout, will go exit \n");
+                goto go_exit;
+            }
+            if (cnctx->trace_flag > 0) {
+                av_log(avctx, AV_LOG_INFO, "enc close func wait avail input buf to send eos done \n");
+            }
+        }
+        enc_params.flags |= (CNVIDEOENC_FLAG_EOS | CNVIDEOENC_FLAG_INVALID_FRAME);
+        if (cnctx->trace_flag > 0) {
+            av_log(avctx, AV_LOG_INFO, "cnencoder feed frame ... \n");
+        }
+        if (cnctx->handle) {
+            ret = cnvideoEncFeedFrame(cnctx->handle, &enc_params, timeout);
+            if (ret != 0) {
+                av_log(avctx, AV_LOG_ERROR, "Feedframe failed, will go exit \n");
+                goto go_exit;
+            }
+        }
+        if (cnctx->trace_flag > 0) {
+            av_log(avctx, AV_LOG_INFO, "cnencoder feed frame done \n");
+        }
+        cnctx->encoder_flushing = 1;
+    }
+
+go_exit:
+    //empty_fifo_queue(avctx, cnctx);
+    // sem_wait(&(cnctx->eos_sema));
+    if (cnctx->trace_flag > 0) {
+        av_log(avctx, AV_LOG_INFO, "cnencoder sema wait ... \n");
+    }
+    struct timespec ts;
+    clock_gettime(CLOCK_REALTIME, &ts);
+    ts.tv_sec += 5; // 5s
+    empty_fifo_queue(avctx, cnctx);
+    ret = sem_timedwait(&(cnctx->eos_sema), &ts);
+    if (ret == -1) {
+        int semvalue = -1;
+        sem_getvalue(&cnctx->eos_sema, &semvalue);
+        av_log(avctx, AV_LOG_ERROR, "enc sem_timewait = -1, semvalue = %d ... \n", semvalue);
+    }
+    if (cnctx->trace_flag > 0) {
+        av_log(avctx, AV_LOG_INFO, "cnencoder sema wait done \n");
+    }
+
+    empty_fifo_queue(avctx, cnctx);
+    av_fifo_free(cnctx->frame_queue);
+    cnctx->frame_queue = NULL;
+    ff_mutex_destroy(&cnctx->queue_mutex);
+    if (cnctx->trace_flag > 0) {
+        av_log(avctx, AV_LOG_INFO, "cnencoder destroy ... \n");
+    }
+    if (cnctx->handle) {
+        ret = cnvideoEncDestroy(cnctx->handle);
+        cnctx->handle = NULL;
+    }
+    if (cnctx->trace_flag > 0) {
+        av_log(avctx, AV_LOG_INFO, "cnencoder destroy done \n");
+    }
+    CNCODEC_ERROR_CHECK(avctx, ret);
+    if (cnctx->mluop_handle) {
+        mlumpp_mluop_resize_yuv_destroy(cnctx->mluop_handle);
+        mlumpp_mluop_unload(cnctx->mluop_handle);
+        cnctx->mluop_handle = NULL;
+        if (cnctx->resize.in_y_ptr) {
+            cnrt_ret = cnrtFree(cnctx->resize.in_y_ptr);
+            CNRT_ERROR_CHECK(avctx, cnrt_ret);
+        }
+        if (cnctx->resize.in_uv_ptr) {
+            cnrt_ret = cnrtFree(cnctx->resize.in_uv_ptr);
+            CNRT_ERROR_CHECK(avctx, cnrt_ret);
+        }
+    }
+    if (cnctx->pkt_sps_pps) {
+        free(cnctx->pkt_sps_pps);
+        cnctx->pkt_sps_pps = NULL;
+    }
+    if (avctx->extradata) {
+        av_free(avctx->extradata);
+        avctx->extradata = NULL;
+    }
+    sem_destroy(&(cnctx->eos_sema));
+    if(cnctx->cnrt_init_flag){
+        cnrtDestroy();
+    }
+    cnctx->encoder_init_flag = 0;
+    if (cnctx->trace_flag > 1) {
+        av_log(avctx, AV_LOG_INFO, "Encoder status summary: \n");
+        av_log(avctx, AV_LOG_INFO, "Encode thread id, %lu \n", (long unsigned)pthread_self());
+        av_log(avctx, AV_LOG_INFO, "Encode flushing flag:%d \n", cnctx->encoder_flushing);
+        av_log(avctx, AV_LOG_INFO, "Encode D2H total packet count:%llu\n", cnctx->total_outframe_count);
+        av_log(avctx, AV_LOG_INFO, "Encode received total packet count:%llu\n", cnctx->total_packet_count);
+        av_log(avctx, AV_LOG_INFO, "Encode feed data count:%llu\n", cnctx->total_frame_count);
+    }
+    if (cnctx->trace_flag > 0) {
+        av_log(avctx, AV_LOG_INFO, "cnencoder close done \n");
+    }
+    return 0;
+}
diff --git a/libavcodec/mlumpp_vid_enc.h b/libavcodec/mlumpp_vid_enc.h
new file mode 100755
index 0000000..ff2d9a2
--- /dev/null
+++ b/libavcodec/mlumpp_vid_enc.h
@@ -0,0 +1,118 @@
+/******************************************************************************
+ * Cambricon MLU Media Process Platform(MLU MPP) SDK
+ * Copyright (C) [2019] by Cambricon, Inc. All rights reserved
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *******************************************************************************/
+#ifndef AVCODEC_MLUMPP_VID_ENC_H
+#define AVCODEC_MLUMPP_VID_ENC_H
+#include <semaphore.h>
+#include "libavutil/fifo.h"
+#include "libavutil/thread.h"
+// Cambricon decoder header file
+#include "cn_video_enc.h"
+#include "cn_codec_common.h"
+// Cambricon runtime header file
+#include "cnrt.h"
+#include "mlumpp_mluop.h"
+typedef struct MLUMPPEncContext{
+    int                                 device_id;
+    int                                 instance_id;
+    int                                 cnrt_init_flag;
+    int                                 input_buf_num;
+    int                                 output_buf_num;
+    int                                 rcmode;
+    int                                 vbr_maxqp;
+    int                                 vbr_minqp;
+    unsigned int                        global_quality;
+    unsigned int                        profile;
+    unsigned int                        level;
+    int                                 async_queue_depth;
+    int                                 trace_flag;
+    int                                 stride_align;
+    int                                 bitrate;
+    int                                 gop_size;
+    int                                 max_b_frames;
+    unsigned int                        fps_num;
+    unsigned int                        fps_den;
+    int                                 init_qp_p;
+    int                                 init_qp_i;
+    int                                 init_qp_b;
+    int                                 cqp;
+    cnvideoEncEntropyMode               coder;
+    AVCodecContext                      *avctx;
+    cnvideoEncoder                      handle;
+    cncodecPixelFormat                  pixelFmt;
+    cncodecType                         codec_type;
+    cncodecColorSpace                   color_space;
+    int                                 width;
+    int                                 height;
+    int                                 coded_width;
+    int                                 coded_height;
+    // for add mluop
+    struct {
+        int                             left;
+        int                             top;
+        int                             right;
+        int                             bottom;
+    } crop;
+    struct {
+        int                             width;  // out w
+        int                             height; // out h
+        void                            *in_y_ptr;
+        void                            *in_uv_ptr;
+        void                            *out_y_ptr;
+        void                            *out_uv_ptr;
+    } resize;
+    struct {
+        int                             sar_w;
+        int                             sar_h;
+    } vuisar;
+
+    char                                *vui_sar_str;
+    char                                *resize_str;
+    //
+    int                                 encoder_flushing;
+    volatile int                        eos_reached;
+    sem_t                               eos_sema;
+    sem_t                               spspps_sema;
+    int                                 eos_post_flag;
+    int                                 spspps_post_flag;
+    int                                 insert_spspps_idr;
+    int                                 is_spspps_packet_flag;
+    int                                 insert_spspps_to_extradata;
+    uint8_t                             *pkt_sps_pps;
+    int                                 pkt_sps_pps_len;
+    AVFifoBuffer                        *frame_queue;
+    AVMutex                             queue_mutex;
+    int64_t                             last_send_frame_time;
+    int                                 codec_abort_flag;
+    volatile int                        encode_state; // 0--get encode-headers, 1--normal encoding
+    volatile int                        encoder_init_flag;
+    HANDLE_MLU_OP                       mluop_handle;
+    //the below only for debug
+    long long                           total_add_ref_num;
+    unsigned long long                  total_frame_count;
+    unsigned long long                  total_packet_count;
+    unsigned long long                  total_outframe_count;
+}MLUMPPEncContext_t;
+// main functions
+int ff_mlumpp_vid_enc_init(AVCodecContext *avctx, MLUMPPEncContext_t* cnctx);
+int ff_mlumpp_vid_enc_send_frame(AVCodecContext *avctx, MLUMPPEncContext_t *cnctx, const AVFrame *frame);
+int ff_mlumpp_vid_enc_receive_packet(AVCodecContext *avctx, MLUMPPEncContext_t *cnctx, AVPacket *pkt);
+int ff_mlumpp_vid_enc_close(AVCodecContext *avctx, MLUMPPEncContext_t *cnctx);
+#endif /* AVCODEC_MLUMPP_VID_ENC_H */
\ No newline at end of file
diff --git a/libavfilter/Makefile b/libavfilter/Makefile
index 455c809..05ec9a2 100644
--- a/libavfilter/Makefile
+++ b/libavfilter/Makefile
@@ -380,6 +380,7 @@ OBJS-$(CONFIG_SOBEL_OPENCL_FILTER)           += vf_convolution_opencl.o opencl.o
 OBJS-$(CONFIG_SPLIT_FILTER)                  += split.o
 OBJS-$(CONFIG_SPP_FILTER)                    += vf_spp.o
 OBJS-$(CONFIG_SR_FILTER)                     += vf_sr.o
+OBJS-$(CONFIG_SR_MLU_FILTER)                 += vf_sr_mlu.o
 OBJS-$(CONFIG_SSIM_FILTER)                   += vf_ssim.o framesync.o
 OBJS-$(CONFIG_STEREO3D_FILTER)               += vf_stereo3d.o
 OBJS-$(CONFIG_STREAMSELECT_FILTER)           += f_streamselect.o framesync.o
diff --git a/libavfilter/allfilters.c b/libavfilter/allfilters.c
index 04a3df7..733365b 100644
--- a/libavfilter/allfilters.c
+++ b/libavfilter/allfilters.c
@@ -361,6 +361,7 @@ extern AVFilter ff_vf_sobel_opencl;
 extern AVFilter ff_vf_split;
 extern AVFilter ff_vf_spp;
 extern AVFilter ff_vf_sr;
+extern AVFilter ff_vf_sr_mlu;
 extern AVFilter ff_vf_ssim;
 extern AVFilter ff_vf_stereo3d;
 extern AVFilter ff_vf_streamselect;
diff --git a/libavfilter/vf_sr_mlu.c b/libavfilter/vf_sr_mlu.c
new file mode 100644
index 0000000..0c074d0
--- /dev/null
+++ b/libavfilter/vf_sr_mlu.c
@@ -0,0 +1,271 @@
+/*
+* Copyright (c) 2020, CAMBRICON CORPORATION. All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a
+* copy of this software and associated documentation files (the "Software"),
+* to deal in the Software without restriction, including without limitation
+* the rights to use, copy, modify, merge, publish, distribute, sublicense,
+* and/or sell copies of the Software, and to permit persons to whom the
+* Software is furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+* DEALINGS IN THE SOFTWARE.
+*/
+#include <stdio.h>
+#include <string.h>
+#include "libavutil/avstring.h"
+#include "libavutil/common.h"
+//#include "libavutil/hwcontext.h"
+#include "libavutil/internal.h"
+#include "libavutil/opt.h"
+#include "libavutil/pixdesc.h"
+#include "avfilter.h"
+#include "formats.h"
+#include "internal.h"
+#include "scale.h"
+#include "video.h"
+// #include "cnrt.h"
+#include <dlfcn.h>
+#include <unistd.h>
+#include <sys/time.h>
+
+#define CNRT_ERROR_CHECK(avctx, ret)                                                        \
+    if (ret != CNRT_RET_SUCCESS) {                                                         \
+        av_log(avctx,AV_LOG_ERROR,"error occur, func: %s, line: %d\n", __func__, __LINE__);\
+        goto fail;                                                                         \
+    }
+
+static const enum AVPixelFormat supported_formats[] = {
+    AV_PIX_FMT_RGB24,
+};
+
+typedef struct MLUSRContext {
+  const AVClass *class;
+  enum AVPixelFormat in_fmt;
+  enum AVPixelFormat out_fmt;
+
+  struct {
+      int width;
+      int height;
+  } planes_in[3], planes_out[3];
+
+  AVFrame     *frame;
+
+  /**
+   * Output sw format. AV_PIX_FMT_NONE for no conversion.
+   */
+  enum AVPixelFormat format;
+
+  char* dev_id;               ///< device_id expression string
+  char* channel_id;
+  char* model_path;
+  int   trace_flag;
+
+  // buffers and mlu-sr func-ptrs
+  void *input_mlu_data;
+  void *output_mlu_data;
+  void *lib;
+  void (*ptr_sr_model_init)(void**, const char*, int, int);
+  void (*ptr_sr_model_exec)(void*, void*, uint32_t, uint32_t, void*);
+  void (*ptr_sr_model_destroy)(void*);
+
+  struct timeval start;
+  struct timeval end;
+
+  void* handle;
+} MLUSRContext;
+
+static av_cold void *dlsym_prefixed(void *handle, const char *symbol,
+                                    const char *prefix) {
+    char buf[50];
+    snprintf(buf, sizeof(buf), "%s_%s", prefix ? prefix : "", symbol);
+    return dlsym(handle, buf);
+}
+
+static int sr_lib_load(MLUSRContext *ctx, const char *lib_dir, void *logctx)
+{
+  if (lib_dir) {
+    ctx->lib = dlopen(lib_dir, RTLD_NOW | RTLD_GLOBAL);
+    if (!ctx->lib) {
+      av_log(logctx, AV_LOG_WARNING, "dlopen %s  failed, dlerror = %s\n", lib_dir, dlerror());
+      return AVERROR_EXTERNAL;
+    } else {
+      av_log(logctx, AV_LOG_TRACE, "dlopen %s successfully\n", lib_dir);
+    }
+  }
+  ctx->ptr_sr_model_init = dlsym_prefixed(ctx->lib, "infer_sr_init", "mluop");
+  ctx->ptr_sr_model_exec = dlsym_prefixed(ctx->lib, "infer_sr_exec", "mluop");
+  ctx->ptr_sr_model_destroy = dlsym_prefixed(ctx->lib, "infer_sr_destroy", "mluop");
+  if (!ctx->ptr_sr_model_init || !ctx->ptr_sr_model_exec || !ctx->ptr_sr_model_destroy) {
+    av_log(logctx, AV_LOG_WARNING, "Not all functions found in %s\n", lib_dir);
+    dlclose(ctx->lib);
+    ctx->lib = NULL;
+    return AVERROR_EXTERNAL;
+  }
+  return 0;
+}
+
+static int sr_lib_unload(MLUSRContext *ctx) {
+  if (ctx->lib) {
+    dlclose(ctx->lib);
+    ctx->lib = NULL;
+  }
+  return 0;
+}
+
+static av_cold int mlu_sr_init(AVFilterContext *ctx) {
+  MLUSRContext *s = ctx->priv;
+  static const char * const mluop_libname = "/usr/local/neuware/lib64/libeasyOP.so";
+  int ret = sr_lib_load(s, mluop_libname, ctx);
+  if (ret < 0) {
+    av_log(ctx, AV_LOG_WARNING, "SR Load lib error! Error id : %d\n", ret);
+    return ret;
+  }
+
+  s->frame = av_frame_alloc();
+  if (!s->frame) {
+    sr_lib_unload(s);
+    av_log(ctx, AV_LOG_WARNING, "SR Alloc frame error! Error id : %d\n", AVERROR(ENOMEM));
+    return AVERROR(ENOMEM);
+  }
+  return 0;
+}
+
+static av_cold void mlu_sr_uninit(AVFilterContext *ctx) {
+  MLUSRContext *s = ctx->priv;
+  s->ptr_sr_model_destroy(s->handle);
+  sr_lib_unload(s);
+  if (!s->frame) {
+    av_log(ctx, AV_LOG_WARNING, "frame error! Error id : %d\n", AVERROR(ENOMEM));
+  } else {
+      av_frame_free(&s->frame);
+  }
+}
+
+static int mlu_sr_query_formats(AVFilterContext *ctx) {
+    static const enum AVPixelFormat pixel_formats[] = {
+        AV_PIX_FMT_RGB24, AV_PIX_FMT_NONE,
+    };
+    AVFilterFormats *pix_fmts = ff_make_format_list(pixel_formats);
+    return ff_set_common_formats(ctx, pix_fmts);
+}
+
+static int mlu_filter_frame(AVFilterLink *link, AVFrame *in) {
+  AVFilterContext *ctx = link->dst;
+  MLUSRContext *s = ctx->priv;
+  AVFilterLink *outlink = ctx->outputs[0];
+
+  AVFrame *out = NULL;
+  out = ff_get_video_buffer(outlink, outlink->w, outlink->h);
+  if (!out) {
+      av_log(ctx, AV_LOG_WARNING, "get video buffer error! Error id : %d\n", AVERROR(ENOMEM));
+      av_frame_free(&in);
+      return AVERROR(ENOMEM);
+  }
+
+  av_frame_copy_props(out, in);
+  out->width  = outlink->w;
+  out->height = outlink->h;
+  if (s->trace_flag) {
+    gettimeofday(&s->start,NULL);
+  }
+  s->ptr_sr_model_exec(s->handle, (void *)in->data[0], in->linesize[0] , out->linesize[0], (void*)out->data[0]);
+  if (s->trace_flag) {
+    gettimeofday(&s->end,NULL);
+    float time_use=(s->end.tv_sec-s->start.tv_sec)*1000000+(s->end.tv_usec-s->start.tv_usec);
+    av_log(ctx, AV_LOG_INFO, "Inference fps: %3f \n", 1000000 / time_use);
+  }
+  av_frame_free(&in);
+  return ff_filter_frame(outlink, out);
+}
+
+static av_cold int mlu_config_props(AVFilterLink *outlink) {
+  AVFilterContext *ctx = outlink->src;
+  AVFilterLink *inlink = outlink->src->inputs[0];
+  MLUSRContext *s = ctx->priv;
+  FILE *model;
+  outlink->w = 2 * inlink->w;
+  outlink->h = 2 * inlink->h;
+  outlink->format = AV_PIX_FMT_RGB24;
+  av_log(ctx, AV_LOG_VERBOSE, "w:%d h:%d -> w:%d h:%d\n", inlink->w, inlink->h, outlink->w, outlink->h);
+  if(s->lib) {
+    if (strlen(s->model_path) > 1) {
+      // av_log(ctx, AV_LOG_INFO, "model_path: %s\n", s->model_path);
+      s->ptr_sr_model_init(&s->handle, s->model_path, atoi(s->dev_id), atoi(s->channel_id));
+    } else {
+      char model_path[256];
+      if (readlink("/proc/self/exe", model_path, 256) < 0) {
+          av_log(ctx, AV_LOG_ERROR, "Failed to find ffmpeg\n");
+      }
+      char *tail = strrchr(model_path, '/');
+      *tail = '\0';
+      sprintf(model_path, "%s/libmlu/%dx%d.cambricon", model_path, inlink->w, inlink->h);
+      // av_log(ctx, AV_LOG_INFO, "model_path: %s\n", model_path);
+      if ((model = fopen(model_path,"rb")) == NULL) {
+        av_log(ctx, AV_LOG_ERROR, "Failed to find model %s\n", model_path);
+      } else {
+        fclose(model);
+        s->ptr_sr_model_init(&s->handle, model_path, atoi(s->dev_id), atoi(s->channel_id));
+      }
+    }
+  }
+  return 0;
+}
+
+#define OFFSET(x) offsetof(MLUSRContext, x)
+#define FLAGS (AV_OPT_FLAG_FILTERING_PARAM|AV_OPT_FLAG_VIDEO_PARAM)
+static const AVOption options[] = {
+    { "model",     "model path",     OFFSET(model_path),   AV_OPT_TYPE_STRING, { .str = ""    }, .flags = FLAGS },
+    { "dev_id",    "device index",   OFFSET(dev_id),       AV_OPT_TYPE_STRING, { .str = "0"   }, .flags = FLAGS },
+    { "channel_id","channel index",  OFFSET(channel_id),   AV_OPT_TYPE_STRING, { .str = "-1"  }, .flags = FLAGS },
+    { "trace",     "trace switch",   OFFSET(trace_flag),   AV_OPT_TYPE_INT,    { .i64 = 0     },  0, 1, .flags = FLAGS },
+    { NULL },
+};
+
+static const AVClass mlu_sr_class = {
+    .class_name = "mlu_sr",
+    .item_name  = av_default_item_name,
+    .option     = options,
+    .version    = LIBAVUTIL_VERSION_INT,
+};
+
+static const AVFilterPad mlu_sr_inputs[] = {
+    {
+        .name         = "default",
+        .type         = AVMEDIA_TYPE_VIDEO,
+        .filter_frame = mlu_filter_frame,
+    },
+    { NULL }
+};
+
+static const AVFilterPad mlu_sr_outputs[] = {
+    {
+        .name         = "default",
+        .config_props = mlu_config_props,
+        .type         = AVMEDIA_TYPE_VIDEO,
+    },
+    { NULL }
+};
+
+AVFilter ff_vf_sr_mlu = {
+    .name      = "sr_mlu",
+    .description = NULL_IF_CONFIG_SMALL("MLU accelerated video super-resolution reconstruction"),
+
+    .init          = mlu_sr_init,
+    .uninit        = mlu_sr_uninit,
+    .query_formats = mlu_sr_query_formats,
+
+    .priv_size = sizeof(MLUSRContext),
+    .priv_class = &mlu_sr_class,
+
+    .inputs    = mlu_sr_inputs,
+    .outputs   = mlu_sr_outputs,
+};
-- 
2.7.4

