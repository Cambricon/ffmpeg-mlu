/*************************************************************************
 * Copyright (C) [2019-2022] by Cambricon, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUKType WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUKType NOKType LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENKType SHALL THE AUTHORS OR COPYRIGHKType HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORKType OR OTHERWISE, ARISING FROM, OUKType OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *************************************************************************/
#include "mlu.h"
#include "yuv_to_rgb_mlu.h"
#include "kernel.h"

__mlu_func__ void doYuvToRgb(int row_num,
                             int width,
                             int y_stride,
                             int uv_stride,
                             int rgb_stride,
                             int dst_chn,
                             int ci,
                             int bias_len,
                             uint8_t *y_nram,
                             uint8_t *uv_nram,
                             half *rgb_nram,
                             half *bias_nram,
                             uint8_t *y_gdram,
                             uint8_t *uv_gdram,
                             uint8_t *rgb_gdram,
                             int16 *conv_kernel_wram,
                             bool is_odd) {
  /* copy yuv data to nram */
  uint32_t width_align = CEIL_ALIGN(width, 64);
  __memcpy(y_nram, y_gdram, width, GDRAM2NRAM,
           width_align, y_stride, row_num - 1);
  __memcpy(uv_nram, uv_gdram, width,
           GDRAM2NRAM, width_align * 2, uv_stride, (row_num -1) / 2);
  if (row_num > 1) {
    if (is_odd) {
      __memcpy(uv_nram + width_align, uv_gdram + uv_stride, width,
               GDRAM2NRAM, width_align * 2, uv_stride, row_num / 2 - 1);
    } else {
      __memcpy(uv_nram + width_align, uv_gdram, width,
               GDRAM2NRAM, width_align * 2, uv_stride, row_num / 2 - 1);
    }
  }

  /* compute length of data */
  int co = ci * dst_chn;
  int input_len_align = row_num * width_align;
  int output_len_align = input_len_align * dst_chn;

  /* convert source yuv data type to fix16 */
  __bang_uchar2half(rgb_nram, (unsigned char *)y_nram, input_len_align * 2);
  __bang_half2int16_rd((int16 *)y_nram, rgb_nram, input_len_align * 2, -7);

  /**************************************************
   * do conv
   * input shape(nhwc): 1 2 input_len_align/ci ci
   * kernel shape(nhwc): co 2 1 ci
   * output shape(nhwc): 1 1 input_len_align/ci co
   **************************************************/
  __bang_conv((half *)rgb_nram, (int16 *)y_nram, conv_kernel_wram, ci, 2,
              input_len_align / ci, 2, 1, 1, 1, co, -20);

  /* add bias */
  __bang_cycle_add(rgb_nram, rgb_nram, bias_nram, output_len_align, bias_len);

  /* truncate values < 0 */
  __bang_active_relu(rgb_nram, rgb_nram, output_len_align);

  /* truncate values > 255 */
  __nramset_half((half *)y_nram, 64, 255);
  __bang_cycle_sub(rgb_nram, rgb_nram, (half *)y_nram, output_len_align, 64);
  __bang_mul_const(rgb_nram, rgb_nram, -1, output_len_align);
  __bang_active_relu(rgb_nram, rgb_nram, output_len_align);
  __bang_mul_const(rgb_nram, rgb_nram, -1, output_len_align);
  __bang_cycle_add(rgb_nram, rgb_nram, (half *)y_nram, output_len_align, 64);

  /* convert result data type to uint8 */
  half *dst_mask = (half *)(y_nram);
  half *tmp = bias_nram + bias_len;
  __nramset_half(tmp, 64, 127);
  __bang_cycle_gt(dst_mask, rgb_nram, tmp, output_len_align, 64);
  __bang_mul_const(dst_mask, dst_mask, 256.0, output_len_align);
  __bang_sub(dst_mask, rgb_nram, dst_mask, output_len_align);
  __bang_half2uchar_dn((signed char *)rgb_nram, dst_mask,
                       CEIL_ALIGN(output_len_align, 128));

  /* copy result to gdram */
  if (row_num == 1) {
    __memcpy(rgb_gdram, rgb_nram, width * dst_chn, NRAM2GDRAM);
  } else {
    __memcpy(rgb_gdram, rgb_nram, width * dst_chn, NRAM2GDRAM,
             rgb_stride, width_align * dst_chn, row_num - 1);
  }
}

__mlu_entry__ void MLUUnion1KernelYuv420spToRgb(uint8_t **src_gdram,
                                           uint8_t **dst_gdram,
                                           int16 *conv_kernel_gdram,
                                           float *bias_gdram,
                                           const uint32_t height,
                                           const uint32_t width,
                                           const uint32_t src_y_stride,
                                           const uint32_t src_uv_stride,
                                           const uint32_t dst_stride,
                                           const uint32_t batch_size,
                                           const uint32_t ci,
                                           const uint32_t dst_chn) {
  /* calculate how many rows will be processed in this task */
  int task_rows = height / taskDim;
  int remain_rows = height % taskDim;
  int start_row_id;
  if (taskId < remain_rows) {
    task_rows += 1;
    start_row_id = taskId * task_rows;
  } else {
    start_row_id = taskId * task_rows + remain_rows;
  }
  if (task_rows == 0) {
    return;
  }

  /* calculate how many rows can be processed at a time */
  int width_align = CEIL_ALIGN(width, 64);
  int output_num_per_row = width_align * dst_chn;
  int space_per_row = output_num_per_row * 2 * sizeof(int16);
  int max_rows_per_time = (MAX_NRAM_SIZE - 768) / space_per_row;

  /* calculate how many times the process need to be repeated in this task */
  int repeat;
  int rows_per_time;
  int rows_last_time;
  if (max_rows_per_time >= task_rows) {
    rows_per_time = task_rows;
    repeat = 1;
    rows_last_time = task_rows;
  } else {
    rows_per_time = max_rows_per_time;
    repeat = task_rows / max_rows_per_time;
    int remain = task_rows % max_rows_per_time;
    if (remain != 0) {
      repeat++;
      rows_last_time = remain;
    } else {
      rows_last_time = rows_per_time;
    }
  }

  /* calculate data length */
  int co = ci * dst_chn;
  int input_len_align = rows_per_time * width_align;
  int output_len_align = input_len_align * dst_chn;
  int kernel_len = 2 * ci * co;
  int bias_len = 64;
  if (dst_chn == 3) {
    bias_len = co;
  }

  /***********************************************************
   * apply space on nram for src data, dst data and bias data
   * apply space on wram for conv kernel data 
   ***********************************************************/
  // __nram__ int16 nram_buf[MAX_SIZE / 2 + 64 * 5 + 64];
  __nram__ int16 nram_buf[MAX_NRAM_SIZE / 2];
  __wram__ int16 conv_kernel_wram[MAX_KERNEL_LEN];
  int16 *src = nram_buf;
  int16 *dst = nram_buf + output_len_align + 64;
  int16 *bias_nram = dst + output_len_align + 64;

  /* copy kernel data to WRAM */
  __memcpy(conv_kernel_wram, conv_kernel_gdram,
           kernel_len * sizeof(int16), GDRAM2WRAM);

  /**********************************
   * copy bias data to nram
   * convert bias data type to half 
   ***********************************/
  __memcpy(src, bias_gdram, bias_len * sizeof(float), GDRAM2NRAM);
  __bang_float2half_rd((half *)bias_nram, (float *)src, bias_len);

  /* do yuv to rgb */
  for (int batch_idx = 0; batch_idx < batch_size; batch_idx ++) {
    int row_num = rows_per_time;
    input_len_align = rows_per_time * width_align;
    for (int i = 0; i < repeat; i ++) {
      if (i == repeat - 1) {
        row_num = rows_last_time;
        input_len_align = row_num * width_align;
      }
      /* calculate the starting address */
      int row_id = start_row_id + rows_per_time * i;
      bool is_odd = (row_id % 2 == 1) ? true : false;
      int offset_y = (start_row_id + rows_per_time * i) * src_y_stride;
      int offset_uv = (start_row_id + rows_per_time * i) / 2 * src_uv_stride;
      int offset_rgb = (start_row_id + rows_per_time * i) * dst_stride;
      uint8_t *y_nram = (uint8_t *)src;
      uint8_t *uv_nram = y_nram + input_len_align;
      half *rgb_nram = (half *)dst;
      uint8_t *y_gdram = src_gdram[batch_idx * 2] + offset_y;
      uint8_t *uv_gdram = src_gdram[batch_idx * 2 + 1] + offset_uv;
      uint8_t *rgb_gdram = dst_gdram[batch_idx] + offset_rgb;

      doYuvToRgb(row_num,
                 width,
                 src_y_stride,
                 src_uv_stride,
                 dst_stride,
                 dst_chn,
                 ci,
                 bias_len,
                 y_nram,
                 uv_nram,
                 rgb_nram,
                 (half *)bias_nram,
                 y_gdram,
                 uv_gdram,
                 rgb_gdram,
                 conv_kernel_wram,
                 is_odd);
    }
  }
}
