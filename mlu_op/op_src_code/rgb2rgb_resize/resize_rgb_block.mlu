/*************************************************************************
 * Copyright (C) [2019-2022] by Cambricon, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subrow_idxect to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUKType WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUKType NOKType LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENKType SHALL THE AUTHORS OR COPYRIGHKType HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORKType OR OTHERWISE, ARISING FROM, OUKType OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *************************************************************************/

#include <algorithm>
#include "mlu.h"
#include "resize_rgb_mlu.h"

__mlu_func__ void loadFilters(half* cpy_syn, half* buffer, int ci, int mult, int chn_num) {
  half *iden_ci = buffer;
  half *cpy_filter = iden_ci + ci * ci;
  __bang_write_zero(iden_ci, ci * ci);
  for (int i = 0; i < ci; i ++) {
    ((int16_t*)iden_ci)[i * ci + i] = 1;
  }

  int kernel_num = mult * ci;
  int kernel_num_per_lt = kernel_num / LT_NUM;
  for (int kernel_id = 0; kernel_id < kernel_num; kernel_id ++) {
    int lt_id = kernel_id % LT_NUM;
    int lt_offset = kernel_id / LT_NUM;
    int filter_offset = lt_id * kernel_num_per_lt + lt_offset;
    int iden_offset = chn_num * (kernel_id / (chn_num * mult)) + (kernel_id % chn_num);
    __memcpy(cpy_filter + filter_offset * ci, iden_ci + iden_offset * ci,
             ci * sizeof(half), NRAM2NRAM);
  }
  __memcpy(cpy_syn, cpy_filter, ci * ci * mult * sizeof(half), NRAM2WRAM);
}

template<typename T>
__mlu_func__ void genMaskAndWeights(T *weight_x,
                                    T *mask_x0,
                                    T *mask_x1,
                                    float scale_x,
                                    int start_col,
                                    int chn_num,
                                    int dst_deal_num,
                                    int mult,
                                    int col_limit) {
  T fx = 0.0;  // fractional part
  int sx = 0;     // integer part
  T wx0 = 0.0;  // weight for left point
  T wx1 = 0.0;  // weight for right point

  int sx_prev = -1;
  int d_idx_prev = 0;

  float map_x = (start_col + 0.5) * scale_x - 0.5;
  map_x = map_x * (int)(map_x > 0);
  map_x = std::min((float)col_limit, map_x);
  int src_idx = (int)map_x;
  for (int d_idx = 0; d_idx < dst_deal_num; d_idx ++) {
    float map_x = (start_col + d_idx + 0.5) * scale_x - 0.5;
    map_x = map_x + 0.000001;
    map_x = std::max((float)0, map_x);
    map_x = std::min((float)col_limit, map_x);
    sx = (int)map_x;
    if (map_x == 1.0) {
      sx = 1;
    }
    fx = map_x - sx;
    sx = sx - src_idx;
    wx0 = (T)1.f - fx;
    wx1 = fx;

    d_idx_prev = d_idx * (sx_prev != sx) + d_idx_prev * (sx_prev == sx);
    sx_prev = sx;
    int offsetW0 = chn_num * d_idx;
    int offsetW1 = chn_num * d_idx + CEIL_ALIGN(dst_deal_num * chn_num, 64);
    int trueIdx0 = (sx * mult + (d_idx - d_idx_prev)) * chn_num;
    int trueIdx1 = ((sx + 1) * mult + (d_idx - d_idx_prev)) * chn_num;
    for (int k = 0; k < chn_num; k ++) {
      weight_x[offsetW0++] = wx0;
      weight_x[offsetW1++] = wx1;
      mask_x0[trueIdx0 ++] = 1;
      mask_x1[trueIdx1 ++] = 1;
    }
  }
}

__mlu_func__ int find_limit(int roi_w,
                            int d_col,
                            int mult,
                            uint32_t chn_num,
                            uint32_t depth_size) {
  int lower_bound = 0;
  int upper_bound = d_col + 1;

  uint32_t align_pad = 64;
  if (chn_num == 3) {
    align_pad = 192;
  }

  // weight_x num: dst_len_pad * 2
  // mask_x0 num: src_len_pad * mult
  // mask_x1 num: src_len_pad * mult
  // src num: max(src_len_pad * 2 * mult, 4 * dst_len_pad)
  // s_line num: src_len_pad * 2
  // s_line0: dst_len_pad * 2
  // s_line1: dst_len_pad * 2
  // s_line0 s_line1 reuse s_line, so s_line num: max(src_len_pad * 2, dst_len_pad * 4)
  while (lower_bound < upper_bound - 1) {
    int dst_num = (lower_bound + upper_bound) / 2;
    int dst_len = dst_num * chn_num;
    int dst_len_pad = CEIL_ALIGN(dst_len, 64);
    int src_num = std::min(roi_w, dst_num * roi_w / d_col + 3);
    int src_len = src_num * chn_num;
    int src_len_pad = CEIL_ALIGN(src_len, align_pad);

    int malloc_num = dst_len_pad * 2 + mult * src_len_pad * 2 +
                      std::max(4 * dst_len_pad, 2 * src_len_pad) +
                      std::max(4 * dst_len_pad, 2 * mult * src_len_pad);
    int malloc_size = malloc_num * 2 + 128 * 2;
    if (depth_size == 4) {
      malloc_size = malloc_num * 4 + 64 * 4;
    }

    if (malloc_size <= MAX_NRAM_SIZE)
      lower_bound = dst_num;
    else
      upper_bound = dst_num;
  }
  return lower_bound;
}

template<typename DT>
__mlu_func__ void resizeRgbx(DT **src_gdram,
                             DT **dst_gdram,
                             uint32_t *src_rois,
                             uint32_t batch_size,
                             uint32_t s_height,
                             uint32_t s_width,
                             uint32_t s_stride,
                             uint32_t d_x,
                             uint32_t d_y,
                             uint32_t d_col,
                             uint32_t d_row,
                             uint32_t d_stride,
                             uint32_t chn_num) {
  if (coreId != 0x80) {
    // 1. batch_size % taskDim == 0, batch_size / taskDim pics for each task;
    // 2. taskDim % batch_size == 0, taskDim / batch_size tasks for one pic;
    // 3. else, each pic divided to taskDim picies
    int batch_task_id = taskId;
    int start_batch = 0;
    int end_batch = batch_size;
    int d_row_seg = d_row / taskDim + int(d_row % taskDim != 0);
    int start_row = d_row_seg * taskId;
    int end_row = std::min(d_row_seg * (taskId + 1), (int)d_row);
    if (batch_size % taskDim == 0) {
      start_batch = taskId * (batch_size / taskDim);
      end_batch = start_batch + (batch_size / taskDim);
      d_row_seg = d_row;
      start_row = 0;
      end_row = d_row;
    }
    if ((taskDim > batch_size) && (taskDim % batch_size == 0)) {
      int task_num_per_pic = taskDim / batch_size;
      start_batch = taskId / task_num_per_pic;
      end_batch = start_batch + 1;
      d_row_seg = d_row / task_num_per_pic + int(d_row % task_num_per_pic != 0);
      batch_task_id = taskId % (taskDim / batch_size);
      start_row = d_row_seg * batch_task_id;
      end_row = std::min(d_row_seg * (batch_task_id + 1), (int)d_row);
    }
    if (start_row > (d_row - 1)) {
      return;
    }

    int ci = CI_0;
    int conv_mult_limit = CONV_MULT_LIMIT_0;
    if (chn_num == 3) {
      ci = CI_1;
      conv_mult_limit = CONV_MULT_LIMIT_1;
    }

    for (uint32_t batch_idx = start_batch; batch_idx < end_batch; batch_idx ++) {
      uint32_t roi_x = src_rois[4 * batch_idx];
      uint32_t roi_y = src_rois[4 * batch_idx + 1];
      uint32_t roi_w = src_rois[4 * batch_idx + 2];
      uint32_t roi_h = src_rois[4 * batch_idx + 3];
      // uint32_t roi_w = src_rois[4 * batch_idx + 2] - roi_x;
      // uint32_t roi_h = src_rois[4 * batch_idx + 3] - roi_y;
      float scale_x = (float)roi_w / (float)d_col;
      float scale_y = (float)roi_h / (float)d_row;

      // ((d_x + 0.5) * scale_x - 0.5 = 1) => (d_x = 1.5 / scale_x - 0.5)
      // mult = d_x - 0
      int mult = (int)(roi_w < d_col) * __float2int_up(1.5 / scale_x - 0.5) +
                 (int)(roi_w >= d_col);

      int dst_num_limit = find_limit(roi_w, d_col, mult, chn_num, sizeof(DT));
      int per_dst_num = std::min(dst_num_limit, (int)d_col);
      int per_dst_len = per_dst_num * chn_num;
      int per_dst_len_pad = CEIL_ALIGN(per_dst_len, 64);
      int repeat = d_col / per_dst_num;
      int remainder = d_col % per_dst_num;
      if (repeat != 0 && remainder == 0) {
        repeat -= 1;
        remainder = per_dst_num;
      }
      int remainder_len = remainder * chn_num;
      int remainder_len_pad = CEIL_ALIGN(remainder_len, 64);

      int src_num = roi_w * per_dst_num / d_col + 3;
      src_num = src_num * (src_num <= roi_w) + roi_w * (src_num > roi_w);
      src_num = (repeat > 0) * src_num + (repeat == 0) * roi_w;
      int src_len = src_num * chn_num;
      int src_len_pad = CEIL_ALIGN(src_len, ci);

      int weight_num = per_dst_len_pad * 2;
      int mask_num = src_len_pad * mult;
      half* temp = (half *)buffer;
      half* weight_x = temp + 64;
      half* mask_x0 = weight_x + weight_num;
      half* mask_x1 = mask_x0 + mask_num;
      half* src = mask_x1 + mask_num;
      half* src_line0 = src + std::max(4 * per_dst_len_pad, 2 * mask_num);
      half* src_line1 = src_line0 + per_dst_len_pad * 2;

      DT *cur_src = src_gdram[batch_idx];
      DT *cur_dst = (DT *)((uint8_t *)(dst_gdram[batch_idx]) + d_y * d_stride);

      // if mult = 1, do not need do conv operation
      // if mult > conv_mult_limit, filter is too big to put on wram
      if (mult > 1 && mult <= conv_mult_limit) {
        loadFilters(cpy_syn, (half *)buffer, ci, mult, chn_num);
      }

      int row_limit = roi_h - 1;
      int col_limit = roi_w - 1;
      int dst_num = per_dst_num;
      int dst_len = per_dst_len;
      int dst_len_pad = per_dst_len_pad;
      for (int i = 0; i < repeat + 1; i ++) {
        int start_col = i * per_dst_num;
        if (i == repeat) {
          dst_num = remainder;
          dst_len = remainder_len;
          dst_len_pad = remainder_len_pad;
        }
        float map_x = (start_col + 0.5) * scale_x - 0.5;
        map_x = map_x * (int)(map_x > 0);
        map_x = std::min((float)col_limit, map_x);
        int src_idx = (int)map_x;
        int src_remainder = roi_w - src_idx;
        src_num = std::min(src_num, src_remainder);
        int src_len = src_num * chn_num;
        int src_len_pad = CEIL_ALIGN(src_len, ci);
        int mask_len = src_len_pad * mult;

        __bang_write_zero(mask_x0, mask_len);
        __bang_write_zero(mask_x1, mask_len);
        genMaskAndWeights<half>(weight_x, mask_x0, mask_x1, scale_x, start_col,
                          chn_num, dst_num, mult, col_limit);

        half fy = 0.0;
        int sy_0 = 0;
        int sy_1 = 0;
        half wy0 = 0.0;
        half wy1 = 0.0;

        for (int row_idx = start_row; row_idx < end_row; ++row_idx) {
          float map_y = (row_idx + 0.5) * scale_y - 0.5;
          map_y = map_y * (int)(map_y > 0);
          map_y = std::min(map_y, (float)row_limit);
          sy_0 = (int)map_y;
          sy_1 = sy_0 + 1;
          if (sy_0 == row_limit) {
            sy_1 = sy_0;
          }

          int offset0 = (roi_y + sy_0) * s_stride
                        + (src_idx + roi_x) * chn_num * sizeof(DT);
          int offset1 = (roi_y + sy_1) * s_stride
                        + (src_idx + roi_x) * chn_num * sizeof(DT);

          // uint8
          if (sizeof(DT) == 1) {
            if (mult <= conv_mult_limit) {
              __memcpy(src_line0, (uint8_t *)cur_src + offset0,
                       src_len * sizeof(DT), GDRAM2NRAM);
              __memcpy((DT *)src_line0 + src_len_pad, (uint8_t *)cur_src + offset1,
                        src_len * sizeof(DT), GDRAM2NRAM);
              __bang_uchar2half(src, (uint8_t *)src_line0, src_len_pad * 2);
            } else {
              __memcpy(src, (uint8_t *)cur_src + offset0,
                       src_len, GDRAM2NRAM);
              __memcpy((DT *)src + src_len_pad, (uint8_t *)cur_src + offset1,
                       src_len, GDRAM2NRAM);
              __bang_uchar2half(src_line0, (uint8_t *)src, src_len_pad * 2);

              // expand mult times
              for (int i = 0; i < mult; i ++) {
                __memcpy(src + i * chn_num, src_line0, chn_num * 2,
                         NRAM2NRAM, chn_num * mult * 2, chn_num * 2, src_num - 1);
                __memcpy(src + mask_len + i * chn_num, src_line0 + src_len_pad, chn_num * 2,
                         NRAM2NRAM, chn_num * mult * 2, chn_num * 2, src_num - 1);
              }
            }
          } else if (sizeof(DT) == 2) {  // half
            if (mult <= conv_mult_limit) {
              __memcpy(src, (uint8_t *)cur_src + offset0,
                       src_len * 2, GDRAM2NRAM);
              __memcpy(src + src_len_pad, (uint8_t *)cur_src + offset1,
                       src_len * 2, GDRAM2NRAM);
            } else {
              __memcpy(src_line0, (uint8_t *)cur_src + offset0,
                       src_len * 2, GDRAM2NRAM);
              __memcpy(src_line0 + src_len_pad, (uint8_t *)cur_src + offset1,
                       src_len * 2, GDRAM2NRAM);

              // expand mult times
              for (int i = 0; i < mult; i ++) {
                __memcpy(src + i * chn_num, src_line0, chn_num * 2,
                         NRAM2NRAM, chn_num * mult * 2, chn_num * 2, src_num - 1);
                __memcpy(src + mask_len + i * chn_num, src_line0 + src_len_pad, chn_num * 2,
                         NRAM2NRAM, chn_num * mult * 2, chn_num * 2, src_num - 1);
              }
            }
          }

          // if mult > conv_mult_limit, filter is too big to put on wram
          if (mult > 1 && mult <= conv_mult_limit) {
            __bang_half2int16_rd((int16_t*)src_line0, src, src_len_pad * 2, -7);
            __bang_conv(src, (int16_t*)src_line0, (int16_t*)cpy_syn, ci, 1,
                        src_len_pad * 2 / ci, 1, 1, 1, 1, ci * mult, -7);
          }

          __bang_collect(src_line0, src, mask_x0, mask_len);
          __bang_collect(src_line0 + dst_len_pad, src, mask_x1, mask_len);
          __bang_collect(src_line1, src + mask_len, mask_x0, mask_len);
          __bang_collect(src_line1 + dst_len_pad, src + mask_len, mask_x1, mask_len);

          // one row of src may be used many times
          int next_row_idx = __float2int_up((sy_0 + 1.5) / scale_y - 0.5);
          next_row_idx = std::min(next_row_idx, row_limit);
          int src_reuse_num = std::max(1, next_row_idx - row_idx);
          for (int src_reuse = 0; src_reuse < src_reuse_num; src_reuse ++) {
            float map_y = (row_idx + 0.5) * scale_y - 0.5;
            map_y = map_y * (int)(map_y > 0);
            map_y = std::min(map_y, (float)row_limit);
            sy_0 = (int)map_y;
            fy = map_y - sy_0;
            wy0 = (half)1.f - fy;
            wy1 = (half)1.f - wy0;

            half* dst_line0 = src;
            half* dst_line1 = dst_line0 + 2 * dst_len_pad;
            __bang_mul(dst_line0, src_line0, weight_x, dst_len_pad * 2);
            __bang_add(dst_line0, dst_line0, dst_line0 + dst_len_pad, dst_len_pad);
            __bang_mul(dst_line1, src_line1, weight_x, dst_len_pad * 2);
            __bang_add(dst_line1, dst_line1, dst_line1 + dst_len_pad, dst_len_pad);

            __bang_mul_const(dst_line0, dst_line0, wy0, dst_len_pad);
            __bang_mul_const(dst_line1, dst_line1, wy1, dst_len_pad);
            __bang_add(dst_line0, dst_line0, dst_line1, dst_len_pad);

            half* dst = dst_line0;
            half* dst_mask = dst + dst_len_pad;
            int dst_size = dst_len * sizeof(DT);

            if (sizeof(DT) == 1) {
              __nramset_half(temp, 64, 127);
              __bang_cycle_gt(dst_mask, dst, temp,
                              dst_len_pad, 64);
              __bang_mul_const(dst_mask, dst_mask, 256, dst_len_pad);
              __bang_sub(dst_mask, dst, dst_mask, dst_len_pad);
              __bang_half2uchar_dn((signed char*)dst, dst_mask,
                                   CEIL_ALIGN(dst_len_pad, 128));
            }

            __memcpy((uint8_t *)cur_dst + row_idx * d_stride + d_x * chn_num * sizeof(DT)
                     + i * per_dst_len * sizeof(DT), dst, dst_size, NRAM2GDRAM);
            row_idx += 1;
          }  // for (int src_reuse = 0; src_reuse < src_reuse_num; src_reuse ++)
          row_idx -= 1;
        }  // for (int row_idx = start_row; row_idx < end_row; ++row_idx)
      }  // for (int i = 0; i < repeat + 1; i ++)
    }  // for (uint32_t batch_idx = start_batch; batch_idx < end_batch; batch_idx ++)
  }  // if (coreId != 0x80)
}

__mlu_func__ void resizeRgbxFloat(float **src_gdram,
                             float **dst_gdram,
                             uint32_t *src_rois,
                             uint32_t batch_size,
                             uint32_t s_height,
                             uint32_t s_width,
                             uint32_t s_stride,
                             uint32_t d_x,
                             uint32_t d_y,
                             uint32_t d_col,
                             uint32_t d_row,
                             uint32_t d_stride,
                             uint32_t chn_num) {
  if (coreId != 0x80) {
    // 1. batch_size % taskDim == 0, batch_size / taskDim pics for each task;
    // 2. taskDim % batch_size == 0, taskDim / batch_size tasks for one pic;
    // 3. else, each pic divided to taskDim picies
    int batch_task_id = taskId;
    int start_batch = 0;
    int end_batch = batch_size;
    int d_row_seg = d_row / taskDim + int(d_row % taskDim != 0);
    int start_row = d_row_seg * taskId;
    int end_row = std::min(d_row_seg * (taskId + 1), (int)d_row);
    if (batch_size % taskDim == 0) {
      start_batch = taskId * (batch_size / taskDim);
      end_batch = start_batch + (batch_size / taskDim);
      d_row_seg = d_row;
      start_row = 0;
      end_row = d_row;
    }
    if ((taskDim > batch_size) && (taskDim % batch_size == 0)) {
      int task_num_per_pic = taskDim / batch_size;
      start_batch = taskId / task_num_per_pic;
      end_batch = start_batch + 1;
      d_row_seg = d_row / task_num_per_pic + int(d_row % task_num_per_pic != 0);
      batch_task_id = taskId % (taskDim / batch_size);
      start_row = d_row_seg * batch_task_id;
      end_row = std::min(d_row_seg * (batch_task_id + 1), (int)d_row);
    }

    int ci = CI_0;
    int conv_mult_limit = CONV_MULT_LIMIT_0;
    if (chn_num == 3) {
      ci = CI_1;
      conv_mult_limit = CONV_MULT_LIMIT_1;
    }

    for (uint32_t batch_idx = start_batch; batch_idx < end_batch; batch_idx ++) {
      uint32_t roi_x = src_rois[4 * batch_idx];
      uint32_t roi_y = src_rois[4 * batch_idx + 1];
      uint32_t roi_w = src_rois[4 * batch_idx + 2];
      uint32_t roi_h = src_rois[4 * batch_idx + 3];
      // uint32_t roi_w = src_rois[4 * batch_idx + 2] - roi_x;
      // uint32_t roi_h = src_rois[4 * batch_idx + 3] - roi_y;
      float scale_x = (float)roi_w / (float)d_col;
      float scale_y = (float)roi_h / (float)d_row;

      // ((d_x + 0.5) * scale_x - 0.5 = 1) => (d_x = 1.5 / scale_x - 0.5)
      // mult = d_x - 0
      int mult = (int)(roi_w < d_col) * __float2int_up(1.5 / scale_x - 0.5) +
                 (int)(roi_w >= d_col);

      int dst_num_limit = find_limit(roi_w, d_col, mult, chn_num, sizeof(float));
      int per_dst_num = std::min(dst_num_limit, (int)d_col);
      int per_dst_len = per_dst_num * chn_num;
      int per_dst_len_pad = CEIL_ALIGN(per_dst_len, 64);
      int repeat = d_col / per_dst_num;
      int remainder = d_col % per_dst_num;
      if (repeat != 0 && remainder == 0) {
        repeat -= 1;
        remainder = per_dst_num;
      }
      int remainder_len = remainder * chn_num;
      int remainder_len_pad = CEIL_ALIGN(remainder_len, 64);

      int src_num = roi_w * per_dst_num / d_col + 3;
      src_num = src_num * (src_num <= roi_w) + roi_w * (src_num > roi_w);
      src_num = (repeat > 0) * src_num + (repeat == 0) * roi_w;
      int src_len = src_num * chn_num;
      int src_len_pad = CEIL_ALIGN(src_len, ci);

      int weight_num = per_dst_len_pad * 2;
      int mask_num = src_len_pad * mult;
      float* weight_x = (float *)buffer;
      float* mask_x0 = weight_x + weight_num;
      float* mask_x1 = mask_x0 + mask_num;
      float* src = mask_x1 + mask_num + 64;
      float* src_line0 = src + std::max(4 * per_dst_len_pad, 2 * mask_num);
      float* src_line1 = src_line0 + per_dst_len_pad * 2;

      float *cur_src = src_gdram[batch_idx];
      float *cur_dst = (float *)((uint8_t *)(dst_gdram[batch_idx]) + d_y * d_stride);

      // if mult = 1, do not need do conv operation
      // if mult > conv_mult_limit, filter is too big to put on wram
      if (mult > 1 && mult <= conv_mult_limit) {
        loadFilters(cpy_syn, (half *)buffer, ci, mult, chn_num);
      }

      int row_limit = roi_h - 1;
      int col_limit = roi_w - 1;
      int dst_num = per_dst_num;
      int dst_len = per_dst_len;
      int dst_len_pad = per_dst_len_pad;
      for (int i = 0; i < repeat + 1; i ++) {
        int start_col = i * per_dst_num;
        if (i == repeat) {
          dst_num = remainder;
          dst_len = remainder_len;
          dst_len_pad = remainder_len_pad;
        }
        float map_x = (start_col + 0.5) * scale_x - 0.5;
        map_x = map_x * (int)(map_x > 0);
        map_x = std::min((float)col_limit, map_x);
        int src_idx = (int)map_x;

        int src_remainder = roi_w - src_idx;
        src_num = std::min(src_num, src_remainder);
        int src_len = src_num * chn_num;
        int src_len_pad = CEIL_ALIGN(src_len, ci);
        int mask_len = src_len_pad * mult;

        __bang_write_zero(mask_x0, mask_len);
        __bang_write_zero(mask_x1, mask_len);
        genMaskAndWeights<float>(weight_x, mask_x0, mask_x1, scale_x, start_col,
                          chn_num, dst_num, mult, col_limit);

        float fy = 0.0;
        int sy_0 = 0;
        int sy_1 = 0;
        float wy0 = 0.0;
        float wy1 = 0.0;

        for (int row_idx = start_row; row_idx < end_row; ++row_idx) {
          float map_y = (row_idx + 0.5) * scale_y - 0.5;
          map_y = map_y * (int)(map_y > 0);
          map_y = std::min(map_y, (float)row_limit);
          sy_0 = (int)map_y;
          sy_1 = sy_0 + 1;
          if (sy_0 == row_limit) {
            sy_1 = sy_0;
          }

          int offset0 = (roi_y + sy_0) * s_stride
                        + (src_idx + roi_x) * chn_num * sizeof(float);
          int offset1 = (roi_y + sy_1) * s_stride
                        + (src_idx + roi_x) * chn_num * sizeof(float);
          if (mult <= conv_mult_limit) {
            __memcpy(src, (uint8_t *)cur_src + offset0,
                     src_len * sizeof(float), GDRAM2NRAM);
            __memcpy(src + src_len_pad, (uint8_t *)cur_src + offset1,
                     src_len * sizeof(float), GDRAM2NRAM);
          } else {
            __memcpy(src_line0, (uint8_t *)cur_src + offset0,
                     src_len * sizeof(float), GDRAM2NRAM);
            __memcpy(src_line0 + src_len_pad, (uint8_t *)cur_src + offset1,
                     src_len * sizeof(float), GDRAM2NRAM);

            // expand mult times
            for (int i = 0; i < mult; i ++) {
              __memcpy(src + i * chn_num, src_line0, chn_num * sizeof(float),
                       NRAM2NRAM, chn_num * mult * sizeof(float),
                       chn_num * sizeof(float), src_num - 1);
              __memcpy(src + mask_len + i * chn_num, src_line0 + src_len_pad,
                       chn_num * sizeof(float),
                       NRAM2NRAM, chn_num * mult * sizeof(float),
                       chn_num * sizeof(float), src_num - 1);
            }
          }

          // if mult > conv_mult_limit, filter is too big to put on wram
          if (mult > 1 && mult <= conv_mult_limit) {
            __bang_float2int16_rd((int16_t*)src_line0, src, src_len_pad * 2, -7);
            __bang_conv(src, (int16_t*)src_line0, (int16_t*)cpy_syn, ci, 1,
                        src_len_pad * 2 / ci, 1, 1, 1, 1, ci * mult, -7);
          }

          __bang_collect(src_line0, src, mask_x0, mask_len);
          __bang_collect(src_line0 + dst_len_pad, src, mask_x1, mask_len);
          __bang_collect(src_line1, src + mask_len, mask_x0, mask_len);
          __bang_collect(src_line1 + dst_len_pad, src + mask_len, mask_x1, mask_len);

          // one row of src may be used many times
          int next_row_idx = __float2int_up((sy_0 + 1.5) / scale_y - 0.5);
          next_row_idx = std::min(next_row_idx, row_limit);
          int src_reuse_num = std::max(1, next_row_idx - row_idx);
          for (int src_reuse = 0; src_reuse < src_reuse_num; src_reuse ++) {
            float map_y = (row_idx + 0.5) * scale_y - 0.5;
            map_y = map_y * (int)(map_y > 0);
            map_y = std::min(map_y, (float)row_limit);
            sy_0 = (int)map_y;
            fy = map_y - sy_0;
            wy0 = 1.f - fy;
            wy1 = 1.f - wy0;

            float* dst_line0 = src;
            float* dst_line1 = dst_line0 + 2 * dst_len_pad;
            __bang_mul(dst_line0, src_line0, weight_x, dst_len_pad * 2);
            __bang_add(dst_line0, dst_line0, dst_line0 + dst_len_pad, dst_len_pad);
            __bang_mul(dst_line1, src_line1, weight_x, dst_len_pad * 2);
            __bang_add(dst_line1, dst_line1, dst_line1 + dst_len_pad, dst_len_pad);

            __bang_mul_const(dst_line0, dst_line0, wy0, dst_len_pad);
            __bang_mul_const(dst_line1, dst_line1, wy1, dst_len_pad);
            __bang_add(dst_line0, dst_line0, dst_line1, dst_len_pad);

            float* dst = dst_line0;
            int dst_size = dst_len * sizeof(float);

            __memcpy((uint8_t *)cur_dst + row_idx * d_stride + d_x * chn_num * sizeof(float)
                     + i * per_dst_len * sizeof(float), dst, dst_size, NRAM2GDRAM);
            row_idx += 1;
          }  // for (int src_reuse = 0; src_reuse < src_reuse_num; src_reuse ++)
          row_idx -= 1;
        }  // for (int row_idx = start_row; row_idx < end_row; ++row_idx)
      }  // for (int i = 0; i < repeat + 1; i ++)
    }  // for (uint32_t batch_idx = start_batch; batch_idx < end_batch; batch_idx ++)
  }  // if (coreId != 0x80)
}
__mlu_global__ void MLUBlockKernelResizeRgbx(void **src_gdram,
                                            void **dst_gdram,
                                            uint32_t depth,
                                            uint32_t *src_rois,
                                            uint32_t batch_size,
                                            uint32_t s_height,
                                            uint32_t s_width,
                                            uint32_t s_stride,
                                            uint32_t d_x,
                                            uint32_t d_y,
                                            uint32_t d_col,
                                            uint32_t d_row,
                                            uint32_t d_stride,
                                            uint32_t chn_num) {
  if (depth == 1) {
    resizeRgbx<uint8_t>((uint8_t **)src_gdram,
                        (uint8_t **)dst_gdram,
                        src_rois,
                        batch_size,
                        s_height,
                        s_width,
                        s_stride,
                        d_x,
                        d_y,
                        d_col,
                        d_row,
                        d_stride,
                        chn_num);
  } else if (depth == 2) {
    resizeRgbx<half>((half **)src_gdram,
                     (half **)dst_gdram,
                     src_rois,
                     batch_size,
                     s_height,
                     s_width,
                     s_stride,
                     d_x,
                     d_y,
                     d_col,
                     d_row,
                     d_stride,
                     chn_num);
  } else if (depth == 4) {
    resizeRgbxFloat((float **)src_gdram,
                    (float **)dst_gdram,
                    src_rois,
                    batch_size,
                    s_height,
                    s_width,
                    s_stride,
                    d_x,
                    d_y,
                    d_col,
                    d_row,
                    d_stride,
                    chn_num);
  }
}
