/*************************************************************************
 * Copyright (C) [2019] by Cambricon, Inc. All rights reserved
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *************************************************************************/
#include "cnrt.h"
#include "mluop.h"
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include <pthread.h>

#define PRINT_TIME 1
#define THREADS_NUM 60

#define CNRT_ERROR_CHECK(ret)                                                  \
  if (ret != CNRT_RET_SUCCESS) {                                               \
    fprintf(stderr, "error occur, func: %s, line: %d\n", __func__, __LINE__);  \
    return 0;                                                                 \
  }

typedef struct {
  int algo;
  bool save_flag;
  uint32_t src_w;
  uint32_t src_h;
  uint32_t dst_w;
  uint32_t dst_h;
  uint32_t frame_num;
  uint32_t thread_num;
  const char *input_file;
  const char *output_file;
}param_ctx_t;

// read a raw yuv image file
// raw yuv files can be generated by ffmpeg, for example, using :
//  ffmpeg -i test.jpg -s 1920x1080 -pix_fmt nv12 test.yuv
// the returned image channels are contiguous, and Y stride=width, U and V
// stride=width/2 memory must be freed with free
int readRawYUV(const char *filename, uint32_t width, uint32_t height,
               uint8_t **YUV) {
  FILE *fp = fopen(filename, "rb");
  if (!fp) {
    perror("Error opening yuv image for read");
    return 1;
  }

  // check file size
  fseek(fp, 0, SEEK_END);
  uint32_t size = ftell(fp);
  if (size != (width * height + 2 * ((width + 1) / 2) * ((height + 1) / 2))) {
    fprintf(stderr, "Wrong size of yuv image : %d bytes, expected %d bytes\n",
            size,
            (width * height + 2 * ((width + 1) / 2) * ((height + 1) / 2)));
    fclose(fp);
    return 2;
  }
  fseek(fp, 0, SEEK_SET);

  *YUV = malloc(size);
  size_t result = fread(*YUV, 1, size, fp);
  if (result != size) {
    perror("Error reading yuv image");
    fclose(fp);
    return 3;
  }
  fclose(fp);
  return 0;
}

// write a raw yuv image file
// ffmpeg -s cif -pix_fmt nv12 -i test1.yuv test_cif.jpg
int saveRawYUV(const char *filename, uint32_t width, uint32_t height,
               const uint8_t *YUV, size_t y_stride, size_t uv_stride) {
  FILE *fp = fopen(filename, "wb");
  if (!fp) {
    perror("Error opening yuv image for write");
    return 1;
  }

  if (y_stride == width) {
    fwrite(YUV, 1, width * height, fp);
    YUV += width * height;
  } else {
    for (uint32_t y = 0; y < height; ++y) {
      fwrite(YUV, 1, width, fp);
      YUV += y_stride;
    }
  }

  if (uv_stride == ((width + 1) / 2)) {
    fwrite(YUV, 1, ((width + 1) / 2) * ((height + 1) / 2) * 2, fp);
  } else {
    for (uint32_t y = 0; y < ((height + 1) / 2); ++y) {
      fwrite(YUV, 1, ((width + 1) / 2), fp);
      YUV += uv_stride;
    }

    for (uint32_t y = 0; y < ((height + 1) / 2); ++y) {
      fwrite(YUV, 1, ((width + 1) / 2), fp);
      YUV += uv_stride;
    }
  }

  fclose(fp);
  return 0;
}

static int set_cnrt_ctx(unsigned int device_id, cnrtChannelType_t channel_id) {
  cnrtDev_t dev;
  cnrtRet_t ret;
  ret = cnrtGetDeviceHandle(&dev, device_id);
  CNRT_ERROR_CHECK(ret);
  ret = cnrtSetCurrentDevice(dev);
  CNRT_ERROR_CHECK(ret);
  if (channel_id >= CNRT_CHANNEL_TYPE_0) {
    ret = cnrtSetCurrentChannel(channel_id);
    CNRT_ERROR_CHECK(ret);
  }
  return 0;
}

static int h2d_process(uint8_t *yuv, int input_w, int input_h, int output_w,
                       int output_h, char **input_mlu_yuv,
                       char **output_mlu_yuv, char **output_cpu_yuv) {
  int src_img_size = input_w * input_h * 3 / 2;
  int dst_img_size = output_w * output_h * 3 / 2;
  cnrtRet_t ret;
  ret = cnrtMalloc((void **)(input_mlu_yuv), sizeof(char) * src_img_size);
  CNRT_ERROR_CHECK(ret);
  ret = cnrtMalloc((void **)(output_mlu_yuv), sizeof(char) * dst_img_size);
  CNRT_ERROR_CHECK(ret);
  ret = cnrtMemcpy((void *)(*input_mlu_yuv), yuv, src_img_size,
                   CNRT_MEM_TRANS_DIR_HOST2DEV);
  CNRT_ERROR_CHECK(ret);
  *output_cpu_yuv = malloc(sizeof(char) * dst_img_size);
  return 0;
}

static int d2h_process(char *output_cpu_yuv, void *dst_y_mlu_in_cpu,
                    void *dst_uv_mlu_in_cpu, int dst_w, int dst_h) {
  cnrtRet_t ret;
  ret = cnrtMemcpy((void *)output_cpu_yuv, dst_y_mlu_in_cpu, dst_w * dst_h,
                   CNRT_MEM_TRANS_DIR_DEV2HOST);
  CNRT_ERROR_CHECK(ret);
  ret = cnrtMemcpy((void *)(output_cpu_yuv + dst_w * dst_h), dst_uv_mlu_in_cpu,
                   dst_w * dst_h / 2, CNRT_MEM_TRANS_DIR_DEV2HOST);
  CNRT_ERROR_CHECK(ret);
  return 0;
}

void *process_resize_plugin_yuv(void *ctx_) {
  param_ctx_t *ctx = (param_ctx_t *)ctx_; 
  cnrtRet_t ret;
  int algo = ctx->algo;
  bool save_flag = ctx->save_flag;
  uint32_t width = ctx->src_w;
  uint32_t height =  ctx->src_h;
  uint32_t dst_w = ctx->dst_w;
  uint32_t dst_h = ctx->dst_h;
  uint32_t frame_num = ctx->frame_num;
  uint32_t thread_num = ctx->thread_num;
  const char *filename = ctx->input_file;
  const char *output_file =ctx->output_file;

  uint8_t *input_cpu_yuv = NULL;
  if (readRawYUV(filename, width, height, &input_cpu_yuv) != 0) {
    printf("Error reading image file, check that the file exists and has the "
           "correct format and resolution.\n");
    return NULL;
  }
  char *input_mlu_yuv = NULL;
  char *output_mlu_yuv = NULL;
  char *output_cpu_yuv = NULL;

  set_cnrt_ctx(0, -1 /* CNRT_CHANNEL_TYPE_0 */);
  h2d_process(input_cpu_yuv, width, height, dst_w, dst_h, &input_mlu_yuv,
              &output_mlu_yuv, &output_cpu_yuv);

  HANDLE handle;
  #if PRINT_TIME
  float time_use = 0;
  struct timeval end;
  struct timeval start;
  gettimeofday(&start, NULL);
  #endif
  /*--------init op--------*/
  mluop_resize_yuv_plugin_init(&handle, width, height, 0, dst_w, dst_h, 0, 0);
  #if PRINT_TIME
  gettimeofday(&end, NULL);
  time_use = (end.tv_sec - start.tv_sec) * 1000000 + (end.tv_usec - start.tv_usec);
  printf("[init] time: %.3f ms\n", time_use/1000);
  #endif

  void *src_y_mlu_in_cpu = (uint8_t *)(input_mlu_yuv);
  void *src_uv_mlu_in_cpu = (uint8_t *)(input_mlu_yuv) + width * height;
  void *dst_y_mlu_in_cpu = (uint8_t *)(output_mlu_yuv);
  void *dst_uv_mlu_in_cpu = (uint8_t *)(output_mlu_yuv) + dst_w * dst_h;
  #if PRINT_TIME
  gettimeofday(&start, NULL);
  #endif
  /*-------execute op-------*/
  for (int i = 0; i < frame_num; i++) {
    mluop_resize_yuv_plugin_exec(handle, src_y_mlu_in_cpu, src_uv_mlu_in_cpu,
                          dst_y_mlu_in_cpu, dst_uv_mlu_in_cpu);
    // for gandong test
    // d2h_process(output_cpu_yuv, dst_y_mlu_in_cpu, dst_uv_mlu_in_cpu, dst_w, dst_h);
    // printf("-------------num: %d\n", i);
  }
  #if PRINT_TIME
  gettimeofday(&end, NULL);
  time_use = (end.tv_sec - start.tv_sec) * 1000000 + (end.tv_usec - start.tv_usec);
  printf("[exec] time(ave.): %.3f ms, total frame: %d\n", (time_use/1000.0)/frame_num, frame_num);
  #endif
  /*----------D2H-----------*/
  d2h_process(output_cpu_yuv, dst_y_mlu_in_cpu, dst_uv_mlu_in_cpu, dst_w, dst_h);
  #if PRINT_TIME
  gettimeofday(&start, NULL);
  #endif
  /*-------destroy op-------*/
  mluop_resize_yuv_plugin_destroy(handle);
  #if PRINT_TIME  
  gettimeofday(&end, NULL);
  time_use = (end.tv_sec - start.tv_sec) * 1000000 + (end.tv_usec - start.tv_usec);
  printf("[destroy] time: %.3f ms\n", time_use/1000);
  #endif
  /*-------sace file-------*/
  if (save_flag)
      saveRawYUV(output_file, dst_w, dst_h, (uint8_t *)output_cpu_yuv, dst_w,
             ((dst_w + 1) / 2));
  if (input_cpu_yuv)
    free(input_cpu_yuv);
  if (input_mlu_yuv)
    cnrtFree(input_mlu_yuv);
  if (output_mlu_yuv)
    cnrtFree(output_mlu_yuv);
  if (output_cpu_yuv)
    free(output_cpu_yuv);
}

void *process_resize_invoke_yuv(void *ctx_) {
  param_ctx_t *ctx = (param_ctx_t *)ctx_; 
  cnrtRet_t ret;
  int algo = ctx->algo;
  bool save_flag = ctx->save_flag;
  uint32_t width = ctx->src_w;
  uint32_t height =  ctx->src_h;
  uint32_t dst_w = ctx->dst_w;
  uint32_t dst_h = ctx->dst_h;
  uint32_t frame_num = ctx->frame_num;
  uint32_t thread_num = ctx->thread_num;
  const char *filename = ctx->input_file;
  const char *output_file =ctx->output_file;

  uint8_t *input_cpu_yuv = NULL;
  if (readRawYUV(filename, width, height, &input_cpu_yuv) != 0) {
    printf("Error reading image file, check that the file exists and has the "
           "correct format and resolution.\n");
    return NULL;
  }
  char *input_mlu_yuv = NULL;
  char *output_mlu_yuv = NULL;
  char *output_cpu_yuv = NULL;

  set_cnrt_ctx(0, -1 /* CNRT_CHANNEL_TYPE_0 */);
  h2d_process(input_cpu_yuv, width, height, dst_w, dst_h, &input_mlu_yuv,
              &output_mlu_yuv, &output_cpu_yuv);

  HANDLE handle;
  #if PRINT_TIME
  float time_use = 0;
  struct timeval end;
  struct timeval start;
  gettimeofday(&start, NULL);
  #endif
  /*--------init op--------*/
  mluop_resize_yuv_invoke_init(&handle, width, height, 0, dst_w, dst_h, 0, 0);
  #if PRINT_TIME
  gettimeofday(&end, NULL);
  time_use = (end.tv_sec - start.tv_sec) * 1000000 + (end.tv_usec - start.tv_usec);
  printf("[init] time: %.3f ms\n", time_use/1000);
  #endif

  void *src_y_mlu_in_cpu = (uint8_t *)(input_mlu_yuv);
  void *src_uv_mlu_in_cpu = (uint8_t *)(input_mlu_yuv) + width * height;
  void *dst_y_mlu_in_cpu = (uint8_t *)(output_mlu_yuv);
  void *dst_uv_mlu_in_cpu = (uint8_t *)(output_mlu_yuv) + dst_w * dst_h;
  #if PRINT_TIME
  gettimeofday(&start, NULL);
  #endif
  /*-------execute op-------*/
  for (int i = 0; i < frame_num; i++) {
    mluop_resize_yuv_invoke_exec(handle, src_y_mlu_in_cpu, src_uv_mlu_in_cpu,
                          dst_y_mlu_in_cpu, dst_uv_mlu_in_cpu);
    // for gandong test
    // d2h_process(output_cpu_yuv, dst_y_mlu_in_cpu, dst_uv_mlu_in_cpu, dst_w, dst_h);
    // printf("-------------num: %d\n", i);
  }
  #if PRINT_TIME
  gettimeofday(&end, NULL);
  time_use = (end.tv_sec - start.tv_sec) * 1000000 + (end.tv_usec - start.tv_usec);
  printf("[exec] time(ave.): %.3f ms, total frame: %d\n", (time_use/1000.0)/frame_num, frame_num);
  #endif
  /*----------D2H-----------*/
  d2h_process(output_cpu_yuv, dst_y_mlu_in_cpu, dst_uv_mlu_in_cpu, dst_w, dst_h);
  #if PRINT_TIME
  gettimeofday(&start, NULL);
  #endif
  /*-------destroy op-------*/
  mluop_resize_yuv_invoke_destroy(handle);
  #if PRINT_TIME  
  gettimeofday(&end, NULL);
  time_use = (end.tv_sec - start.tv_sec) * 1000000 + (end.tv_usec - start.tv_usec);
  printf("[destroy] time: %.3f ms\n", time_use/1000);
  #endif
  /*-------sace file-------*/
  if (save_flag)
      saveRawYUV(output_file, dst_w, dst_h, (uint8_t *)output_cpu_yuv, dst_w,
             ((dst_w + 1) / 2));
  if (input_cpu_yuv)
    free(input_cpu_yuv);
  if (input_mlu_yuv)
    cnrtFree(input_mlu_yuv);
  if (output_mlu_yuv)
    cnrtFree(output_mlu_yuv);
  if (output_cpu_yuv)
    free(output_cpu_yuv);
}

void printInfo(void *ctx_) {
  param_ctx_t *ctx = (param_ctx_t *)ctx_; 
  printf("----------------------------------\n");
  printf("argv[1]: %s \n", ctx->input_file);
  printf("argv[2]: %d \n", ctx->src_w);
  printf("argv[3]: %d \n", ctx->src_h);
  printf("argv[4]: %d \n", ctx->dst_w);
  printf("argv[5]: %d \n", ctx->dst_h);
  printf("argv[6]: %s \n", ctx->output_file);
  printf("argv[7]: %d \n", ctx->frame_num);
  printf("argv[8]: %d \n", ctx->thread_num);
  printf("argv[9]: %d \n", ctx->save_flag);
  printf("argv[10]: %d \n", ctx->algo);
  printf("----------------------------------\n");
}

int main(int argc, char **argv) {
  cnrtRet_t cnrt_ret;
  cnrt_ret = cnrtInit(0);
  CNRT_ERROR_CHECK(cnrt_ret);
  if (argc < 5) {
    printf("-------------------------description----------------------------\n");
    printf("Usage :\n");
    printf("./test mluop <src_yuv_file> <src_width> <src_height> <dst_width>"
           " <dst_height> <dst_yuv_file> <frame_num> <thread_num> <save_flag> <algo>\n");
    printf("Algo list:\n");
    printf("[0] <--> process_resize_plugin_yuv\n");
    printf("[1] <--> process_resize_invoke_yuv\n");
    printf("----------------------------------------------------------------\n");
    return 1;
  }

  param_ctx_t *ctx = malloc(sizeof(param_ctx_t));
  memset(ctx, 0, sizeof(param_ctx_t));
  ctx->input_file = argv[1];
  ctx->output_file = argv[6];
  ctx->src_w = atoi(argv[2]);
  ctx->src_h = atoi(argv[3]);
  ctx->dst_w = atoi(argv[4]);
  ctx->dst_h = atoi(argv[5]);
  ctx->frame_num = atoi(argv[7]);
  ctx->thread_num = atoi(argv[8]);
  ctx->save_flag = atoi(argv[9]);
  ctx->algo = atoi(argv[10]);

  if (ctx->algo <= 0) ctx->algo = 0;
  if (ctx->dst_w <= 0) ctx->dst_w = 352;
  if (ctx->dst_h <= 0) ctx->dst_h = 288;
  if (ctx->save_flag <= 0) ctx->save_flag = 0;
  if (ctx->frame_num <= 0) ctx->frame_num = 10;
  if (ctx->thread_num <= 0) ctx->thread_num = THREADS_NUM;
  // printInfo(ctx);

  int ret = 0;
  pthread_t tids[THREADS_NUM];
  pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
  for (int i = 0; i < ctx->thread_num; i++) {
    printf("create thead [%d]\n", i);
    if (0 == ctx->algo) {
      printf("exec algo[%d]: process_resize_plugin_yuv \n", ctx->algo);
      ret = pthread_create(&tids[i], &attr, process_resize_plugin_yuv, (void *)ctx);
    } else if (1 == ctx->algo) {
      ret = pthread_create(&tids[i], &attr, process_resize_invoke_yuv, (void *)ctx);
      printf("exec algo[%d]: process_resize_invoke_yuv \n", ctx->algo);
    } else
      printf("don't support algo ...\n");
  }
  void *status = NULL;
  pthread_attr_destroy(&attr);
  for (int i = 0; i < ctx->thread_num; i++) {
    ret = pthread_join(tids[i], &status);
    if (ret != 0){
        printf("pthread_join error(thread id :%lu): error_code=%d\n",(long unsigned)tids[i], ret);
    } else {
        printf("pthread_join ok(thread id :%lu): get status:=%ld\n",(long unsigned)tids[i], (long)status);
    }
  }
  free(ctx);
  cnrtDestroy();
  printf("main() : program exiting.\n");

  return 0;
}
