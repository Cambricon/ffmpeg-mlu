/*************************************************************************
 * Copyright (C) [2019] by Cambricon, Inc. All rights reserved
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *************************************************************************/

#include "mluop.h"
#include "mluop_list.h"
#include <assert.h>
#include "test_mluop.h"

// read a raw yuv image file
// raw yuv files can be generated by ffmpeg, for example, using :
//  ffmpeg -i test.jpg -s 1920x1080 -pix_fmt nv12 test.yuv
// the returned image channels are contiguous, and Y stride=width, U and V
// stride=width/2 memory must be freed with free

void yuv2yuv_resize_op(void *ctx_, char **argv) {
  param_ctx_t *ctx = (param_ctx_t *)ctx_;
  ctx->algo = atoi(argv[1]);
  ctx->input_file = argv[2];
  ctx->src_w = atoi(argv[3]);
  ctx->src_h = atoi(argv[4]);
  ctx->dst_w = atoi(argv[5]);
  ctx->dst_h = atoi(argv[6]);
  ctx->output_file = argv[7];
  ctx->pix_fmt = argv[8];
  ctx->frame_num = atoi(argv[9]);
  ctx->thread_num = atoi(argv[10]);
  ctx->save_flag = atoi(argv[11]);
  ctx->device_id = atoi(argv[12]);
  ctx->depth_size = 1; // depth_size: 1->uint8, 2->f16, 4->f32

  char depth_[3] = "8U";
  ctx->depth = depth_;

  if (ctx->algo <= 0) ctx->algo = 0;
  if (ctx->dst_w <= 0) ctx->dst_w = 352;
  if (ctx->dst_h <= 0) ctx->dst_h = 288;
  if (ctx->save_flag <= 0) ctx->save_flag = 0;
  if (ctx->frame_num <= 0) ctx->frame_num = 10;
  if (ctx->thread_num <= 0) ctx->thread_num = THREADS_NUM;

  int ret = 0;
  void *status = NULL;
  pthread_t tids[THREADS_NUM];
  pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);

  for (uint32_t i = 0; i < ctx->thread_num; i++) {
    printf("create thead [%d]\n", i);
    ret = pthread_create(&tids[i], &attr, process_resize_yuv, (void *)ctx);
  }

  pthread_attr_destroy(&attr);
  for (uint32_t i = 0; i < ctx->thread_num; i++) {
    ret = pthread_join(tids[i], &status);
    if (ret != 0){
        printf("pthread_join error(thread id :%lu): error_code=%d\n",(long unsigned)tids[i], ret);
    } else {
        printf("pthread_join ok(thread id :%lu): get status:=%ld\n",(long unsigned)tids[i], (long)status);
    }
  }
}

void *process_resize_yuv(void *ctx_) {
  param_ctx_t *ctx = (param_ctx_t *)ctx_;
  bool save_flag = ctx->save_flag;
  uint32_t width = ctx->src_w;
  uint32_t height =  ctx->src_h;
  uint32_t dst_w = ctx->dst_w;
  uint32_t dst_h = ctx->dst_h;
  uint32_t frame_num = ctx->frame_num;
  uint32_t device_id = ctx->device_id;
  const char *depth = ctx->depth;
  const char *filename = ctx->input_file;
  const char *output_file =ctx->output_file;
  set_cnrt_ctx(device_id, CNRT_CHANNEL_TYPE_NONE /* CNRT_CHANNEL_TYPE_0 */);

  uint8_t *input_cpu_yuv = (uint8_t *)malloc(width * height * 3 / 2 * sizeof(uint8_t));

  FILE *fp = fopen(filename, "rb");
  size_t read_size = fread(input_cpu_yuv, 1, width * height * 3 / 2 * sizeof(uint8_t), fp);
  fclose(fp);
  if (read_size != width * height * 3 / 2 * sizeof(uint8_t)) {
    printf("read file size failed!\n");
    free(input_cpu_yuv);
    return NULL;
  }

  HANDLE handle;
  #if PRINT_TIME
  float time_use = 0;
  struct timeval end;
  struct timeval start;
  gettimeofday(&start, NULL);
  #endif

  /*--------init op--------*/
  mluop_resize_yuv_init(&handle, width, height, dst_w, dst_h, depth, ctx->pix_fmt);
  #if PRINT_TIME
  gettimeofday(&end, NULL);
  time_use = (end.tv_sec - start.tv_sec) * 1000000 + (end.tv_usec - start.tv_usec);
  printf("[init] time: %.3f ms\n", time_use/1000);
  #endif

  uint32_t src_y_elem_size = height * PAD_UP(width, ALIGN_Y_SCALE);
  uint32_t src_uv_elem_size = height / 2 * PAD_UP(width, ALIGN_Y_SCALE);
  uint32_t dst_y_elem_size = PAD_UP(dst_w, ALIGN_Y_SCALE) * dst_h;
  uint32_t dst_uv_elem_size = PAD_UP(dst_w, ALIGN_Y_SCALE) * dst_h / 2;
  uint32_t dst_elem_size = dst_y_elem_size + dst_uv_elem_size;

  void *src_y_mlu;
  void *src_uv_mlu;
  void *dst_y_mlu;
  void *dst_uv_mlu;
  cnrtMalloc((void **)(&src_y_mlu), src_y_elem_size);
  cnrtMalloc((void **)(&src_uv_mlu), src_uv_elem_size);
  cnrtMalloc((void **)(&dst_y_mlu), dst_y_elem_size);
  cnrtMalloc((void **)(&dst_uv_mlu), dst_uv_elem_size);
  cnrtMemcpy(src_y_mlu, input_cpu_yuv, src_y_elem_size,
             CNRT_MEM_TRANS_DIR_HOST2DEV);
  cnrtMemcpy(src_uv_mlu, (input_cpu_yuv + src_y_elem_size), src_uv_elem_size,
             CNRT_MEM_TRANS_DIR_HOST2DEV);

  uint8_t *dst_yuv_cpu = (uint8_t *)malloc(dst_elem_size);

  /*-------execute op-------*/

  for (uint32_t i = 0; i < frame_num; i++) {
    cnrtMemcpy(src_y_mlu, input_cpu_yuv, src_y_elem_size,
              CNRT_MEM_TRANS_DIR_HOST2DEV);
    cnrtMemcpy(src_uv_mlu, (input_cpu_yuv + src_y_elem_size), src_uv_elem_size,
              CNRT_MEM_TRANS_DIR_HOST2DEV);
    #if PRINT_TIME
    gettimeofday(&start, NULL);
    #endif
    mluop_resize_yuv_exec(handle, src_y_mlu, src_uv_mlu,
                          dst_y_mlu, dst_uv_mlu);
    /* mluop_resize_roi_yuv_exec(handle, src_y_mlu, src_uv_mlu,
                                 dst_y_mlu, dst_uv_mlu, 0,0,960,540,10,10,640,360); */
    /* mluop_resize_pad_yuv_exec(handle, src_y_mlu, src_uv_mlu,
                                 dst_y_mlu, dst_uv_mlu);*/

    #if PRINT_TIME
    gettimeofday(&end, NULL);
    time_use = (end.tv_sec - start.tv_sec) * 1000000 + (end.tv_usec - start.tv_usec);
    printf("[exec] time(ave.): %.3f ms, total frame: %d\n", (time_use/1000.0)/frame_num, frame_num);
    #endif
    /*----------D2H-----------*/
    cnrtMemcpy(dst_yuv_cpu, dst_y_mlu, dst_y_elem_size,
               CNRT_MEM_TRANS_DIR_DEV2HOST);
    cnrtMemcpy((dst_yuv_cpu + dst_y_elem_size), dst_uv_mlu, dst_uv_elem_size,
                CNRT_MEM_TRANS_DIR_DEV2HOST);
  }

  #if PRINT_TIME
  gettimeofday(&start, NULL);
  #endif
  /*-------destroy op-------*/
  mluop_resize_yuv_destroy(handle);

  #if PRINT_TIME
  gettimeofday(&end, NULL);
  time_use = (end.tv_sec - start.tv_sec) * 1000000 + (end.tv_usec - start.tv_usec);
  printf("[destroy] time: %.3f ms\n", time_use/1000);
  #endif
  /*-------sace file-------*/
  if (save_flag) {
    FILE *fp_out = fopen(output_file, "wb");
    fwrite(dst_yuv_cpu, 1, dst_elem_size, fp_out);
    fclose(fp_out);
  }

  if (input_cpu_yuv)
    free(input_cpu_yuv);
  if (dst_yuv_cpu)
    free(dst_yuv_cpu);
  if (src_y_mlu)
    cnrtFree(src_y_mlu);
  if (src_uv_mlu)
    cnrtFree(src_uv_mlu);
  if (dst_y_mlu)
    cnrtFree(dst_y_mlu);
  if (dst_uv_mlu)
    cnrtFree(dst_uv_mlu);

  return NULL;
}
