/*************************************************************************
 * Copyright (C) [2019] by Cambricon, Inc. All rights reserved
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *************************************************************************/
#include "cnrt.h"
#include "mluop_plugin.h"
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define CNRT_ERROR_CHECK(ret)                                                  \
  if (ret != CNRT_RET_SUCCESS) {                                               \
    fprintf(stderr, "error occur, func: %s, line: %d\n", __func__, __LINE__);  \
    return -1;                                                                 \
  }
// read a raw yuv image file
// raw yuv files can be generated by ffmpeg, for example, using :
//  ffmpeg -i test.jpg -s 1920x1080 -pix_fmt nv12 test.yuv
// the returned image channels are contiguous, and Y stride=width, U and V
// stride=width/2 memory must be freed with free
int readRawYUV(const char *filename, uint32_t width, uint32_t height,
               uint8_t **YUV) {
  FILE *fp = fopen(filename, "rb");
  if (!fp) {
    perror("Error opening yuv image for read");
    return 1;
  }

  // check file size
  fseek(fp, 0, SEEK_END);
  uint32_t size = ftell(fp);
  if (size != (width * height + 2 * ((width + 1) / 2) * ((height + 1) / 2))) {
    fprintf(stderr, "Wrong size of yuv image : %d bytes, expected %d bytes\n",
            size,
            (width * height + 2 * ((width + 1) / 2) * ((height + 1) / 2)));
    fclose(fp);
    return 2;
  }
  fseek(fp, 0, SEEK_SET);

  *YUV = malloc(size);
  size_t result = fread(*YUV, 1, size, fp);
  if (result != size) {
    perror("Error reading yuv image");
    fclose(fp);
    return 3;
  }
  fclose(fp);
  return 0;
}

// write a raw yuv image file
// ffmpeg -s cif -pix_fmt nv12 -i test1.yuv test_cif.jpg
int saveRawYUV(const char *filename, uint32_t width, uint32_t height,
               const uint8_t *YUV, size_t y_stride, size_t uv_stride) {
  FILE *fp = fopen(filename, "wb");
  if (!fp) {
    perror("Error opening yuv image for write");
    return 1;
  }

  if (y_stride == width) {
    fwrite(YUV, 1, width * height, fp);
    YUV += width * height;
  } else {
    for (uint32_t y = 0; y < height; ++y) {
      fwrite(YUV, 1, width, fp);
      YUV += y_stride;
    }
  }

  if (uv_stride == ((width + 1) / 2)) {
    fwrite(YUV, 1, ((width + 1) / 2) * ((height + 1) / 2) * 2, fp);
  } else {
    for (uint32_t y = 0; y < ((height + 1) / 2); ++y) {
      fwrite(YUV, 1, ((width + 1) / 2), fp);
      YUV += uv_stride;
    }

    for (uint32_t y = 0; y < ((height + 1) / 2); ++y) {
      fwrite(YUV, 1, ((width + 1) / 2), fp);
      YUV += uv_stride;
    }
  }

  fclose(fp);
  return 0;
}
static int set_cnrt_ctx(unsigned int device_id, cnrtChannelType_t channel_id) {
  cnrtDev_t dev;
  cnrtRet_t ret;
  ret = cnrtGetDeviceHandle(&dev, device_id);
  CNRT_ERROR_CHECK(ret);
  ret = cnrtSetCurrentDevice(dev);
  CNRT_ERROR_CHECK(ret);
  if (channel_id >= CNRT_CHANNEL_TYPE_0) {
    ret = cnrtSetCurrentChannel(channel_id);
    CNRT_ERROR_CHECK(ret);
  }
  return 0;
}

static int h2d_process(uint8_t *yuv, int input_w, int input_h, int output_w,
                       int output_h, char **input_mlu_yuv,
                       char **output_mlu_yuv, char **output_cpu_yuv) {
  int src_img_size = input_w * input_h * 3 / 2;
  int dst_img_size = output_w * output_h * 3 / 2;
  cnrtRet_t ret;
  ret = cnrtMalloc((void **)(input_mlu_yuv), sizeof(char) * src_img_size);
  CNRT_ERROR_CHECK(ret);
  ret = cnrtMalloc((void **)(output_mlu_yuv), sizeof(char) * dst_img_size);
  CNRT_ERROR_CHECK(ret);
  ret = cnrtMemcpy((void *)(*input_mlu_yuv), yuv, src_img_size,
                   CNRT_MEM_TRANS_DIR_HOST2DEV);
  CNRT_ERROR_CHECK(ret);
  *output_cpu_yuv = malloc(sizeof(char) * dst_img_size);
  return 0;
}

int process_resize_yuv(int argc, char **argv) {
  if (argc < 5) {
    printf("Usage : test mluop <yuv image file> <image width> <image height> "
           "<output template filename>\n");
    return 1;
  }
  const int iteration_number = 65536;
  printf("Time will be measured in each configuration for %d iterations...\n",
         iteration_number);

  const char *filename = argv[1];
  uint32_t width, height;
  const char *out;
  // parse argument line
  width = atoi(argv[2]);
  height = atoi(argv[3]);
  out = argv[4];
  uint8_t *input_cpu_yuv = NULL;
  if (readRawYUV(filename, width, height, &input_cpu_yuv) != 0) {
    printf("Error reading image file, check that the file exists and has the "
           "correct format and resolution.\n");
    return 1;
  }
  char *input_mlu_yuv = NULL;
  char *output_mlu_yuv = NULL;
  char *output_cpu_yuv = NULL;
  int dst_w = 352;
  int dst_h = 288;
  cnrtRet_t ret;
  set_cnrt_ctx(0, -1 /* CNRT_CHANNEL_TYPE_0 */);
  h2d_process(input_cpu_yuv, width, height, dst_w, dst_h, &input_mlu_yuv,
              &output_mlu_yuv, &output_cpu_yuv);
  HANDLE handle;
  clock_t t = clock();
  mluop_resize_yuv_init(&handle, width, height, 0, dst_w, dst_h, 0, 0);
  t = clock() - t;
  printf("[int] time : %f sec\n", ((float)t) / CLOCKS_PER_SEC);
  void *src_y_mlu_in_cpu = (uint8_t *)(input_mlu_yuv);
  void *src_uv_mlu_in_cpu = (uint8_t *)(input_mlu_yuv) + width * height;
  void *dst_y_mlu_in_cpu = (uint8_t *)(output_mlu_yuv);
  void *dst_uv_mlu_in_cpu = (uint8_t *)(output_mlu_yuv) + dst_w * dst_h;
  t = clock();
  for (int i = 0; i < iteration_number; i++) {
    mluop_resize_yuv_exec(handle, src_y_mlu_in_cpu, src_uv_mlu_in_cpu,
                          dst_y_mlu_in_cpu, dst_uv_mlu_in_cpu);
  }
  t = clock() - t;
  printf("[exec] average time : %f sec, iteration number: %d\n",
         ((float)t) / (CLOCKS_PER_SEC * iteration_number), iteration_number);
  ret = cnrtMemcpy((void *)output_cpu_yuv, dst_y_mlu_in_cpu, dst_w * dst_h,
                   CNRT_MEM_TRANS_DIR_DEV2HOST);
  CNRT_ERROR_CHECK(ret);
  ret = cnrtMemcpy((void *)(output_cpu_yuv + dst_w * dst_h), dst_uv_mlu_in_cpu,
                   dst_w * dst_h / 2, CNRT_MEM_TRANS_DIR_DEV2HOST);
  CNRT_ERROR_CHECK(ret);
  t = clock();
  mluop_resize_yuv_destroy(handle);
  t = clock() - t;
  printf("[destroy] time : %f sec\n", ((float)t) / CLOCKS_PER_SEC);
  saveRawYUV(out, dst_w, dst_h, (uint8_t *)output_cpu_yuv, dst_w,
             ((dst_w + 1) / 2));
  if (input_cpu_yuv)
    free(input_cpu_yuv);
  if (input_mlu_yuv)
    cnrtFree(input_mlu_yuv);
  if (output_mlu_yuv)
    cnrtFree(output_mlu_yuv);
  if (output_cpu_yuv)
    free(output_cpu_yuv);

  return 0;
}

int main(int argc, char **argv) {
  cnrtRet_t ret;
  ret = cnrtInit(0);
  CNRT_ERROR_CHECK(ret);
  process_resize_yuv(argc, argv);
  cnrtDestroy();
  return 0;
}
